
\begin{shadequote}[r]{켄 톰슨(Ken Thompson)}
새로운 것은 유닉스와 같은 종류의 혁명과 함께 와야 한다. IBM을 무력화시키는 무언가가 나타나기 전까지 그 어떤 것도 IBM을 무너뜨릴 수 없었다. 물론 메인프레임 시장을 굳건히 지키고 있겠지만, 그건 무의미할 뿐이다. Microsoft도 마찬가지다. Microsoft를 무의미하게 만드는 무언가가 나타나기 전까지는 진입 장벽이 너무 높아서 대체되지 않을 것이다.
\end{shadequote}





## 배경

사람과 컴퓨터는 일반적으로 키보드와 마우스, 터치스크린 인터페이스, 음성 인식 시스템 등 다양한 방식으로 의사소통한다.
개인용 컴퓨터와 상호 작용하는 가장 널리 사용되는 방법이 그래픽 사용자 인터페이스(GUI)다. GUI를 통해 메뉴를 고르고 마우스를 클릭해서 컴퓨터에 수행할 작업을 지시한다. \index{GUI} \index{그래픽 사용자 인터페이스}

GUI는 시각을 통해 직관적으로 학습할 수 있지만, 이와 같은 방식으로 컴퓨터에 명령을 전달하는 하는 경우 확장성이 매우 떨어진다.

문헌 검색을 위해 서로 다른 1,000개 디렉터리에 있는 텍스트 파일 1,000개에서 세 번째 줄을 복사하여 하나의 파일에 붙여넣어야 하는 작업을 상상해 보자. GUI를 사용하면 몇 시간 동안 책상 앞에서 클릭만 해야 할 뿐만 아니라 이러한 반복적인 작업을 수행하는 과정에서 오류가 발생할 수 있다. 바로 이 부분에서 유닉스 쉘(Unix Shell)이 진가를 발휘한다. \index{유닉스 쉘}

유닉스 쉘은 명령라인 인터페이스(CLI)이자 스크립팅 언어이기 때문에 이러한 반복적인 작업을 자동으로 빠르고 효과적으로 수행할 수 있다. 적절한 명령어를 쉘 문법에 맞춰 적절히 사용하면 쉘은 원하는 만큼 반복작업을 수행할 수 있다. 
결론적으로 쉘을 사용하면 앞에서 언급된 문헌 검색 작업을 몇 초 만에 완료할 수 있다. \index{CLI} \index{명령라인 인터페이스}

## 쉘

쉘은 사용자가 명령을 입력할 수 있는 프로그램이다. 쉘을 사용하면 기후 예측모형 소프트웨어와 같은 복잡한 프로그램을 호출하거나 코드 한줄로 빈 디렉터리를 생성하는 간단한 명령도 실행시킬 수 있다.

가장 널리 사용되는 유닉스 쉘은 여전히 배쉬(본 어게인 셸이라고도 불리는데, 스티븐 본이 만든 셸에서 파생되어 붙여진 명칭)로 서로 다른 운영체제 호환성과 하위 호환성 측면에서 다른 어떤 유닉스 쉘 프로그램도 따라갈 수 없는 장점을 갖고 있다. \index{배쉬} \index{bash}

깃배쉬('Git Bash')는 윈도우 사용자가 깃(Git)과 상호 작용할 때 배쉬와 유사한 인터페이스를 제공하는 프로그램이다. \index{깃배쉬} \index{Git Bash}

쉘을 사용하려면 약간의 노력과 시간은 반듯이 필요하다. GUI는 선택할 수 있는 옵션이 표시되지만 CLI는 선택 항목이 자동으로 표시되지 않고 프롬프트만 깜빡거린다. 챗GPT를 처음 접한 경험과 비슷하다. 새로운 외국어나 프로그래밍 언어를 학습할 때처럼 새로운 어휘 즉, 몇 가지 명령어를 외우고 있어야 한다. 하지만 구어와 달리 몇 개의 '단어'(즉, 명령어)만 익혀도 큰 도움이 되기 때문에 큰 스트레스는 없다. \index{명령어}

쉘 문법을 사용하면 기존 도구를 강력한 파이프라인으로 결합시켜 자동으로 대용량 데이터 처리가 가능하다. 그리고 쉘 스크립트로 주석과 함께 관리할 경우 작업흐름의 재현성과 투명성도 크게 향상시킬 수 있다. 클라우드가 대세가 되면서, CLI는 원격 컴퓨터 및 슈퍼컴퓨터와 작업하는 기본기가 되었다. \index{데이터 파이프라인} \index{클라우드} \index{HPC}

## 어떻게 생겼을까? {#shell-looks-like}

시작해 보자.

쉘을 처음 열면 쉘이 작업 명령을 기다리고 있음을 나타내는 **프롬프트(Prompt)**가 다음과 같이 표시된다. \index{프롬프트} \index{prompt}

```bash
$
```

셸은 일반적으로 `$`를 프롬프트로 사용하지만 다른 기호를 사용할 수도 있다. 본서에서는 프롬프트를 `$`로 표시한다. 
명령어를 입력할 때 프롬프트를 입력하지 않는다는 것을 명심한다. 즉, 프롬프트 다음에 오는 명령만 입력한다. 이 규칙은 이곳 뿐만 아니라 다음 장을 포함한 전체 적용된다. 또한, 명령어를 입력한 후 필히 엔터(Enter) 키를 눌러야 쉘 명령이 실행된다.

프롬프트 뒤에 **텍스트 커서(Text Cursor)**, 즉 입력할 위치가 표시되는 문자가 나타난다. 커서는 일반적으로 깜박이거나 단단한 블록모양이지만, 경우에 따라서 밑줄이나 파이프 모양일 수도 있다. 예를 들어, 텍스트 편집기 프로그램에서 커서를 본 적이 있을 것이다.\index{\$} \index{커서} \index{cursor}

프롬프트가 약간 다르게 보일 수 있다. 특히 대부분의 쉘 환경에서는 기본 설정값으로 `$` 앞에 사용자 이름과 호스트 이름을 넣는다. 이러한 프롬프트는 예를 들어 다음과 같이 표시될 수 있다:


```bash
nelle@localhost $
```

프롬프트에 더 많은 정보가 포함될 수도 있다. 프롬프트가 `$`로 짧지 않더라도 걱정하지 말자. 본서에서는 이러한 추가 정보에 휘둘리지 말고, 방해받지 말아야 한다. 집중해야 할 유일한 중요한 점은 `$` 문자 자체이며 그 이유는 나중에 다시 살펴보겠다.

본서와 마찬가지로 프롬프트가 `$ `와 달라 눈에 거슬리는 경우, 명령어를 `PS1='$ '` 타이핑하게 되면 
동일하게 프롬프트를 맞출 수 있다. 하지만, 본인 취향에 맞추어 프롬프트를 다양하게 꾸밀 수 있다 - 흔히 프롬프트에
사용자명과 디렉토리 현재 위치정보를 포함하고 디렉토리\footnote{컴퓨터과학 분야에서는 주로 디렉토리라는 표현을 써왔다. 컴퓨터가 대중화되면서, 폴더라는 표현을 함께 써 오는 추세가 되었다.} 위치, 색상도 달리하여 심미감을 넣는 것이 일반적이다.


이제 리스팅(listing)의 줄임말인 첫 번째 명령어 `ls`를 사용해 봅시다. 이 명령은 현재 디렉터리의 내용을 보여준다:

```bash
$ ls
Desktop     Downloads   Movies      Pictures
Documents   Library     Music       Public
```


::: {.callout-note}
### Command not found 오류 {.unnumbered}

쉘이 타이핑한 명령어 이름을 갖는 프로그램을 찾을 수 없는 경우,
다음과 같은 오류 메시지가 출력된다:
 
```bash
$ ls-F
-bash: ls-F: command not found
```

일반적으로 명령어를 잘못 타이핑했다는 의미가 된다: 이 경우,
`ls` 와 `-F` 사이 공백을 빼먹어서 그렇다. 즉, `ls -F`와 같이 
명령을 전달하면 의도한 바가 기계에 정확히 전달된다.
:::


## 전형적인 쉘 명령어 구조

한걸음 더 들어가, 다음 명령어를 통해 전형적인 쉘 명령어 구조를 살펴보자.

```bash
bash-3.2$
bash-3.2$ ls -F / 
Applications/         System/
Library/              Users/
Network/              Volumes/
bash-3.2$ 
```

첫번째 줄은 **프롬프트(prompt)**만 보여주고 있고, 쉘이 입력준비가 되었다는 것을 나타낸다.\index{프롬프트}\index{prompt}
프롬프트로 다른 텍스트를 지정할 수도 있다. 가장 중요한 것:
명령어를 타이핑할 때, 프롬프트, 여기서는 'bash-3.2$', 를 타이핑하지 말고 쉘에서 인식되거나 수행될 수 있는 명령어만 타이핑한다.

예제 두번째 줄에서 타이핑한 `ls -F /` 부분이 전형적인 구조를 보여주고 있다:
**명령어(command)**, **플래그(flags)** (**선택옵션(options)** 혹은 **스위치(switches)**) 그리고 **인자(argument)**.\index{플래그(flag)} \index{선택옵션(options)} \index{스위치(switches)}\index{인자(argument)}
플래그는 대쉬(`-`) 혹은 더블 대쉬(`--`)로 시작하는데 명령어의 행동에 변화를 준다.

인자는 명령어에 작업할 대상을 일러준다(예를 들어, 파일명과 디렉토리).
종종 플래그를 매개변수(parameter)라고도 부른다.\index{패러미터(parameter)}
명령어를 플래그 한개 이상, 인자도 한개 이상 사용하기도 한다:
하지만, 명령어가 항상 인자 혹은 플래그를 요구하지는 않는다.

상기 예제의 두번째 줄에서, **명령어는** `ls`, **플래그**는 `-F`, 
**인자**는 `/`이 된다. 각각은 공백으로 뚜렷하게 구분된다:
만약 `ls` 와 `-F` 사이 공백을 넣지 않으며 쉘은 `ls-F` 명령어를 찾게 되는데,
존재하지 않는 명령어다. 또한, 대문자도 문제가 될 수 있다:
`LS` 명령어와 `ls` 명령어는 다르다.\index{ls}

다음으로 명령어가 생성한 출력결과를 살펴보자.
이번 경우에 `/` 폴더에 위치한 파일 목록을 출력하고 있다.
해당 출력결과가 무엇을 의미하는지 다룰 예정이지만, 맥OS를 사용하시는 분들은  출력결과를 이미 인지하고 있을 수도 있다.

마지막으로, 쉘은 프롬프트를 출력하고 다음 명령어가 타이핑되도록 대기모드로 바뀐다.

쉘 윈도우를 열고, `ls -F /` 명령어를 직접 타이핑한다.
(공백과 대문자가 중요함으로 잊지 말자.)
원하는 경우 프롬프트를 변경해도 좋다.

## `ls` 와 플래그 의미 파악 {#shell-ls}

모든 쉘 명령어는 컴퓨터 어딘가에 저장된 프로그램으로,
쉘은 명령어를 검색해서 찾을 장소를 목록으로 이미 가지고 있다.
명령목록은 PATH로 불리는 **변수(variable)**에 기록되어 있다.\footnote{이 개념을 나중에 다룰 것이다}
명령어, 플래그, 인자가 공백으로 구분된다는 점을 다시 상기하자.\index{PATH}\index{변수(variable)}

REPL(읽기-평가-출력-루프, Read-Evaluate-Print-Loop)를 좀더 살펴보자.
"평가(evaluate)" 단계는 두가지 부분으로 구성됨에 주목한다:


1. 타이핑한 것을 읽어들인다. (이번 예제에서 `ls -F /`) 
쉘은 공백을 사용해서 명령어로 입력된 것을 명령어, 플래그, 인자로 쪼갠다.
1. 평가(Evaluate):
  - `ls` 라는 프로그램을 찾는다.
  - 찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.
1. 프로그램 실행 결과를 출력한다.

그리고 나서, 프롬프트를 출력하고 또다른 명령어를 입력받도록 대기한다.


## 사례: 문제정의

해양 생물학자 넬 니모(Nell Nemo) 박사가 방금전 6개월간 [북태평양 소용돌이꼴](http://en.wikipedia.org/wiki/North_Pacific_Gyre) 조사를 마치고 방금 귀환했다. 
[태평양 거대 쓰레기 지대](http://en.wikipedia.org/wiki/Great_Pacific_Garbage_Patch)에서 젤리같은 해양생물을 표본추출했다. 총 합쳐서 1,520개 시료가 있고 다음 작업이 필요하다:

1.  서로 다른 300개 단백질의 상대적인 함유량을 측정하는 분석기계로 시료를 시험한다. 
     한 시료에 대한 컴퓨터 출력결과는 각 단백질에 대해 한 줄 파일형식으로 표현된다.
2.  그녀의 지도교수가 작성한 `goostat`라는 프로그램을 사용하여 각 단백질에
대한 통계량을 계산한다.
3.  다른 대학원 학생중 한명이 작성한 `goodiff`로 명명된 프로그램을 사용해서, 각 단백질에 대한 통계량과 다른 단백질에 대해 상응하는 통계량을 비교한다.
4.  결과를 작성한다. 그녀의 지도교수는 이달 말까지 이 작업을 정말로 마무리해서, 
     논문이 다음번 *Aquatic Goo Letters* 저널 특별판에 게재되기를 희망한다.


각 시료를 분석장비가 처리하는데 약 반시간 정도 소요된다. 
좋은 소식은 각 시료를 준비하는데는 단지 2분만 소요된다. 
연구실에 병렬로 사용할 수 있는 분석장비 8대가 있어서, 이 단계는 약 2주정도만 소요될 것이다.

나쁜 소식은 `goostat`, `goodiff`를 수작업으로 실행한다면, 파일이름 입력하고 “OK” 버튼을 45,150번 눌려야 된다는 사실이다 (`goostat` 300회 + `goodiff` $\frac{300 \times 299}{2}$). 매번 30초씩 가정하면 2주 이상 소요될 것이다. 논문 마감일을 놓칠 수도 있지만, 이 모든 명령어를 올바르게 입력할 가능성은 거의 0 에 가깝다.


다음 장에서는 그녀가 대신 수행할 작업을 탐색한다. 
좀더 구체적으로, 처리하는 파이프라인 중간에 반복되는 작업을 자동화하는데 쉘 명령어(command shell)를 어떻게 사용하는지 설명해서, 논문을 쓰는 동안에 컴퓨터가 하루에 24시간 작업한다. 
덤으로 중간 처리작업 파이프라인을 완성하면, 더 많은 데이터를 얻을 때마다 다시 재사용할 수 있게 된다.

추가적으로 일단 처리 파이프라인을 구축하면 더 많은 데이터를 수집할 때마다 재사용의 강력함을 경험할 수 있다. 파이프라인 구축 작업을 수행하기 위해 넬 박사는 다음과 같은 방법을 숙지해야 한다.

- 파일/디렉토리로 이동
- 파일/디렉토리 생성
- 파일 길이 확인
- 명령어를 조합하여 연결하기
- 파일셋 불러오기
- 파일별 반복작업
- 파이프라인을 담고 있는 쉘 스크립트(Shell Script) 실행


\begin{Exercise}\label{Ex1}

\noindent 1. 유닉스 쉘(Unix Shell)이 오랫동안 생존한 이유는 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  사용자로 하여금 키보드 몇 번 쳐서 복잡한 작업을 수행할 수 있게 만들기 때문
\task  고성능 컴퓨팅(High Performance Computing, HPC)를 사용할 수 있게 해주기 때문
\task  프로그램을 새로운 방식으로 조합하여 반복적인 작업을 자동화할 수 있게 해주기 때문
\task  상기 모두
\end{tasks}

\noindent 2. 명령-라인 인터페이스(CLI)의 핵심 기능은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  읽기-평가-출력(REPL,read-evaluate-print loop)
\task  WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)
\task  GUI (Graphical User Interface)
\task  컴퓨터와의 상호작용
\end{tasks}

\noindent 3. 다음 중 ls 명령어에 대한 올바른 설명은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  ls는 리스트의 약자로, 디렉토리의 내용을 보여주는 명령어입니다.
\task  ls는 항상 현재 디렉토리의 내용만 보여줍니다.
\task  ls 명령어는 파일이나 디렉토리를 삭제하는 데 사용됩니다.
\task  ls 명령어는 실행할 수 있는 프로그램을 찾는 데 사용됩니다.
\end{tasks}

\noindent 4. 쉘에 명령어를 입력하고 실행할 때의 순서를 올바르게 배열한 것은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  결과 출력 -> 프로그램 찾기 -> 타이핑한 것을 읽기 -> 프로그램 실행
\task  타이핑한 것을 읽기 -> 프로그램 찾기 -> 프로그램 실행 -> 결과 출력
\task  프로그램 찾기 -> 프로그램 실행 -> 타이핑한 것을 읽기 -> 결과 출력
\task  프로그램 실행 -> 결과 출력 -> 타이핑한 것을 읽기 -> 프로그램 찾기
\end{tasks}

\end{Exercise}



