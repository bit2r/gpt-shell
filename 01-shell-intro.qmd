
\begin{shadequote}[r]{화이트헤드(Alfred North Whitehead)}
문명은 생각하지 않고, 수행할 수 있는 중요한 작업의 수를 늘리면서 발전한다.(Civilization advances by extending the number of important operations which we can perform without thinking about them.)
\end{shadequote}

## 유닉스 쉘

사람과 컴퓨터는 일반적으로 키보드와 마우스, 터치스크린 인터페이스, 음성 인식 시스템 등 다양한 방식으로 의사소통한다. 개인용 컴퓨터와 상호 작용하는 가장 널리 사용되는 방법이 그래픽 사용자 인터페이스(GUI)다. GUI를 통해 메뉴를 고르고 마우스를 클릭해서 컴퓨터에 수행할 작업을 지시한다. GUI는 시각을 통해 직관적으로 학습할 수 있지만, 이와 같은 방식으로 컴퓨터에 명령을 전달하는 하는 경우 확장성이 매우 떨어진다. GUI는 시각을 통해 직관적으로 학습할 수 있지만, 이와 같은 방식으로 컴퓨터에 명령을 전달하는 하는 경우 확장성이 매우 떨어진다. \index{GUI} \index{그래픽 사용자 인터페이스}

문헌 검색을 위해 서로 다른 1,000개 디렉터리에 있는 텍스트 파일 1,000개에서 세 번째 줄을 복사하여 하나의 파일에 붙여넣어야 하는 작업을 상상해 보자. GUI를 사용하면 몇 시간 동안 책상 앞에서 클릭만 해야 할 뿐만 아니라 이러한 반복적인 작업을 수행하는 과정에서 오류가 발생할 수 있다. 바로 이 부분에서 유닉스 쉘(Unix Shell)이 진가를 발휘한다. \index{유닉스 쉘}

유닉스 쉘은 명령라인 인터페이스(CLI)이자 스크립팅 언어이기 때문에 이러한 반복적인 작업을 자동으로 빠르고 효과적으로 수행할 수 있다. 적절한 명령어를 쉘 문법에 맞춰 적절히 사용하면 쉘은 원하는 만큼 반복작업을 수행할 수 있다. 
결론적으로 쉘을 사용하면 앞에서 언급된 문헌 검색 작업을 몇 초 만에 완료할 수 있다. \index{CLI} \index{명령라인 인터페이스} [@bach1986design]


아주 높은 곳에서 바라보면, 컴퓨터는 네가지 일을 수행한다:

-   프로그램 실행
-   데이터 저장
-   컴퓨터간 상호 의사소통
-   사람과 상호작용


마지막 작업을 뇌-컴퓨터 연결, 음성 인터페이스를 포함한 다양한 많은 방식으로 수행하고 있고
최근 스마폰의 보급으로 모바일 인터페이스가 보편화되었지만, 
대부분 WIMP((Window 윈도우, Icon 아이콘, Mouse 마우스, Pointer 포인터)를 사용한다. 
1980년대까지 이러한 기술은 보편적이지 않았지만, 
기술의 뿌리는 1960년대 더그 엥겔바트(Doug Engelbart)의 작업에 기초하고 있고, 
"[The Mother of All Demos](http://www.youtube.com/watch?v=a11JDLBXtPQ)"에서 확인할 수 있다.

조금 더 멀리 거슬러 올라가면, 초기 컴퓨터와 상호작용하는 유일한 방법은 전선줄(와이어)로 연결하는 것이다. 1950년에서 1980년 사이 대부분의 사람들은 라인 프린터(line printer)를 사용했다. 이런 장치는 표준 키보드에 있는 문자, 숫자, 특수부호의 입력과 출력만 허용해서, 
프로그래밍 언어와 인터페이스는 이러한 제약사항에서 설계됐다.

여전히 전통적인 화면, 마우스, 터치패드, 키보드를 사용하고 있지만, 
터치 인터페이스와 음성 인터페이스도 점차 보편화되고 있다. 지금 대부분의 사람들이 사용하는 **그래픽 사용자 인터페이스(GUI, graphical user interface)**\index{GUI}\index{그래픽 사용자 인터페이스}과 구별하기 위해서 이런 종류의 인터페이스를 **명령-라인 인터페이스(CLI, command-line interface)**\index{CLI}\index{명령-라인 인터페이스}라고 한다. CLI의 핵심은 **읽기-평가-출력 루프(REPL, read-evaluate-print loop)**\index{REPL}이다: 사용자가 명령어를 타이핑하고 엔터(enter)/반환(return)키를 입력하면, 컴퓨터가 읽고, 실행하고, 결과를 출력한다. \index{읽기-평가-출력 루프} 즉, 사용자가 다른 명령을 타이핑하면 컴퓨터는 읽고 평가하고 출력하는 작업을 사용자가 로그 오프하고 시스템을 빠져 나갈때까지 무한 반복한다. R/파이썬 프로그래밍 언어를 스크립트 방식이 아닌 콘솔에서 단순한 프로그램 제작 작업한 경험이 있다면 REPL 개념을 이미 숙지 하고 있는 것이다.

GUI는 WIMP(Window 윈도우, Icon 아이콘, Mouse 마우스, Pointer 포인터)\index{WIMP}로 구성되는데 배우기 쉽고, 단순 작업에 대해서는 환상적이다. "클릭"하게 되면 명령이 "내가 원하는 작업을 수행해"라고 손쉽게 컴퓨터로 통역된다. 
하지만, 이런 마술은 단순한 작업을 수행하고, 정확하게 이러한 유형의 작업을 수행할 수 있는 프로그램에 한정된다.

만약 복잡하고, 특정 목적에 부합되는 훨씬 묵직한 작업을 컴퓨터에 내리고자 한다면,
난해하거나 어렵거나 할 필요는 없고, 명령 어휘가 몇개 필요하고 이를 사용하는데 필요한 단순한 문법만이 필요하다.

쉘이 이런 기능을 제공한다 - 단순한 언어로 이를 사용하는데 **명령-라인 인터페이스**가 필요하다.
명령라인 인터페이스의 심장은 **읽기-평가-출력 루프(REPL,read-evaluate-print loop)**다.
REPL로 불리는 이유는 쉘에 명령어를 타이핑하고 엔터키(Return)를 치면 컴퓨터가 명령어를 읽어들이고 나서, 평가(혹은 실행)하고 출력결과를 화면에 뿌린다. 또 다른 명령어를 입력할 때까지 대기하는 루프를 반복하게 된다.


상기 묘사가 마치 사용자가 직접 명령어를 컴퓨터에 보내고, 
컴퓨터는 다시 사용자에게 직접 출력을 보내는 것처럼 들린다.
사실 중간에 **명령 쉘(command shell)**\index{명령 쉘}\index{Command Shell}로 불리는 프로그램이 있다. 
사용자가 타이핑하는 것은 쉘로 간다. 
쉘은 무슨 명령어를 수행할지 파악해서 컴퓨터에게 수행하도록 지시한다.
쉘을 *조개 껍데기(shell)*\index{조개 껍데기}\index{Shell}\index{쉘}로 불리는데 이유는 운영체제를 감싸서, 
추상화(Abstraction)하여 복잡성 일부를 숨겨 운영체제와 상호작용을 더 단순하게 하는 역할을 수행한다.\index{추상화}


## 쉘(Shell) 소개 {#shell}

**유닉스 쉘(Unix Shell)**\index{유닉스 쉘}\index{Unix!Shell}은 대부분의 컴퓨터 사용자가 살아온 것보다 오래 동안 존재했다. 오래동안 생존한 이유는 사용자로 하여금 단지 키보드 몇번 쳐서 복잡한 작업을 수행할 수 있게 하는 강력한 도구이기 때문이다. 좀더 중요하게는 기존의 프로그램을 새로운 방식으로 조합해서 반복적인 작업을 자동화함으로써, 동일한 작업을 반복적으로 하지 않게 만든다.  쉘 사용은 폭넓게 다양하고 강력한 도구와 컴퓨팅 자원(슈퍼컴퓨터와 "고성능 컴퓨팅(High Performance Computing, HPC)"이 포함)을 사용하는 근본이 된다.\index{HPC}\index{고성능 컴퓨팅}

쉘은 사용자가 명령을 입력할 수 있는 프로그램이다. 쉘을 사용하면 기후 예측모형 소프트웨어와 같은 복잡한 프로그램을 호출하거나 코드 한줄로 빈 디렉터리를 생성하는 간단한 명령도 실행시킬 수 있다.

가장 널리 사용되는 유닉스 쉘은 여전히 배쉬(본 어게인 쉘이라고도 불리는데, 스티븐 본이 만든 쉘에서 파생되어 붙여진 명칭)로 서로 다른 운영체제 호환성과 하위 호환성 측면에서 다른 어떤 유닉스 쉘 프로그램도 따라갈 수 없는 장점을 갖고 있다. \index{배쉬} \index{bash}

깃배쉬('Git Bash')는 윈도우 사용자가 깃(Git)과 상호 작용할 때 배쉬와 유사한 인터페이스를 제공하는 프로그램이다. \index{깃배쉬} \index{Git Bash}

쉘을 사용하려면 약간의 노력과 시간은 반듯이 필요하다. GUI는 선택할 수 있는 옵션이 표시되지만 CLI는 선택 항목이 자동으로 표시되지 않고 프롬프트만 깜빡거린다. 챗GPT를 처음 접한 경험과 비슷하다. 새로운 외국어나 프로그래밍 언어를 학습할 때처럼 새로운 어휘 즉, 몇 가지 명령어를 외우고 있어야 한다. 하지만 구어와 달리 몇 개의 '단어'(즉, 명령어)만 익혀도 큰 도움이 되기 때문에 큰 스트레스는 없다. \index{명령어}

쉘 문법을 사용하면 기존 도구를 강력한 파이프라인으로 결합시켜 자동으로 대용량 데이터 처리가 가능하다. 그리고 쉘 스크립트로 주석과 함께 관리할 경우 작업흐름의 재현성과 투명성도 크게 향상시킬 수 있다. 클라우드가 대세가 되면서, CLI는 원격 컴퓨터 및 슈퍼컴퓨터와 작업하는 기본기가 되었다. \index{데이터 파이프라인} \index{클라우드} \index{HPC}


## 배쉬 쉘 {#shell-bash}

**쉘(Shell)**은 또한 프로그램이다. 그러나 그것을 조금 특별하게 만드는 것은 스스로 연산을 수행하기보다 다른 프로그램을 실행한다는 점이다. 가장 일반적으로 사용되는 유닉스 쉘(Unix Shell)은 Bash(Bourne Again SHell)이다. 이 이름은 Stephen Bourne이 작성한 원래의 쉘에서 유래했으며, 이는 프로그래머들 사이에서 재치있는 이름으로 통한다. Bash는 대부분의 유닉스 기반 컴퓨터에 기본적으로 설치된 쉘이며, 유닉스와 유사한 도구를 제공하는 대부분의 윈도우용 패키지에도 적용되어 있다. \index{Bash}\index{배쉬}


Bash나 다른 쉘을 사용하면 프로그래밍을 작성하는 느낌이 난다. 마우스 사용보다는 명령어를 입력하는 것이 더 간결하며, 이 명령어들은 보통 2~3자리 문자로 이루어져 있다. 결과 출력 역시 그래픽보다는 텍스트 형태로 제공된다. 쉘의 강력한 장점 중 하나는 키보드 입력만으로 다량의 데이터를 자동으로 처리하는 파이프라인을 구축할 수 있다는 점이다. 또한, 멀리 떨어진 컴퓨터나 슈퍼컴퓨터와 상호작용하기에는 명령 라인이 가장 편리하다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화 도구와 자원을 실행하는 데에는 쉘에 익숙해져야 한다. 클러스터 컴퓨팅과 클라우드 컴퓨팅이 과학적 데이터 분석(scientific data crunching)에 있어 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되었다. 여기서 배울 수 있는 명령-라인 기술을 기반으로 광범위한 과학적 질문과 컴퓨터적 도전을 처리할 수 있다. 


주요 유닉스 쉘에는 Bourne shell (sh), Bash, Zsh, C shell (csh), Tcsh, Korn shell (ksh) 등이 존
재한다. Bash 는 Bourne shell (sh)과 뿌리를 공유하고 하위 호환성을 갖는다. Zsh, csh, Tcsh,
ksh 를 비롯한 다양한 쉘 프로그램이 나름대로의 기능을 제시하며 사용자를 끌어들이고 있다. 배쉬는 유닉스/리눅스 계열 운영 체제에서 가장 널리 사용되는 쉘 프로그램으로, 배쉬로 작성된 스크립트는 대부분의 시스템에서 잘 동작하는 스크립트 호환성이 가장 큰 장점이다. 본서에서 이를 기본 쉘 프로그램으로 다룬다. \index{호환성} \index{Shell!Zsh} \index{Shell!Bash}

## 어려운가요? {#shell-difficulty}

**명령라인 인터페이스(CLI)**로 선택지가 명령어와 패러미터의 조합으로 표현된다. 그래픽 유저 인터페이스(GUI)와 비교하여 컴퓨터와 상호작용하는데 있어 다른 방식을 취하고 있어, 익숙해지는데 다소 노력과 시간이 소요된다. GUI는 선택지를 보여주고, 사용자가 선택지 중에서 선택하는 하는 것이다. CLI는 사용자에게 제시되는 것이 아니라서 새로운 언어의 어휘를 학습하듯이 일부 학습이 필요하다. 마치 영어 전체를 통달하는 것은 고통스럽고 시간이 많이 들지만, 생활영어 수준으로 영어를 배운다면 삶의 질을 크게 높일 수 있는 것처럼, 명령어의 일부만 배우게 되면 정말 도움이 많이 된다. 이 책에서는 소수의 핵심적인 명령어만을 중점으로 다룬다.


## 유연성과 자동화 {#shell-flexibility}

쉘문법(Grammar of Shell)은 기존 명령어 도구를 조합해서 강력한 파이프라인을 구축하도록 한다.\index{쉘문법(Grammar of Shell)}
이를 통해서 방대한 데이터를 자동화하여 다룰 수 있다. 명령 순서는 *스크립트 (script)*로 작성하여
작업흐름의 재현가능성을 향상시켜서 쉽게 반복이 가능하도록 한다. 스크립트 작성은 이후 소개할 것이다.\index{스크립트(script)}

추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬
운 방법이다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데
쉘과 친숙성이 거의 필연적이다. 클러스트 컴퓨팅(Cluster Computing, 여러 대의 컴퓨터를 연결하여 단일 시스템처럼 작동)과 클라우드 컴퓨팅(Cloud Computing, 사용자가 필요한 만큼의 컴퓨팅 자원을 인터넷을 통해 제공받을 수 있는 서비스)을 활용한 과학 데이터 크런칭(scientific data cruching)\footnote{'과학적 데이터 크런칭'은 대량의 과학 데이터를 분석하고 처리하는 과정을 의미한다. 이는 대형 가속기에서 생성된 데이터, 천문학적 관측, 생명 과학에서의 유전자 시퀀싱 등 다양한 과학적 분야에서 생성된 대규모 데이터셋을 분석하는데 사용된다. '크런칭(crunching)'이라는 용어는 일반적으로 대규모 데이터를 처리하거나 분석하는 것을 의미하는 비공식적인 용어인데, '과학적 데이터 크런칭'은 이러한 대규모 데이터를 이해하고, 통찰력을 얻으며, 그 결과를 이용하여 과학적 질문에 답하는데 사용되는 방법을 말한다.}이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다. 여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다.


## 어떻게 생겼을까? {#shell-looks-like}

시작해 보자.

쉘을 처음 열면 쉘이 작업 명령을 기다리고 있음을 나타내는 **프롬프트(Prompt)**가 다음과 같이 표시된다. \index{프롬프트} \index{prompt}

```bash
$
```

쉘은 일반적으로 `$`를 프롬프트로 사용하지만 다른 기호를 사용할 수도 있다. 본서에서는 프롬프트를 `$`로 표시한다. 
명령어를 입력할 때 프롬프트를 입력하지 않는다는 것을 명심한다. 즉, 프롬프트 다음에 오는 명령만 입력한다. 이 규칙은 이곳 뿐만 아니라 다음 장을 포함한 전체 적용된다. 또한, 명령어를 입력한 후 필히 엔터(Enter) 키를 눌러야 쉘 명령이 실행된다.

프롬프트 뒤에 **텍스트 커서(Text Cursor)**, 즉 입력할 위치가 표시되는 문자가 나타난다. 커서는 일반적으로 깜박이거나 단단한 블록모양이지만, 경우에 따라서 밑줄이나 파이프 모양일 수도 있다. 예를 들어, 텍스트 편집기 프로그램에서 커서를 본 적이 있을 것이다.\index{\$} \index{커서} \index{cursor}

프롬프트가 약간 다르게 보일 수 있다. 특히 대부분의 쉘 환경에서는 기본 설정값으로 `$` 앞에 사용자 이름과 호스트 이름을 넣는다. 이러한 프롬프트는 예를 들어 다음과 같이 표시될 수 있다:


```bash
nelle@localhost $
```

프롬프트에 더 많은 정보가 포함될 수도 있다. 프롬프트가 `$`로 짧지 않더라도 걱정하지 말자. 본서에서는 이러한 추가 정보에 휘둘리지 말고, 방해받지 말아야 한다. 집중해야 할 유일한 중요한 점은 `$` 문자 자체이며 그 이유는 나중에 다시 살펴보겠다.

본서와 마찬가지로 프롬프트가 `$ `와 달라서 눈에 거슬리는 경우, 명령어를 `PS1='$ '` 타이핑하게 되면 동일하게 프롬프트를 맞출 수 있다. 하지만, 본인 취향에 맞추어 프롬프트를 다양하게 꾸밀 수 있다 - 흔히 프롬프트에 사용자명과 디렉토리 현재 위치정보를 포함하고 디렉토리\footnote{컴퓨터과학 분야에서는 주로 디렉토리(directory)라는 표현을 써왔다. 컴퓨터가 대중화되면서, 폴더(folder)라는 표현을 함께 써 오는 추세가 되었다.} 위치, 색상도 달리하여 심미감을 넣는 것이 일반적이다.


이제 리스팅(listing, 목록화)의 줄임말인 첫 번째 명령어 `ls`를 사용해 봅시다. 이 명령은 현재 디렉터리의 내용을 보여준다:

```bash
$ ls
Desktop     Downloads   Movies      Pictures
Documents   Library     Music       Public
```


::: {.callout-note}
### Command not found 오류 {.unnumbered}

쉘이 타이핑한 명령어 이름을 갖는 프로그램을 찾을 수 없는 경우,
다음과 같은 오류 메시지가 출력된다:
 
```bash
$ ls-F
-bash: ls-F: command not found
```

일반적으로 명령어를 잘못 타이핑했다는 의미가 된다: 이 경우,
`ls` 와 `-F` 사이 공백을 빼먹어서 그렇다. 즉, `ls -F`와 같이 
명령을 전달하면 의도한 바가 기계에 정확히 전달된다.
:::


## 전형적인 쉘 명령어 구조

한걸음 더 들어가, 다음 명령어를 통해 전형적인 쉘 명령어 구조를 살펴보자.

```bash
bash-3.2$
bash-3.2$ ls -F / 
Applications/         System/
Library/              Users/
Network/              Volumes/
bash-3.2$ 
```

첫번째 줄은 **프롬프트(prompt)**만 보여주고 있고, 쉘이 입력준비가 되었다는 것을 나타낸다.\index{프롬프트}\index{prompt}
프롬프트로 다른 텍스트를 지정할 수도 있다. 가장 중요한 것:
명령어를 타이핑할 때, 프롬프트, 여기서는 'bash-3.2$', 를 타이핑하지 말고 쉘에서 인식되거나 수행될 수 있는 명령어만 타이핑한다.

예제 두번째 줄에서 타이핑한 `ls -F /` 부분이 전형적인 구조를 보여주고 있다:
**명령어(command)**, **플래그(flags, 선택옵션(options) 혹은 스위치(switches))** 그리고 **인자(argument)**.\index{플래그(flag)} \index{선택옵션(options)} \index{스위치(switches)}\index{인자(argument)}
플래그는 대쉬(`-`) 혹은 더블 대쉬(`--`)로 시작하는데 명령어의 행동에 변화를 준다.

인자는 명령어에 작업할 대상을 일러준다(예를 들어, 파일명과 디렉토리).
종종 플래그를 매개변수(parameter)라고도 부른다.\index{패러미터(parameter)}
명령어를 플래그 한개 이상, 인자도 한개 이상 사용하기도 한다:
하지만, 명령어가 항상 인자 혹은 플래그를 요구하지는 않는다.

상기 예제의 두번째 줄에서, **명령어는** `ls`, **플래그**는 `-F`, 
**인자**는 `/`이 된다. 각각은 공백으로 뚜렷하게 구분된다:
만약 `ls` 와 `-F` 사이 공백을 넣지 않으며 쉘은 `ls-F` 명령어를 찾게 되는데, 존재하지 않는 명령어를 알리는 메세지가 화면에 출력된다. 또한, 대문자도 문제가 될 수 있다: LS 명령어와 ls 명령어는 다르다.\index{ls}

다음으로 명령어가 생성한 출력결과를 살펴보자.
이번 경우에 `/` 폴더에 위치한 파일 목록을 출력하고 있다.
해당 출력결과가 무엇을 의미하는지 다룰 예정이지만, 맥OS를 사용하시는 분들은  출력결과를 이미 인지하고 있을 수도 있다.

마지막으로, 쉘은 프롬프트를 출력하고 다음 명령어가 타이핑되도록 대기모드로 바뀐다.

쉘 윈도우를 열고, `ls -F /` 명령어를 직접 타이핑한다.
(공백과 대문자가 중요함으로 잊지 말자.)
원하는 경우 프롬프트를 변경해도 좋다.

## `ls` 와 플래그 의미 파악 {#shell-ls}

모든 쉘 명령어는 컴퓨터 어딘가에 저장된 프로그램으로,
쉘은 명령어를 검색해서 찾을 장소를 목록으로 이미 가지고 있다.
명령목록은 PATH로 불리는 **변수(variable)**에 기록되어 있다.\footnote{이 개념을 나중에 루프(Loop)에서 다룰 것이다}
명령어, 플래그, 인자가 공백으로 구분된다는 점을 다시 상기하자.\index{PATH}\index{변수(variable)}

REPL(읽기-평가-출력 루프, Read-Evaluate-Print Loop)를 좀더 살펴보자.
"평가(evaluate)" 단계는 두가지 부분으로 구성됨에 주목한다:


1. 타이핑한 것을 읽어들인다. (이번 예제에서 `ls -F /`) 
쉘은 공백을 사용해서 명령어로 입력된 것을 명령어, 플래그, 인자로 쪼갠다.
1. 평가(Evaluate):
  - `ls` 라는 프로그램을 찾는다.
  - 찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.
1. 프로그램 실행 결과를 출력한다.

그리고 나서, 프롬프트를 출력하고 또다른 명령어를 입력받도록 대기한다.


## 사례: 문제정의

해양 생물학자 넬 니모(Nell Nemo) 박사가 방금전 6개월간 [북태평양 소용돌이꼴](http://en.wikipedia.org/wiki/North_Pacific_Gyre) 조사를 마치고 방금 귀환했다. 
[태평양 거대 쓰레기 지대](http://en.wikipedia.org/wiki/Great_Pacific_Garbage_Patch)에서 젤리같은 해양생물을 표본추출했다. 총 합쳐서 1,520개 시료가 있고 다음 작업이 필요하다:

1.  서로 다른 300개 단백질의 상대적인 함유량을 측정하는 분석기계로 시료를 시험한다. 
     한 시료에 대한 컴퓨터 출력결과는 각 단백질에 대해 한 줄 파일형식으로 표현된다.
2.  그녀의 지도교수가 작성한 `goostat`라는 프로그램을 사용하여 각 단백질에
대한 통계량을 계산한다.
3.  다른 대학원 학생중 한명이 작성한 `goodiff`로 명명된 프로그램을 사용해서, 각 단백질에 대한 통계량과 다른 단백질에 대해 상응하는 통계량을 비교한다.
4.  결과를 작성한다. 그녀의 지도교수는 이달 말까지 이 작업을 정말로 마무리해서, 
     논문이 다음번 *Aquatic Goo Letters* 저널 특별판에 게재되기를 희망한다.


각 시료를 분석장비가 처리하는데 약 반시간 정도 소요된다. 
좋은 소식은 각 시료를 준비하는데는 단지 2분만 소요된다. 
연구실에 병렬로 사용할 수 있는 분석장비 8대가 있어서, 이 단계는 약 2주정도만 소요될 것이다.

나쁜 소식은 `goostat`, `goodiff`를 수작업으로 실행한다면, 파일이름 입력하고 “OK” 버튼을 45,150번 눌려야 된다는 사실이다 (`goostat` 300회 + `goodiff` $\frac{300 \times 299}{2}$). 매번 30초씩 가정하면 2주 이상 소요될 것이다. 논문 마감일을 놓칠 수도 있지만, 이 모든 명령어를 올바르게 입력할 가능성은 거의 0 에 가깝다.


다음 장에서는 그녀가 대신 수행할 작업을 탐색한다. 
좀더 구체적으로, 처리하는 파이프라인 중간에 반복되는 작업을 자동화하는데 쉘 명령어(command shell)를 어떻게 사용하는지 설명해서, 논문을 쓰는 동안에 컴퓨터가 하루에 24시간 작업한다. 
덤으로 중간 처리작업 파이프라인을 완성하면, 더 많은 데이터를 얻을 때마다 다시 재사용할 수 있게 된다.

추가적으로 일단 처리 파이프라인을 구축하면 더 많은 데이터를 수집할 때마다 재사용의 강력함을 경험할 수 있다. 파이프라인 구축 작업을 수행하기 위해 넬 박사는 다음과 같은 방법을 숙지해야 한다.

- 파일/디렉토리로 이동
- 파일/디렉토리 생성
- 파일 길이 확인
- 명령어를 조합하여 연결하기
- 파일셋 불러오기
- 파일별 반복작업
- 파이프라인을 담고 있는 쉘 스크립트(Shell Script) 실행


\begin{Exercise}\label{Ex1}

\noindent 1. 유닉스 쉘(Unix Shell)이 오랫동안 생존한 이유는 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  사용자로 하여금 키보드 몇 번 쳐서 복잡한 작업을 수행할 수 있게 만들기 때문
\task  고성능 컴퓨팅(High Performance Computing, HPC)를 사용할 수 있게 해주기 때문
\task  프로그램을 새로운 방식으로 조합하여 반복적인 작업을 자동화할 수 있게 해주기 때문
\task  상기 모두
\end{tasks}

\noindent 2. 명령-라인 인터페이스(CLI)의 핵심 기능은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  읽기-평가-출력(REPL,read-evaluate-print loop)
\task  WIMP(Window(윈도우), Icon(아이콘), Mouse(마우스), Pointer(포인터))
\task  GUI (Graphical User Interface)
\task  컴퓨터와의 상호작용
\end{tasks}

\noindent 3. 다음 중 ls 명령어에 대한 올바른 설명은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  ls는 리스트의 약자로, 디렉토리의 내용을 보여주는 명령어입니다.
\task  ls는 항상 현재 디렉토리의 내용만 보여줍니다.
\task  ls 명령어는 파일이나 디렉토리를 삭제하는 데 사용됩니다.
\task  ls 명령어는 실행할 수 있는 프로그램을 찾는 데 사용됩니다.
\end{tasks}

\noindent 4. 쉘에 명령어를 입력하고 실행할 때의 순서를 올바르게 배열한 것은 무엇인가요?
\begin{tasks}[label=(\arabic*)](1)
\task  결과 출력 -> 프로그램 찾기 -> 타이핑한 것을 읽기 -> 프로그램 실행
\task  타이핑한 것을 읽기 -> 프로그램 찾기 -> 프로그램 실행 -> 결과 출력
\task  프로그램 찾기 -> 프로그램 실행 -> 타이핑한 것을 읽기 -> 결과 출력
\task  프로그램 실행 -> 결과 출력 -> 타이핑한 것을 읽기 -> 프로그램 찾기
\end{tasks}

\end{Exercise}



```{=tex}
\titlebox{챗GPT 유닉스 쉘}{Cbluejeans}{챗GPT는 자연어인 프롬프트를 유닉스 실행 명령어로 통역을 해준다. 유닉스 쉘에 대한 기본 지식만 있다면 챗GPT를 통해 유창한 대화가 가능하다. }
```

유닉스 쉘 명령어가 기억나지 않는다면 ShellGPT를 사용하여 해당 작업을 신속하게 수행할 수 있다. ShellGPT 프로그램을 설치한 후에 `sgpt -s` 명령어 다음에 자연어를 넣게 되면 자연어를 유닉스 쉘 명령어로 변환한 것을 제시하고 설명이 필요하면 `D` 키를 누르고 사용자가 원한다면 `E` 키를 눌러 즉석에서 실행도 가능하다.\footnote{제2부 GPT 데이터 과학에서 sgpt 설치를 비롯한 자세한 내용이 기술되어 있어 필요하면 미리 제8장 관련 내용을 읽어보는 것도 좋은 전략이 될 듯 싶다. }


### 파일과 디렉토리 출력 {-}

`sgpt -s` 다음에 자연어로 해당 디렉토리에 포함된 파일과 디렉토리를 구별하여 출력하는 유닉스 명령어를 확인하고 실행을 통해 결과를 확인한다.

> 프롬프트: 현재 디렉토리에서 파일과 디렉토리 내용을 구분하여 출력해주세요

``` bash
$ sgpt -s "현재 디렉토리에서 파일과 디렉토리 내용을 구분하여 출력해주세요"
ls -F
[E]xecute, [D]escribe, [A]bort: D
The "ls -F" command lists the files and directories in the current directory, and appends a symbol to each entry indicating its type (e.g., "/" for directories, "*" for executables).
[E]xecute, [D]escribe, [A]bort: E
exercise-data/  north-pacific-gyre/
```

챗GPT가 프롬프트로 작성한 유닉스 쉘 명령어를 해석하면 다음과 같다.

> "ls -F" 명령은 현재 디렉터리에 있는 파일과 디렉터리를 나열하고 각 항목에 해당 유형을 나타내는 기호(예: 디렉터리의 경우 "/", 실행 파일의 경우 "*")를 추가한다.

얻어진 유닉스 쉘 명령어를 실행하게 되면 현재 디렉토리 아래 디렉토리 두개를 출력한다.
