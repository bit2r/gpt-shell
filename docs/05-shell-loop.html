<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="kr" xml:lang="kr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>gpt-shell - 2&nbsp; 루프(Loops)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./04-shell-pipefilter.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">루프(Loops)</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">gpt-shell</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-shell-pipefilter.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">파이프와 필터</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-shell-loop.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">루프(Loops)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">참고문헌</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#nelle-shell-loop" id="toc-nelle-shell-loop" class="nav-link active" data-scroll-target="#nelle-shell-loop"><span class="toc-section-number">2.1</span>  Nelle의 파이프라인: 많은 파일 처리하기</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="shell-loop" class="quarto-section-identifier d-none d-lg-block"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">루프(Loops)</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>반복적으로 명령어를 실행하게 함으로써 자동화를 통해서 <strong>루프</strong>는 생산성 향상에 핵심이 된다. 와일드카드와 탭 자동완성과 유사하게, 루프를 사용하면 타이핑 상당량(타이핑 실수)을 줄일 수 있다. 와일드카드와 탭 자동완성은 타이핑을 (타이핑 실수를) 줄이는 두가지 방법이다. 또다른 것은 쉘이 반복해서 특정 작업을 수행하게 하는 것이다. <code>basilisk.dat</code>, <code>unicorn.dat</code> 등으로 이름 붙여진 게놈 데이터 파일이 수백개 있다고 가정하자. 이번 예제에서, 단지 두개 예제 파일만 있는 <code>creatures</code> 디렉토리를 사용할 것이지만 동일한 원칙은 훨씬 더 많은 파일에 즉시 적용될 수 있다. 디렉토리에 있는 파일을 변경하고 싶지만, 원본 파일을 <code>original-basilisk.dat</code>와 <code>original-unicorn.dat</code>으로 이름을 변경해서 저장한다. 하지만 다음 명령어를 사용할 수 없다:</p>
<pre><code>$ cp *.dat original-*.dat</code></pre>
<p>왜냐하면 상기 두 파일 경우에 전개가 다음과 같이 될 것이기 때문이다:</p>
<pre><code>$ cp basilisk.dat unicorn.dat original-*.dat</code></pre>
<p>상기 명령어는 파일을 백업하지 않고 대신에 오류가 발생된다:</p>
<pre><code>cp: target `original-*.dat' is not a directory</code></pre>
<p><code>cp</code> 명령어는 입력값 두개 이상을 받을 때 이런 문제가 발생한다. 이런 상황이 발생할 때, 마지막 입력값을 디렉토리로 예상해서 모든 파일을 해당 디렉토리로 넘긴다. <code>creatures</code> 디렉토리에는 <code>original-*.dat</code> 라고 이름 붙은 하위 디렉토리가 없기 때문에, 오류가 생긴다.</p>
<p>대신에, 리스트에서 한번에 연산작업을 하나씩 수행하는 <strong>루프(loop)</strong>를 사용할 수 있다. 교대로 각 파일에 대해 첫 3줄을 화면에 출력하는 단순한 예제가 다음에 나와 있다:</p>
<pre><code>$ for filename in basilisk.dat unicorn.dat
&gt; do
&gt;    head -n 3 $filename    # 루프 내부에 들여쓰기는 가독성에 도움을 준다.
&gt; done

COMMON NAME: basilisk
CLASSIFICATION: basiliscus vulgaris
UPDATED: 1745-05-02
COMMON NAME: unicorn
CLASSIFICATION: equus monoceros
UPDATED: 1738-11-24</code></pre>
<div id="shell-loop-indent" class="rmdcaution">
<p><strong><code>for</code> 루프 내부에 코드 들여쓰기</strong></p>
<p><code>for</code> 루프 내부의 코드를 들여쓰는 것이 일반적인 관행이다. 들여쓰는 유일한 목적은 코드를 더 읽기 쉽게 하는 것 밖에 없다 – <code>for</code> 루프를 실행하는데는 꼭 필요하지는 않다.</p>
</div>
<p>쉘이 키워드 <code>for</code>를 보게 되면, 쉘은 리스트에 있는 각각에 대해 명령문 하나(혹은 명령문 집합)을 반복할 것이라는 것을 알게 된다. 루프를 반복할 때마다(iteration 이라고도 한다), 현재 작업하고 있는 파일 이름은 <code>filename</code>으로 불리는 <strong>변수(variable)</strong>에 할당된다. 리스트의 다음 원소로 넘어가기 전에 루프 내부 명령어가 실행된다. 루프 내부에서, 변수 이름 앞에 <code>$</code> 기호를 붙여 변수 값을 얻는다: <code>$</code> 기호는 쉘 해석기가 변수명을 텍스트나 외부 명령어가 아닌 <strong>변수</strong>로 처리해서 값을 해당 위치에 치환하도록 지시한다.</p>
<p>이번 경우에 리스트는 파일이름이 두개다: <code>basilisk.dat</code>, <code>unicorn.dat</code>. 매번 루프가 돌 때마다 파일명을 <code>filename</code> 변수에 할당하고 <code>head</code> 명령어를 실행시킨다. 즉, 루프가 첫번째 돌 때 <code>$filename</code> 은 <code>basilisk.dat</code>이 된다. 쉘 해석기는 <code>basilisk.dat</code> 파일에 <code>head</code> 명령어를 실행시켜서 <code>basilisk.dat</code> 파일의 첫 3줄을 화면에 출력시킨다.</p>
<p>두번째 반복에서, <code>$filename</code>은 <code>unicorn.dat</code>이 된다. 이번에는 쉘이 <code>head</code> 명령어를 <code>unicorn.dat</code> 파일에 적용시켜 <code>unicorn.dat</code> 파일 첫 3줄을 화면에 출력시킨다. 리스트에 원소가 두개라서, 쉘은 <code>for</code> 루프를 빠져나온다.</p>
<p>변수명을 분명히 구분하는데, 중괄호 내부에 변수명을 넣어서 변수로 사용하는 것도 가능하다: <code>$filename</code> 은 <code>${filename}</code>와 동치지만, <code>${file}name</code>와는 다르다. 이 표기법을 다른 사람 프로그램에서 찾아볼 수 있다.</p>
<div id="shell-loop-variable" class="rmdcaution">
<p><strong>루프 내부의 변수</strong></p>
<p>이번 예제는 <code>data-shell/molecules</code> 디렉토리를 가정한다. <code>ls</code> 명령어를 던지면 출력결과는 다음과 같다:</p>
<pre><code>cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb</code></pre>
<p>다음 코드의 출력결과는 어떻게 나오는가?</p>
<pre><code>$ for datafile in *.pdb
&gt; do
&gt;    ls *.pdb
&gt; done</code></pre>
<p>이제 다음 코드의 출력결과는 무엇인가?</p>
<pre><code>$ for datafile in *.pdb
&gt; do
&gt;   ls $datafile
&gt; done</code></pre>
<p>왜 상기 두 루프 실행결과는 다를까?</p>
<blockquote class="blockquote">
<p><strong>해답</strong> 첫번째 코드 블록은 루프를 돌릴 때마다 동일한 출력결과를 출력한다. 배쉬는 루프 몸통 내부 와일드카드 <code>*.pdb</code>을 확장해서 <code>.pdb</code>로 끝나는 모든 파일을 매칭시킨다. 확장된 루프는 다음과 같이 생겼다:</p>
<pre><code>$ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
&gt; do
&gt; ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
&gt; done

cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb
cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb</code></pre>
<p>두번째 코드 블록은 루프를 돌 때마다 다른 파일을 출력한다. <code>datafile</code> 파일 변수값이 <code>$datafile</code>을 통해 평가되고 <code>ls</code> 명령어를 사용해서 파일 목록을 출력하게 된다.</p>
<pre><code>cubane.pdb
ethane.pdb
methane.pdb
octane.pdb
pentane.pdb
propane.pdb</code></pre>
</blockquote>
</div>
<div id="shell-loop-prompt" class="rmdcaution">
<p><strong>프롬프트 따라가기</strong></p>
<p>루프안에서 타이핑을 할 때, 쉘 프롬프트가 <code>$</code>에서 <code>&gt;</code>으로 바뀐다. 두번째 프롬프트는, <code>&gt;</code>, 온전한 명령문 타이핑이 끝마치지 않았음을 상기시키려고 다르게 표기된다. 세미콜론 <code>;</code> 을 사용해서 두 명령어로 구성된 문장을 단일 명령줄로 단순화한다.</p>
</div>
<div id="shell-loop-symbols" class="rmdcaution">
<p><strong>동일한 기호, 하지만 다른 의미</strong></p>
<p>쉘 프롬프트로 <code>&gt;</code> 기호가 사용되는 것을 확인했지만, <code>&gt;</code> 기호는 출력결과를 방향변경(redirect) 하는데도 사용된다. 유사하게 <code>$</code> 기호를 쉘 프롬프트로 사용했지만, 앞에서 살펴봤듯이, 쉘로 하여금 변수값을 추출하는데도 사용된다.</p>
<p><em>쉘</em>이 <code>&gt;</code> 혹은 <code>$</code> 기호를 출력하게 되면, 사용자가 뭔가 타이핑하길 기대하고 있다는 것으로 해당 기호는 프롬프트를 의미한다.</p>
<p><em>사용자 본인</em>이 <code>&gt;</code> 혹은 <code>$</code> 기호를 타이핑하게 되면, 출력결과를 방향변경하거나 변수 값을 끄집어내는 지시를 쉘에 전달하게 된다.</p>
</div>
<p><code>data-shell/creatures</code> 디렉토리의 예제로 돌아가자. 사람 코드를 읽는 독자에게 목적을 좀더 명확히 하기 위해서 루프의 변수명을 <code>filename</code>로 했다. 쉘 자체는 변수명이 어떻게 작명되든지 문제삼지 않는다. 만약 루프를 다음과 같이 작성하거나:</p>
<pre><code>$ for x in basilisk.dat unicorn.dat
&gt; do
&gt;    head -n 3 $x
&gt; done</code></pre>
<p>혹은:</p>
<pre><code>$ for temperature in basilisk.dat unicorn.dat
&gt; do
&gt;    head -n 3 $temperature
&gt; done</code></pre>
<p>둘다 정확하게 동일하게 동작한다. <em>이렇게는 절대 하지 마세요</em>. 사람이 프로그램을 이해할 수 있을 때만 프로그램이 유용하기 때문에, (<code>x</code>같은) 의미없는 이름이나, (<code>temperature</code>같은) 오해를 줄 수 있는 이름은 오해를 불러일으켜서 독자가 생각하기에 당연히 프로그램이 수행해야 할 작업을 프로그램이 수행하지 못하게 할 가능성을 높인다.</p>
<div id="shell-loop-control" class="rmdcaution">
<p><strong>파일 집합 제한걸기</strong></p>
<p><code>data-shell/molecules</code> 디렉토리에서 다음 루프를 실행하게 되면 출력결과는 어떻게 될까?</p>
<pre><code>$ for filename in c*
&gt; do
&gt;    ls $filename 
&gt; done</code></pre>
<ol type="1">
<li>어떤 파일도 출력되지 않는다.</li>
<li>모든 파일이 출력된다.</li>
<li><code>cubane.pdb</code>, <code>octane.pdb</code>, <code>pentane.pdb</code> 파일만 출력된다.</li>
<li><code>cubane.pdb</code> 파일만 출력된다.</li>
</ol>
<blockquote class="blockquote">
<p><strong>해답</strong> 정답은 4. 와일드카드 <code>*</code> 문자는 0 혹은 그 이상 문자를 매칭하게 된다. 따라서, 문자 <code>c</code>로 시작하는 문자 다음에 0 혹은 그 이상 문자를 갖는 모든 파일이 매칭된다.</p>
</blockquote>
<p>대신에 다음 명령어를 사용하면 출력결과는 어떻게 달라지나?</p>
<pre><code>$ for filename in *c*
&gt; do
&gt;    ls $filename 
&gt; done</code></pre>
<ol type="1">
<li>동일한 파일이 출력된다.</li>
<li>이번에는 모든 파일이 출력된다.</li>
<li>이번에는 어떤 파일도 출력되지 않는다.</li>
<li><code>cubane.pdb</code> 와 <code>octane.pdb</code> 파일이 출력된다.</li>
<li><code>octane.pdb</code> 파일만 출력된다.</li>
</ol>
<blockquote class="blockquote">
<p><strong>해답</strong> 정답은 4. 와일드카드 <code>*</code> 문자는 0 혹은 그 이상 문자를 매칭하게 된다. 따라서, <code>c</code> 앞에 0 혹은 그 이상 문자가 올 수 있고, <code>c</code> 문자 다음에 0 혹은 그 이상 문자가 모두 매칭된다.</p>
</blockquote>
</div>
<p><code>data-shell/creatures</code> 디렉토리에서 예제를 계속해서 학습해보자. 다음에 좀더 복잡한 루프가 있다:</p>
<pre><code>$ for filename in *.dat
&gt; do
&gt;     echo $filename
&gt;     head -n 100 $filename | tail -n 20
&gt; done</code></pre>
<p>쉘이 <code>*.dat</code>을 전개해서 쉘이 처리할 파일 리스트를 생성한다. 그리고 나서 <strong>루프 몸통(loop body)</strong> 부분이 파일 각각에 대해 명령어 두개를 실행한다. 첫 명령어 <code>echo</code>는 명령 라인 매개변수를 표준 출력으로 화면에 뿌려준다. 예를 들어:</p>
<pre><code>$ echo hello there</code></pre>
<p>상기 명령은 다음과 같이 출력된다:</p>
<pre><code>hello there</code></pre>
<p>이 사례에서, 쉘이 파일 이름으로 <code>$filename</code>을 전개했기 때문에, <code>echo $filename</code>은 단지 파일 이름만 화면에 출력한다. 다음과 같이 작성할 수 없다는 것에 주의한다:</p>
<pre><code>$ for filename in *.dat
&gt; do
&gt;     $filename
&gt;     head -n 100 $filename | tail -n 20
&gt; done</code></pre>
<p>왜냐하면, <code>$filename</code>이 <code>basilisk.dat</code>으로 전개될 때 루프 처음에 쉘이 프로그램으로 인식한 <code>basilisk.dat</code>를 실행하려고 하기 때문이다. 마지막으로, <code>head</code>와 <code>tail</code> 조합은 어떤 파일이 처리되든 81-100줄만 선택해서 화면에 뿌려준다. (파일이 적어도 100줄로 되었음을 가정)</p>
<p>::: {#shell-loop-space .rmdcaution}</p>
<p><strong>파일, 디렉토리, 변수 등 이름에 공백</strong></p>
<p>공백(whitespace)을 사용해서 루프를 돌릴 때 리스트의 각 원소를 구별했다. 리스트 원소중 일부가 공백을 갖는 경우, 해당 원소를 인용부호로 감싸서 사용해야 된다. 데이터 파일이 다음과 같은 이름으로 되었다고 가정하자:</p>
<pre><code>red dragon.dat
purple unicorn.dat</code></pre>
<p>다음을 사용하여 파일을 처리하려고 한다면:</p>
<pre><code>$ for filename in "red dragon.dat" "purple unicorn.dat"
&gt; do
&gt;     head -n 100 "$filename" | tail -n 3
&gt; done</code></pre>
<p>파일명에 공백(혹은 다른 특수 문자)를 회피하는 것이 더 단순하다. 상기 파일은 존재하지 않는다. 그래서 상기 코드를 실행하게 되면, <code>head</code> 명령어는 파일을 찾을 수가 없어서 예상되는 파일명을 보여주는 오류 메시지가 반환된다:</p>
<pre><code>head: cannot open ‘red dragon.dat’ for reading: No such file or directory
head: cannot open ‘purple unicorn.dat’ for reading: No such file or directory</code></pre>
<p>상기 루프 내부 <code>$filename</code> 파일명 주위 인용부호를 제거하고 공백 효과를 살펴보자. <code>creatures</code> 디렉토리에서 코드를 실행시키게 되면 <code>unicorn.dat</code> 파일에 대한 결과를 루프 명령어 실행 결과를 얻게 됨에 주목한다:</p>
<pre><code>head: cannot open ‘red’ for reading: No such file or directory
head: cannot open ‘dragon.dat’ for reading: No such file or directory
head: cannot open ‘purple’ for reading: No such file or directory
CGGTACCGAA
AAGGGTCGCG
CAAGTGTTCC</code></pre>
<p>원래 파일 복사문제로 되돌아가서, 다음 루프를 사용해서 문제를 해결해 보자:</p>
<pre><code>$ for filename in *.dat
&gt; do
&gt;     cp $filename original-$filename
&gt; done</code></pre>
<p>상기 루프는 <code>cp</code> 명령문을 각 파일이름에 대해 실행한다. 처음에 <code>$filename</code>이 <code>basilisk.dat</code>로 전개될 때, 쉘은 다음을 실행한다:</p>
<pre><code>cp basilisk.dat original-basilisk.dat</code></pre>
<p>두번째에는 명령문은 다음과 같다:</p>
<pre><code>cp unicorn.dat original-unicorn.dat</code></pre>
<p><code>cp</code> 명령어는 아무런 출력결과도 만들어내지 않기 때문에, 루프가 제대로 돌아가는지 확인하기 어렵다. <code>echo</code>로 명령문 앞에 위치시킴으로써, 명령문 각각이 제대로 동작되고 있는 확인하는 것이 가능하다. 다음 도표를 통해서 스크립트가 동작할 때 어떤 작업이 수행하고 있는지 상술하고 있다. 또한 <code>echo</code> 명령어를 사려깊이 사용하는 것이 어떻게 훌륭한 디버깅 기술이 되는지도 보여주고 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/images/shell_script_for_loop_flow_chart.svg" class="img-fluid figure-img" style="width:100.0%"></p>
<p></p><figcaption class="figure-caption">For Loop in Action</figcaption><p></p>
</figure>
</div>
<section id="nelle-shell-loop" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="nelle-shell-loop"><span class="header-section-number">2.1</span> Nelle의 파이프라인: 많은 파일 처리하기</h2>
<p>Nelle은 이제 <code>goostats</code> 프로그램(논문 지도교수가 작성한 쉘 스크립트)을 사용해서 데이터 파일을 처리할 준비가 되었다. <code>goostats</code> 프로그램은 표본추출 단백질 파일에서 통계량을 산출하는데 인자를 두개 받는다:</p>
<ol type="1">
<li>입력파일 (원본 데이터를 포함)</li>
<li>출력파일 (산출된 통계량을 저장)</li>
</ol>
<p>아직 쉘을 어떻게 사용하는지 학습단계에 있기 때문에, 단계별로 요구되는 명령어를 차근히 작성하기로 마음먹었다. 첫번째 단계는 적합한 파일을 선택했는지를 확인하는 것이다 — ‘Z’가 아닌 ’A’ 혹은 ’B’로 파일이름이 끝나는 것이 적합한 파일이라는 것을 명심한다. 홈 디렉토리에서 시작해서, 박사과정 Nelle이 다음과 같이 타이핑한다:</p>
<pre><code>$ cd north-pacific-gyre/2012-07-03
$ for datafile in NENE*[AB].txt
&gt; do
&gt;     echo $datafile
&gt; done

NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...
NENE02043A.txt
NENE02043B.txt</code></pre>
<p>다음 단계는 <code>goostats</code> 분석 프로그램이 생성할 파일이름을 무엇으로 할지 결정하는 것이다. “stats”을 각 입력 파일에 접두어로 붙이는 것이 간단해 보여서, 루프를 변경해서 작업을 수행하도록 한다:</p>
<pre><code>$ for datafile in NENE*[AB].txt
&gt; do
&gt;     echo $datafile stats-$datafile
&gt; done

NENE01729A.txt stats-NENE01729A.txt
NENE01729B.txt stats-NENE01729B.txt
NENE01736A.txt stats-NENE01736A.txt
...
NENE02043A.txt stats-NENE02043A.txt
NENE02043B.txt stats-NENE02043B.txt</code></pre>
<p><code>goostats</code>을 아직 실행하지는 않았지만, 이제 확신할 수 있는 것은 올바른 파일을 선택해서, 올바른 출력 파일이름을 생성할 수 있다는 점이다.</p>
<p>명령어를 반복적으로 타이핑하는 것은 귀찮은 일이지만, 더 걱정이 되는 것은 Nelle이 타이핑 실수를 하는 것이다. 그래서 루프를 다시 입력하는 대신에 위쪽 화살표를 누른다. 위쪽 화살표에 반응해서 컴퓨터 쉘은 한줄에 전체 루프를 다시 보여준다. (스크립트 각 부분이 구분되는데 세미콜론이 사용됨):</p>
<pre><code>$ for datafile in NENE*[AB].txt; do echo $datafile stats-$datafile; done</code></pre>
<p>왼쪽 화살표 키를 사용해서, Nelle은 <code>echo</code>명령어를 <code>bash goostats</code>으로 변경하고 백업한다:</p>
<pre><code>$ for datafile in NENE*[AB].txt; do bash goostats $datafile stats-$datafile; done</code></pre>
<p>엔터키를 누를 때, 쉘은 수정된 명령어를 실행한다. 하지만, 어떤 것도 일어나지 않는 것처럼 보인다 — 출력이 아무것도 없다. 잠시뒤에 Nelle은 작성한 스크립트가 화면에 아무것도 출력하지 않아서, 실행되고 있는지, 얼마나 빨리 실행되는지에 대한 정보가 없다는 것을 깨닫는다. 컨트롤+C(Control-C)를 눌러서 작업을 종료하고, 반복할 명령문을 위쪽 화살표로 선택하고, 편집해서 다음과 같이 작성한다:</p>
<pre><code>$ for datafile in NENE*[AB].txt; do echo $datafile; bash goostats $datafile stats-$datafile; done</code></pre>
<div id="shell-loop-start-end" class="rmdcaution">
<p><strong>시작과 끝</strong></p>
<p>쉘에 ^A, 콘트롤+A(Control-A, <code>Ctrl-a</code>)를 타이핑해서 해당 라인 처음으로 가고, ^E (<code>Ctrl-e</code>, Control-E)를 쳐서 라인의 끝으로 이동한다.</p>
</div>
<p>이번에 프로그램을 실행하면, 매 5초간격으로 한줄을 출력한다:</p>
<pre><code>NENE01729A.txt
NENE01729B.txt
NENE01736A.txt
...
</code></pre>
<p>1518 곱하기 5초를 60으로 나누면, 작성한 스크립트를 실행하는데 약 2시간 정도 소요된다고 볼 수 있다. 마지막 점검으로, 또다른 터미널 윈도우를 열어서, <code>north-pacific-gyre/2012-07-03</code> 디렉토리로 가서, <code>cat stats-NENE01729B.txt</code>을 사용해서 출력파일 중 하나를 면밀히 조사한다. 출력결과가 좋아보인다. 그래서 커피를 마시고 그동안 밀린 논문을 읽기로 한다.</p>
<div id="shell-loop-history" class="rmdcaution">
<p><strong>역사(history)를 아는 사람은 반복할 수 있다.</strong></p>
<p>앞선 작업을 반복하는 또다른 방법은 <code>history</code> 명령어를 사용하는 것이다. 실행된 마지막 수백개 명령어 리스트를 얻고 나서, 이들 명령어 중 하나를 반복실행하기 위해서 <code>!123</code>(“123”은 명령 숫자로 교체된다.)을 사용한다. 예를 들어 Nelle이 다음과 같이 타이핑한다면:</p>
<pre><code>$ history | tail -n 5
  456  ls -l NENE0*.txt
  457  rm stats-NENE01729B.txt.txt
  458  bash goostats NENE01729B.txt stats-NENE01729B.txt
  459  ls -l NENE0*.txt
  460  history</code></pre>
<p>그리고 나서, 단순히 <code>!458</code>을 타이핑함으로써, <code>NENE01729B.txt</code> 파일에 <code>goostats</code>을 다시 실행할 수 있게 된다.</p>
</div>
<div id="shell-loop-history-differ" class="rmdcaution">
<p><strong>다른 이력(history) 명령어</strong></p>
<p>이력(history)에 접근하는 단축 명령어가 다수 존재한다.</p>
<ul>
<li><code>Ctrl-R</code> 탄축키는 “reverse-i-search” 이력 검색모드로 입력한 텍스트와 매칭되는 가장 최슨 명령어를 이력에서 찾아서 제시한다. <code>Ctrl-R</code> 단축키를 한번 혹은 그 이상 누르게 되면 그 이전 매칭을 검색해 준다.</li>
<li><code>!!</code> 명령어는 바로 직전 명령어를 불러온다. (키보드 윗화살표를 사용하는 것보다 더 편리할수도 편리하지 않을 수도 있다.)</li>
<li><code>!$</code> 명령어는 마지막 명령문의 마지막 단어를 불러온다. 기대했던 것보다 훨씬 유용할 수 있다: <code>bash goostats NENE01729B.txt stats-NENE01729B.txt</code> 명령문을 실행한 후에 <code>less !$</code>을 타이핑하게 되면 <code>stats-NENE01729B.txt</code> 파일을 찾아준다. 키보드 위화살표를 눌러 명령라인을 편집하는 것보다 훨씬 빠르다.</li>
</ul>
</div>
<div id="shell-loop-save" class="rmdcaution">
<p><strong>루프 내부에서 파일에 저장하기 - 1부</strong></p>
<p><code>data-shell/molecules</code> 디렉토리에 있다고 가정하자. 다음 루프의 효과는 무엇인가?</p>
<pre><code>$ for alkanes in *.pdb
&gt; do
&gt;     echo $alkanes
&gt;     cat $alkanes &gt; alkanes.pdb
&gt; done</code></pre>
<ol type="1">
<li><code>fructose.dat</code>, <code>glucose.dat</code>, <code>sucrose.dat</code>을 출력하고, <code>sucrose.dat</code>에서 나온 텍스트를 <code>xylose.dat</code>에 저장된다.</li>
<li><code>fructose.dat</code>, <code>glucose.dat</code>, <code>sucrose.dat</code>을 출력하고, 모든 파일 3개에서 나온 텍스트를 합쳐 <code>xylose.dat</code>에 저장된다.</li>
<li><code>fructose.dat</code>, <code>glucose.dat</code>, <code>sucrose.dat</code>, <code>xylose.dat</code>을 출력하고, <code>sucrose.dat</code>에서 나온 텍스트를 <code>xylose.dat</code>에 저장된다.</li>
<li>위 어느 것도 아니다.</li>
</ol>
<blockquote class="blockquote">
<p><strong>해답</strong> 1. 순차적으로 각 파일의 텍스트가 <code>alkanes.pdb</code> 파일에 기록된다. 하지만, 루프가 매번 반복될 때마다 파일에 덮어쓰기가 수행되어서 마지막 <code>alkanes.pdb</code> 파일 텍스트만 <code>alkanes.pdb</code> 파일에 기록된다.</p>
</blockquote>
</div>
<div id="shell-loop-save2" class="rmdcaution">
<p><strong>루프 내부에서 파일에 저장하기 - 2부</strong></p>
<p>이번에도 <code>data-shell/molecules</code> 디렉토리에 있다고 가정하고, 다음 루프 실행 출력결과는 무엇일까?</p>
<pre><code>$ for datafile in *.pdb
&gt; do
&gt;     cat $datafile &gt;&gt; all.pdb
&gt; done</code></pre>
<ol type="1">
<li><code>cubane.pdb</code>, <code>ethane.pdb</code>, <code>methane.pdb</code>, <code>octane.pdb</code>, <code>pentane.pdb</code> 파일에 나온 모든 모든 텍스트가 하나로 붙여져서 <code>all.pdb</code> 파일에 저장된다.</li>
<li><code>ethane.pdb</code> 파일에 나온 텍스트만 <code>all.pdb</code> 파일에 저장된다.</li>
<li><code>cubane.pdb</code>, <code>ethane.pdb</code>, <code>methane.pdb</code>, <code>octane.pdb</code>, <code>pentane.pdb</code>, <code>propane.pdb</code> 파일에서 나온 모든 텍스트가 하나로 풑여져서 <code>all.pdb</code> 파일에 저장된다.</li>
<li><code>cubane.pdb</code>, <code>ethane.pdb</code>, <code>methane.pdb</code>, <code>octane.pdb</code>, <code>pentane.pdb</code>, <code>propane.pdb</code> 파일에서 나온 모든 텍스트가 화면에 출력되고 <code>all.pdb</code> 파일에 저장된다.</li>
</ol>
<blockquote class="blockquote">
<p><strong>해답</strong> 정답은 3. 명령어 실행 출력결과를 방향변경하여 덮었는 것이 아니라 <code>&gt;&gt;</code> 기호는 파일에 덧붙인다. <code>cat</code> 명령어에서 나온 출력결과가 파일로 방향변경되어 어떤 출력결과도 화면에 출력되지는 않는다.</p>
</blockquote>
</div>
<div id="shell-loop-dry-run" class="rmdcaution">
<p><strong>시운전(Dry Run)</strong></p>
<p>루프는 한번에 많은 작업을 수행하는 방식이다 — 만약 잘못된 것이 있다면, 한번에 실수를 대단히 많이 범하게 된다. 루프가 수행하는 작업을 점검하는 한 방법이 실제로 루프를 돌리는 대신에 <code>echo</code> 명령어를 사용하는 것이다. 실제로 명령어를 실행하지 않고, 다음 루프가 실행할 명령어를 머릿속으로 미리보고자 한다고 가정한다:</p>
<pre><code>$ for file in *.pdb
&gt; do
&gt;   analyze $file &gt; analyzed-$file
&gt; done</code></pre>
<p>아래 두 루프 사이에 차이는 무엇이고, 어느 것을 시운전으로 실행하고 싶은가?</p>
<pre><code># Version 1
$ for file in *.pdb
&gt; do
&gt;   echo analyze $file &gt; analyzed-$file
&gt; done</code></pre>
<pre><code># Version 2
$ for file in *.pdb
&gt; do
&gt;   echo "analyze $file &gt; analyzed-$file"
&gt; done</code></pre>
<blockquote class="blockquote">
<p><strong>해답</strong> 두번째 버젼을 실행하면 좋을 것이다. 달러 기호로 접두명을 주었기 때문에 루프 변수를 확장해서 인용부호로 감싼 모든 것을 화면에 출력한다.</p>
<p>첫번째 버전은 <code>echo analyze $file</code> 명령을 수행해서 <code>analyzed-$file</code> 파일로 출력결과를 방향변경하여 저장시킨다. 따라서 파일이 쭉 자동생성된다:<code>analyzed-cubane.pdb</code>, <code>analyzed-ethane.pdb</code> …</p>
<p>두가지 버젼을 직접 실행해보고 출력결과를 살펴보자! <code>analyzed-*.pdb</code> 파일을 열어서 파일에 기록된 내용도 살펴본다.</p>
</blockquote>
</div>
<div id="shell-loop-nested" class="rmdcaution">
<p><strong>중첩루프(Nested Loops)</strong> 다른 화합물과 다른 온도를 갖는 조합을 해서, 각 반응율 상수를 측정하는 실험을 조직하도록 이에 상응하는 디렉토리 구조를 갖추고자 한다. 다음 코드 실행결과는 어떻게 될까?</p>
<pre><code>$ for species in cubane ethane methane
&gt; do
&gt;     for temperature in 25 30 37 40
&gt;     do
&gt;         mkdir $species-$temperature
&gt;     done
&gt; done</code></pre>
<blockquote class="blockquote">
<p><strong>해답</strong> 중첩 루프(루프 내부에 루프가 포함됨)를 생성하게 된다. 외부 루프에 각 화학물이, 내부 루프(중첩된 루프)에 온도 조건을 반복하게 되서, 화학물과 온도를 조합한 새로운 디렉토리가 쭉 생성된다.</p>
<p>직접 코드를 실행해서 어떤 디렉토리가 생성되는지 확인한다!</p>
</blockquote>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./04-shell-pipefilter.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">파이프와 필터</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">참고문헌</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>