<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="kr" xml:lang="kr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>gpt-shell - 4&nbsp; 파일과 폴더 넘나들기</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./shell-intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파일과 폴더 넘나들기</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">gpt-shell</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./00_setup.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">환경설정</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_openAI.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">OpenAI 들어가며</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./shell-intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">쉘(Shell) 소개</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./shell-filedir.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파일과 폴더 넘나들기</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">참고문헌</a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#shell-help" id="toc-shell-help" class="nav-link active" data-scroll-target="#shell-help"><span class="toc-section-number">4.1</span>  도움말 얻기</a>
  <ul class="collapse">
  <li><a href="#shell-help-flag" id="toc-shell-help-flag" class="nav-link" data-scroll-target="#shell-help-flag"><span class="toc-section-number">4.1.1</span>  <code>--help</code> 플래그</a></li>
  <li><a href="#shell-help-man" id="toc-shell-help-man" class="nav-link" data-scroll-target="#shell-help-man"><span class="toc-section-number">4.1.2</span>  <code>man</code> 명령어</a></li>
  </ul></li>
  <li><a href="#shell-cd-change" id="toc-shell-cd-change" class="nav-link" data-scroll-target="#shell-cd-change"><span class="toc-section-number">4.2</span>  <code>cd</code> 디렉토리 변경</a></li>
  <li><a href="#shell-path-absolute" id="toc-shell-path-absolute" class="nav-link" data-scroll-target="#shell-path-absolute"><span class="toc-section-number">4.3</span>  상대/절대 경로</a></li>
  <li><a href="#nelle-filedir" id="toc-nelle-filedir" class="nav-link" data-scroll-target="#nelle-filedir"><span class="toc-section-number">4.4</span>  사례: 파일 구성</a></li>
  <li><a href="#쉘-명령-일반구문" id="toc-쉘-명령-일반구문" class="nav-link" data-scroll-target="#쉘-명령-일반구문"><span class="toc-section-number">4.5</span>  쉘 명령 일반구문</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="shell-filedir" class="quarto-section-identifier d-none d-lg-block"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파일과 폴더 넘나들기</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<pre class="{bash}"><code>knitr::opts_chunk$set(engine.opts = list(bash = "-l"))</code></pre>
<p>파일과 디렉토리 관리를 담당하고 있는 운영체제 부분을 <strong>파일 시스템(file system)</strong>이라고 한다. 파일 시스템은 데이터를 정보를 담고 있는 파일과 파일 혹은 다른 디렉토리를 담고 있는 디렉토리(혹은 “폴더”“)로 조직화한다.</p>
<p>파일과 디렉토리를 생성, 검사, 이름 바꾸기, 삭제하는데 명령어 몇개가 자주 사용된다. 명령어를 살펴보기 위해, 쉘 윈도우를 연다:</p>
<p>먼저, <code>pwd</code> 명령어를 사용해서 위치를 찾아낸다; <code>pwd</code>는 “print working directory”를 의미한다. 디렉토리는 <em>장소(place)</em> 같다 - 쉘을 사용할 때마다 정확하게 한 장소에 위치하게 되는데, 이를 <strong>현재 작업 디렉토리(current working directory)</strong>라고 부른다. 명령어 대부분은 현재 작업 디렉토리에 파일을 읽고 쓰는 작업을 “이곳(here)”에 수행한다. 그래서 명령어를 실행하기 전에 현재 위치가 어디인지 파악하는 것이 중요하다. <code>pwd</code> 명령어를 숳애하게 되면 현재 위치를 다음과 같이 보여주게 된다:</p>
<pre><code>$ pwd
/Users/nelle</code></pre>
<p>다음에서, 컴퓨터의 응답은 <code>/Users/nelle</code>으로 넬(Nelle)의 <strong>홈 디렉토리(home directory)</strong>다:</p>
<div id="shell-home-directory" class="rmdcaution">
<p><strong>홈 디렉토리(Home Directory) 변종</strong></p>
<p>홈 디렉토리 경로는 운영체제마다 다르게 보인다. 리눅스에서 <code>/home/nelle</code> 처럼 보이고, 윈도우에서는 <code>C:\Documents and Settings\nelle</code>, <code>C:\Users\nelle</code>와 유사하게 보인다. (윈도우 버젼마다 다소 차이가 있을 수 있음에 주목한다.) 다음 예제부터, 맥OS 출력결과를 기본설정으로 사용할 것이다; 리눅스와 윈도우 출력결과에 다소 차이가 날 수 있지만, 전반적으로 유사하다.</p>
</div>
<p>“홈 디렉토리(home directory)”를 이해하기 위해서, 파일 시스템이 전체적으로 어떻게 구성되었는지 살펴보자. 최상단에 다른 모든 것을 담고 있는 <strong>루트 디렉토리(root directory)</strong>가 있다. 슬래쉬 <code>/</code> 문자로 나타내고, <code>/users/nelle</code>에서 맨 앞에 슬래쉬이기도 하다.</p>
<p>Nelle 과학자 컴퓨터의 파일시스템을 사례로 살펴보자. 시연을 통해서 유사한 방식으로 (하지만 정확하게 동일하지는 않지만) 본인 컴퓨터 파일시스템을 탐색하는 명령어를 학습하게 된다.</p>
<p>넬 과학자 컴퓨터의 파일 시스템은 다음과 같다:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/filesystem.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">파일 시스템</figcaption><p></p>
</figure>
</div>
<p>최상단에 다른 모든 것을 담고 있는 <strong>루트 디렉토리(root directory)</strong>가 있다. 슬래쉬 <code>/</code> 문자로 나타내고, <code>/users/nelle</code>에서 맨 앞에 슬래쉬이기도 하다.</p>
<p>홈 디렉토리 안쪽에 몇가지 다른 디렉토리가 있다: <code>bin</code> (몇몇 내장 프로그램이 저장된 디렉토리), <code>data</code> (여러가지 데이터 파일이 저장된 디렉토리), <code>Users</code> (사용자의 개인 디렉토리가 저장된 디렉토리), <code>tmp</code> (장기간 저장될 필요가 없는 임시 파일을 위한 디렉토리), 등등:</p>
<p>현재 작업 디렉토리 <code>/Users/nelle</code>는 <code>/Users</code> 내부에 저장되어 있다는 것을 알고 있는데, 이유는 <code>/Users</code>가 이름 처음 부분이기 때문에 알 수 있다. 마찬가지로 <code>/Users</code>는 루트 디렉토리 내부에 저장되어 있다는 것을 알 수 있는데, 이름이 <code>/</code>으로 시작되기 때문이다.</p>
<div id="shell-slash" class="rmdcaution">
<p><strong>슬래쉬(Slashes)</strong></p>
<p>슬래쉬 <code>/</code> 문자는 두가지 의미가 있는 것에 주목한다. 파일 혹은 디렉토리 이름 앞에 나타날 때, 루트 디렉토리를 지칭하게 되고, 이름 <em>가운데</em> 나타날 때, 단순히 구분자 역할을 수행한다.</p>
</div>
<p><code>/Users</code> 하단에서 Nelle 과학자 컴퓨터 계정과, 랩실 동료 미이라(Mummy)와 늑대인간(Wolfman) 디렉토리를 볼 수 있다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/home-directories.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">홈 디렉토리</figcaption><p></p>
</figure>
</div>
<p>미이라(Mummy) 파일은 <code>/Users/imhotep</code> 디렉토리에 저장되어 있고, 늑대인가(Wolfman)의 파일은 <code>/Users/larry</code> 디렉토리에 저장되어 있고 <code>/Users/nelle</code> 디렉토리에 <code>nelle</code>의 정보가 저장되어 있는데, 이것이 왜 <code>nelle</code>이 디렉토리 이름의 마지막 부분인 이유다. 일반적으로 명령 프롬프트를 열게 되면, 처음 시작하는 곳이 본인 계정 홈 디렉토리가 된다.</p>
<p>본인 파일시스템에 담긴 내용물을 파악하는데 사용하는 명령어를 학습해 보자. (Nelle의 홈 디렉토리에 무엇이 있는지 <code>ls</code> 명령어를 실행해서 살펴보자.) <code>ls</code>는 “목록보기(listing)”를 나타낸다:</p>
<pre><code>$ ls
Applications Documents    Library      Music        Public
Desktop      Downloads    Movies       Pictures</code></pre>
<p>(다시 한번, 본인 컴퓨터 운영체제와 파일시스템을 취향에 따라 바꿨는지에 따라 출력결과는 다소 다를 수 있다.)</p>
<p><code>ls</code>는 알파벳 순서로 깔끔하게 열로 정렬하여 현재 디렉토리에 있는 파일과 디렉토리 이름을 출력한다. <strong>플래그(flag)</strong> <code>-F</code>(<strong>스위치(switch)</strong> 혹은 <strong>옵션(option)</strong>으로도 불린다)를 추가하여 출력을 좀더 이해하기 좋게 출력괄를 생성할 수도 있다. <code>ls</code>으로 하여금 디렉토리 이름 뒤에 <code>/</code>을 추가하게 일러준다: 끝에 붙은 <code>/</code>은 디렉토리라는 것을 지칭한다. 설정에 따라 달라지도록 파일이냐 디렉토리냐에 따라 다른 색상을 입힐 수도 있다. 앞선 학습에서 <code>ls -F</code> 명령어를 사용한 것을 상기한다.</p>
<pre><code>$ ls -F
Applications/ Documents/    Library/      Music/        Public/
Desktop/      Downloads/    Movies/       Pictures/</code></pre>
<section id="shell-help" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="shell-help"><span class="header-section-number">4.1</span> 도움말 얻기</h2>
<p><code>ls</code> 명령어에 딸린 <strong>플래그</strong>가 많다. 일반적으로 명령어와 수반되는 플래그 사용법을 파악하는 방식이 두개 있다:</p>
<ol type="1">
<li><code>--help</code> 플래그를 명령어에 다음과 같이 전달하는 방법:</li>
</ol>
<pre><code>$ ls --help</code></pre>
<ol start="2" type="1">
<li><code>man</code> 명령어로 다음과 같이 매뉴얼을 읽는 방법:</li>
</ol>
<pre><code>$ man ls </code></pre>
<p><strong>본인 컴퓨터 환경에 따라 상기 방법 중 하나만 동작(<code>man</code> 혹은 <code>--help</code>)할 수도 있다.</strong> 아래에서 두가지 방법 모두 살펴보자.</p>
<section id="shell-help-flag" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="shell-help-flag"><span class="header-section-number">4.1.1</span> <code>--help</code> 플래그</h3>
<p>배쉬 내부에서 동작하도록 작성된 배쉬 명령어와 프로그램은 <code>--help</code> 플래그를 지원해서 명령어 혹은 프로그램을 사용하는 방식에 대한 더 많은 정보를 볼 수 있게 해 준다.</p>
<pre><code>$ ls --help

Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               '--block-size=M' prints sizes in units of
                               1,048,576 bytes; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first

... 중략

  -X                         sort alphabetically by entry extension
  -Z, --context              print any security context of each file
  -1                         list one file per line.  Avoid '\n' with -q or -b
      --help     display this help and exit
      --version  output version information and exit

The SIZE argument is an integer and optional unit (example: 10K is 10*1024).
Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).

GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;
Full documentation at: &lt;http://www.gnu.org/software/coreutils/ls&gt;
or available locally via: info '(coreutils) ls invocation'</code></pre>
<div id="shell-cmd-flag" class="rmdcaution">
<p><strong>지원되지 않는 명령-라인 선택옵션</strong></p>
<p>지원되지 않는 선택옵션(플래그)를 사용하게 되면, <code>ls</code>를 비롯한 다른 프로그램은 다음과 같은 오류 메시지를 일반적으로 출력하게 된다:</p>
<pre><code>$ ls -j
ls: invalid option -- 'j'
Try 'ls --help' for more information.</code></pre>
</div>
</section>
<section id="shell-help-man" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="shell-help-man"><span class="header-section-number">4.1.2</span> <code>man</code> 명령어</h3>
<p><code>ls</code>에 대해 배울 수 있는 다른 방식은 다음 명령어를 타이핑하는 것이다.</p>
<pre><code>$ man ls</code></pre>
<p>상기 명령어를 실행하게 되면 <code>ls</code> 명령어와 선택 옵션에 대해 기술된 페이지로 탈바꿈하게 된다. 만약 운이 좋은 경우 상용법에 대한 예제도 포함되어 있다.</p>
<p><code>man</code> 페이지를 살펴보는 방법은 행단위로 이동하는데 <kbd>↑</kbd>, <kbd>↓</kbd>을 사용하거나 전체 페이지 단위로 건너뛰거나 아래 페이지로 이동할 경우 <kbd>B</kbd>, <kbd>Spacebar</kbd>을 사용한다. <code>man</code> 페이지에서 단어나 문자를 찾는 경우 <kbd>/</kbd> 다음에 검색할 문자 혹은 단어를 타이핑하면 된다.</p>
<p><code>man</code> 페이지에서 빠져 나오고자 <strong>종료(quit)</strong>하고자 한다면 <kbd>Q</kbd>을 누른다.</p>
<div id="shell-help-webpage" class="rmdcaution">
<p><strong>웹상의 매뉴얼 페이지</strong></p>
<p>물론 명령어에 대한 도움말에 접근하는 세번째 방식이 있다: 웹브라우저를 통해서 인터넷을 검색하는 것이다. 인터넷 검색을 이용할 때, 검색쿼리에 <code>unix man page</code> 문구를 포함할 경우 연관된 정보를 찾는데 도움이 될 수 있다.</p>
<p>GNU도 <a href="http://www.gnu.org/software/coreutils/manual/coreutils.html">GNU 핵심 유틸리티(core GNU utilities)</a>이 포함된 <a href="http://www.gnu.org/manual/manual.html">매뉴얼</a>을 제공하고 있는데 이번 학습에 소개된 많은 명령어를 망라하고 있다.</p>
</div>
<div id="shell-more-flags" class="rmdcaution">
<p><strong>더많은 <code>ls</code> 플래그 탐색</strong></p>
<p><code>-l</code>, <code>-h</code> 플래그를 붙여 <code>ls</code> 명령어를 수행하게 되면 출력결과는 어떻게 나올까?</p>
<p>출력결과의 일부는 이번 학습에서 다루지 않는 속성(property)에 대한 것으로 파일 권한과 파일 소유에 대한 것이다. 그럼에도 불구하고 나머지는 유용할 것이다.</p>
<blockquote class="blockquote">
<p><code>ls</code>와 사용되는 <code>-l</code> 플래그는 <strong>l</strong>ong을 축약한 것으로 파일/디렉토리 명칭 뿐만 아니라 파일 크기, 최종 변경 시간 같은 부가정보가 출력된다. <code>-h</code> 플래그는 “<strong>h</strong>uman readable” 사람이 읽기 편한 형태로 파일크기를 지정한다. 예를 들어, <code>5369</code> 대신에 <code>5.3K</code>이 화면에 출력된다.</p>
</blockquote>
</div>
<div id="shell-time-flag" class="rmdcaution">
<p><strong>재귀적으로 시간순으로 목록 출력</strong></p>
<p><code>ls -R</code> 명령어는 디렉토리에 담긴 내용을 재귀적으로 화면에 출력한다; 즉, 각 단계별로 하위 디렉토리, 하위-하위 디렉토리 내용을 확면에 출력한다. <code>ls -t</code> 명령어는 마지막 변경된 시점순으로 가장 최근에 변경된 파일 혹은 디렉토리를 화면에 정렬해서 출력한다. <code>ls -R -t</code> 명령어는 어떤 순서로 화면엘 출력할까?</p>
<p>힌트: <code>ls -l</code> 명령어를 사용해서 시간도장(timestamp)을 볼 수 있도록 전체 목록을 화면에 출력한다.</p>
<blockquote class="blockquote">
<p>각 디렉토리의 파일/디렉토리가 가장 마지막 시간 변경순으로 정렬되어 출력된다.</p>
</blockquote>
</div>
<p>여기서 홈 디렉토리가 <strong>하위 디렉토리(sub-directories)</strong>가 포함된것을 알 수 있다. 슬래쉬(<code>/</code>)가 붙지 않는 명칭을 갖는 것은 것은 평범한 <strong>파일(file)</strong>이다. <code>ls</code> 와 <code>-F</code> 사이에 공백이 있는 것에 주목한다: 공백이 없다면 쉘은 존재하지 않는 <code>ls-F</code> 명령어를 실행시키려 한다고 간주한다.</p>
<p><code>ls</code> 명령어를 사용해서 다른 디렉토리에 들어 있는 파일과 디렉토리를 살펴볼 수 있다. <code>ls -F Desktop</code> 명령어를 실행해서 바탕화면 <code>Desktop</code> 디렉토리에 담긴 것을 살펴보자. 즉, <code>ls</code> 명령어는 <code>-F</code> <strong>플래그</strong>, 그리고 <strong>인자(argument)</strong> <code>Desktop</code>으로 구성된다. <code>Desktop</code> 인자는 <code>ls</code>로 하여금 현재 작업 디렉토리가 아닌 바탕화면 디렉토리 내용을 출력하도록 지정하는 역할을 수행한다:</p>
<pre><code>$ ls -F Desktop
data-shell/</code></pre>
<p>작업한 출력결과는 웹사이트에서 다운로드 받아 압축을 풀어 작업하여 생성한 <code>data-shell</code> 디렉토리와 본인 바탕화면에 저장된 모든 파일과 하위디렉토리가 출력되어야 한다.</p>
</section>
</section>
<section id="shell-cd-change" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="shell-cd-change"><span class="header-section-number">4.2</span> <code>cd</code> 디렉토리 변경</h2>
<p>지금 확인했듯이, 배쉬 쉘은 파일을 계층적 파일 시스템으로 구성한다는 아이디어에 강력히 의존하고 있다. 이런 방식으로 계층적으로 파일과 디렉토리를 구조화하게 되면 본인 작업을 추적하는데 도움이 된다: 책상위에 출력한 논문 수백개를 쌓아놓은 것는 것이 가능하듯이, 홈 디렉토리에 파일 수백개를 저장하는 것도 가능하다. 하지만, 이런 접근법은 자멸하는 전략이나 마찬가지다.</p>
<p><code>data-shell</code> 디렉토리가 바탕화면(Desktop)에 위치하는 것을 확인했으니, 다음 두가지를 수행할 수 있다.</p>
<p>먼저, <code>data-shell</code> 디렉토리에 담긴 것을 살펴보자; 디렉토리 이름에 <code>ls</code>를 전달해서 앞서 확인된 동일한 전략을 사용하자:</p>
<pre><code>$ ls -F Desktop/data-shell
creatures/          molecules/          notes.txt           solar.pdf
data/               north-pacific-gyre/ pizza.cfg           writing/</code></pre>
<p>둘째로, 다른 디렉토리로 위치를 실제로 바꿀 수 있다. 그렇게 하면 더이상 홈 디렉토리에 있지는 않게 된다.</p>
<p>작업 디렉토리를 변경하기 위해서 <code>cd</code> 다음에 디렉토리 이름을 사용한다. <code>cd</code>는 “change directory”의 두문어다. 하지만 약간 오해의 소지가 있다: 명령어 자체가 디렉토리를 변경하지는 않고, 단지 사용자가 어느 디렉토리에 있는지에 대한 쉘의 생각만 바꾼다.</p>
<p>앞서 확인한 <code>data</code> 디렉토리로 이동해 보자. 다음 명령어를 쭉 이어서 실행하게 되면 목적지에 도달할 수 있다:</p>
<pre><code>$ cd Desktop
$ cd data-shell
$ cd data</code></pre>
<p>상기 명령어는 홈 디렉토리에 바탕화면(<code>Desktop</code>) 디렉토리로 이동하고 나서, <code>data-shell</code> 디렉토리로 이동하고 나서, <code>data</code> 디렉토리에 이동하게 된다. <code>cd</code> 명령어는 아무것도 출력하지는 않지만, <code>pwd</code> 명령어를 실행하게 되면 <code>/Users/nelle/Desktop/data-shell/data</code> 위치한 것을 확인하게 된다. 인자 없이 <code>ls</code> 명령어를 실행하게 되면, <code>/Users/nelle/Desktop/data-shell/data</code> 디렉토리 파일과 디렉토리를 출력하게 되는데 이유는 지금 있는 위치이기 때문이다:</p>
<pre><code>$ pwd
/Users/nelle/Desktop/data-shell/data</code></pre>
<pre><code>$ ls -F
amino-acids.txt   elements/     pdb/            salmon.txt
animals.txt       morse.txt     planets.txt     sunspot.txt</code></pre>
<p>이제 디렉토리 나무를 타서 아래로 내려가는 방법을 익혔다. 하지만 어떻게 하면 위로 올라갈 수 있을까? 다음 명령어를 시도해보자:</p>
<pre><code>$ cd data-shell
-bash: cd: data-shell: No such file or directory</code></pre>
<p>하지만, 오류 발생! 이유가 뭘까?</p>
<p>지금까지 방법으로 <code>cd</code> 명령어는 현재 디렉토리 내부에 하위 디렉토리만 볼 수 있다. 현재 디렉토리에서 상위 디렉토리를 볼 수 있는 다른 방법이 있다; 가장 단순한 것부터 시작해보자.</p>
<p>쉘에서 한단계 위 디렉토리로 이동할 수 있는 단축키가 존재하는데 다음과 같이 생겼다:</p>
<pre><code>$ cd ..</code></pre>
<p><code>..</code>은 특별한 디렉토리명인데 “현재 디렉토리를 포함하는 디렉토리”, 좀더 간결하게 표현하면 현재 디렉토리의 <strong>부모</strong>를 의미한다. 물론, <code>cd ..</code> 명령어를 실행하고 나서 <code>pwd</code>을 실행하게 되면 <code>/Users/nelle/Desktop/data-shell</code>로 되돌아 간다:</p>
<pre><code>$ pwd
/Users/nelle/Desktop/data-shell</code></pre>
<p>단순히 <code>ls</code> 명령어를 실행하게 되면 특수 디렉토리 <code>..</code>이 화면에 출력되지는 않는다. <code>..</code> 디렉토리를 출력하려면 <code>ls</code> 명령어와 <code>-a</code> 플래그를 사용한다:</p>
<pre><code>$ ls -F -a
./   .bash_profile  data/       north-pacific-gyre/  pizza.cfg  thesis/
../  creatures/     molecules/  notes.txt            solar.pdf  writing/</code></pre>
<p><code>-a</code>은 “show all”의 축약으로 모두 보여주기를 의미한다; <code>ls</code>로 하여금 <code>..</code>와 같은 <code>.</code>로 시작하는 파일과 디렉토리명도 화면에 출력하게 강제한다. (<code>/Users/nelle</code> 디렉토리에 위치한다면, <code>/Users</code> 디렉토리를 지칭) <code>.</code>도 또다른 특별한 디렉토리로, “현재 작업 디렉토리(current working directory)”를 의미한다. 중복되어 불필요해 보일 수 있지만, 곧 <code>.</code>에 대한 사용법을 학습할 것이다.</p>
<p>대부분의 명령라인 도구에서 플래그 다수룰 조합해서 플래그 사이 공백없이 단일 <code>-</code>로 사용함에 주목한다: <code>ls -F -a</code>은 <code>ls -Fa</code>와 동일하다.</p>
<div id="shell-hidden-files" class="rmdcaution">
<p><strong>다른 숨은 파일들</strong></p>
<p>숨은 <code>..</code>, <code>.</code> 디렉토리에 더해서, <code>.bash_profile</code> 파일도 봤을 것이다. <code>.bash_profile</code> 파일에는 쉘 환경설정 정보가 담겨져 있다. <code>.</code>으로 시작하는 다른 파일과 디렉토리를 봤을 수도 있다. 이런 파일은 본인 컴퓨터의 다른 프로그램에서 환경설정을 하기 위해서 사용되는 파일과 디렉토리라고 보면 된다. <code>.</code> 접두어를 사용해서 <code>ls</code> 명령어를 사용할 때 이러한 환경설정 파일들이 터미널을 난잡하게 만드는 것을 방지하는 기능을 수행한다.</p>
</div>
<div id="shell-orthogonality" class="rmdcaution">
<p><strong>직교(Orthogonality)</strong></p>
<p>특수 이름 <code>.</code>과 <code>..</code>는 <code>ls</code>에만 속하는 것이 아니고; 모든 프로그램에서 같은 방식으로 해석된다. 예를 들어, <code>/Users/nelle/data</code> 디렉토리에 있을 때, <code>ls ..</code> 명령어는 <code>/Users/nelle</code>의 목록을 보여줄 것이다. 어떻게 조합되든 상관없이 동일한 의미를 가지게 될 때, 프로그래머는 이를 <strong>직교(orthogonal)</strong>한다고 부른다. 직교 시스템은 사람들이 훨씬 배우기 쉬운데, 이유는 기억하고 추적할 특수 사례와 예외가 더 적기 때문이다.</p>
</div>
</section>
<section id="shell-path-absolute" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="shell-path-absolute"><span class="header-section-number">4.3</span> 상대/절대 경로</h2>
<p>컴퓨터에 파일시스템을 돌아다니는데 기본 명령어는 <code>pwd</code>, <code>ls</code>, <code>cd</code>을 들 수 있다. 지금까지 사용했던 했던 방식을 벗어난 사례를 살펴보자. 프롬프트에서 <code>cd</code> 명령어를 디렉토리를 특정하지 않고 실행시키면 어떻게 될까?</p>
<pre><code>$ cd</code></pre>
<p>상기 명령어 실행 결과를 어떻게 확인할 수 있을까? <code>pwd</code> 명령어가 정답을 제시한다!</p>
<pre><code>$ pwd
/Users/nelle</code></pre>
<p>어떤 플래그도 없는 <code>cd</code> 명령어는 홈디렉토리로 이동시킨다. 파일시스템에서 방향을 잃었을 경우 큰 도움이 된다.</p>
<p><code>data</code> 디렉토리로 되돌아가자. 앞서 명령어 세개를 동원했지만 한방에 해당 디렉토리를 명세해서 바로 이동할 수 있다.</p>
<pre><code>$ cd Desktop/data-shell/data</code></pre>
<p><code>pwd</code> 와 <code>ls -F</code> 명령어를 실행해서 올바른 자리로 돌아왔는지 확인하자. <code>data</code> 디렉토리에서 한단계 위로 올라가려고 하면 <code>cd ..</code> 명령어를 사용했다. 현재 디렉토리 위치에 관계없이 특정 디렉토리로 이동할 수 있는 다른 방식도 있다.</p>
<p>지금까지 디렉토리명을 명세할 때 <strong>상대경로(relative paths)</strong>를 사용했다. <code>ls</code> 혹은 <code>cd</code>와 같은 명령어와 상대 경로를 사용할 때는 시스템이 파일시스템의 루트 위치(<code>/</code>)에서 차근차근 찾기보다 해당 위치를 현재 위치를 찾아 명령을 실행시킨다.</p>
<p>하지만, <code>/</code> 슬래쉬로 표현되는 루트 디렉토리에서 전체 경로를 추가한 <strong>절대경로(absolute path)</strong>로 명세하는 것도 가능하다. <code>/</code> 슬래쉬는 컴퓨터가 루트 디렉토리에서 경로를 탐색하도록 지시한다. 따라서, 명령어를 실행할 때 현재 디렉토리 위치에 관계없이 정확한 특정 디렉토리를 항상 명세하게 된다.</p>
<p>절대경로를 사용하면 파일 시스템에 어느 위치에서든 있던 관계없이 <code>data-shell</code> 디렉토리로 이동할 수 있다. 절대경로를 찾기 쉬운 방법은 <code>pwd</code> 명령어를 사용해서 필요한 디렉토리 정보를 추출하고 이를 활용해서 <code>data-shell</code> 디렉토리로 이동한다.</p>
<pre><code>$ pwd
/Users/nelle/Desktop/data-shell/data</code></pre>
<pre><code>$ cd /Users/nelle/Desktop/data-shell</code></pre>
<p><code>pwd</code>와 <code>ls -F</code> 명령어를 실행하게 되면 원하던 디렉토로리 제대로 이동되었는지 확인이 가능하다.</p>
<div id="shell-shortcuts" class="rmdcaution">
<p><strong>단축(Shortcuts) 두개 더</strong></p>
<p>쉘을 <code>~</code> (틸드) 문자를 경로의 시작으로 해석해서 “현재 사용자 홈 디렉토리”를 의미하게 된다. 예를 들어, Nelle의 홈 디렉토리가 <code>/Users/nelle</code>이라면, <code>~/data</code>은 <code>/Users/nelle/data</code>와 동치가 된다. 경로명에 첫 문자로 있을 때만 이것이 동작한다: <code>here/there/~/elsewhere</code>이 <code>here/there/Users/nelle/elsewhere</code>이 되는 것은 <em>아니다</em>. 따라서, <code>cd ~</code>을 홈 디렉토리로 변경하는데 사용한다.</p>
<p>또 다룩 단축은 대쉬(<code>-</code>) 문자다. <code>cd</code>는 <code>-</code> 문자를 <em>지금 있는 이전 디렉토리</em>로 변역한다. 이 방법이 전체 경로를 기억하고 있다가 타이핑하는 것보다 더 빠르다. 이를 통해 디렉토리를 앞뒤로 <em>매우</em> 효율적으로 이동하게 된다. <code>cd ..</code> 와 <code>cd -</code> 명령어 사이 차이점은 전자(<code>cd ..</code>)는 <em>위로</em>, 후자(<code>cd -</code>)는 <em>아래로</em> 이동하게 위치를 바꾸는 역할을 수행한다. TV 리모컨의 <em>이전 채널</em> 기능으로 생각하면 편하다.</p>
</div>
<div id="shell-relative-paths" class="rmdcaution">
<p><strong>동일 작업을 수행하는 수많은 방법 - 절대 경로 vs.&nbsp;상대 경로</strong></p>
<p><code>/home/amanda/data/</code> 디렉토리에서 시작할 때, Amanda가 홈디렉토리인 <code>/home/amanda</code>로 돌아가도록 사용할 수 있는 명령어를 아래에서 선택하시요.</p>
<ol type="1">
<li><code>cd .</code></li>
<li><code>cd /</code></li>
<li><code>cd /home/amanda</code></li>
<li><code>cd ../..</code></li>
<li><code>cd ~</code></li>
<li><code>cd home</code></li>
<li><code>cd ~/data/..</code></li>
<li><code>cd</code></li>
<li><code>cd ..</code></li>
</ol>
<blockquote class="blockquote">
<p><strong>해답 풀이</strong> 1. No: <code>.</code>은 현재 디렉토리를 나타냄. 2. No: <code>/</code>는 루트 디렉토리를 나타냄. 3. No: Amanda 홈 디렉토리른 <code>/Users/amanda</code>임. 4. No: <code>../..</code>은 두 단계 거슬러 올라간다; 즉, <code>/Users</code>에 도달함. 5. Yes: <code>~</code>은 사용자 홈 디렉토리를 나타남; 이 경우 <code>/Users/amanda</code>이 됨. 6. No: 현재 디렉토리 내부에 <code>home</code> 디렉토리가 존재하는 경우 <code>home</code> 디렉토리로 이동하게 됨. 7. Yes: 불필요하게 복잡하지만, 정답이 맞음. 8. Yes: 사용자 홈 디렉토리로 이동할 수 있는 단축키를 사용함. 9. Yes: 한 단계 위로 이동.</p>
</blockquote>
</div>
<div id="shell-relative-paths-sol" class="rmdcaution">
<p><strong>상대경로 해결</strong></p>
<p>만약 <code>pwd</code> 명령어를 쳤을 때, 화면에 <code>/Users/thing</code>이 출력된다면, <code>ls -F ../backup</code>은 무엇을 출력할까요?</p>
<ol type="1">
<li><code>../backup: No such file or directory</code></li>
<li><code>2012-12-01 2013-01-08 2013-01-27</code></li>
<li><code>2012-12-01/ 2013-01-08/ 2013-01-27/</code></li>
<li><code>original/ pnas_final/ pnas_sub/</code></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/filesystem-challenge.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">도전과제 질문 파일 시스템</figcaption><p></p>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>해답 풀이</strong></p>
<ol type="1">
<li>No: <code>backup</code> in <code>/Users</code> 디렉토리 내부에 <code>backup</code> 디렉토리가 <em>있다</em>. <br></li>
<li>No: <code>Users/thing/backup</code> 디렉토리에 담긴 것을 출력한다. 하지만 <code>..</code>으로 한 단계 상위 레벨 위를 찾도록 요청했다.</li>
<li>No: 이전 해답을 참조한다.</li>
<li>Yes: <code>../backup/</code> 은 <code>/Users/backup/</code>을 지칭한다.</li>
</ol>
</blockquote>
</div>
<div id="shell-ls-reading" class="rmdcaution">
<p><strong><code>ls</code> 독해 능력</strong></p>
<p>상기 그림(도전과제 질문에 사용되는 파일 시스템)에 나온 디렉토리 구조를 상정한다. 만약 <code>pwd</code> 명령어를 쳤을 때 화면에 <code>/Users/backup</code>이 출력되고, <code>-r</code> 인자는 <code>ls</code> 명령어가 역순으로 화면에 출력하게 한다면, 어떤 명령어가 다음을 화면에 출력할까요?</p>
<pre><code>pnas_sub/ pnas_final/ original/
1.  `ls pwd`
2.  `ls -r -F`
3.  `ls -r -F /Users/backup`
4.  위 #2 혹은 #3, 하지만, #1은 아님.</code></pre>
<blockquote class="blockquote">
<p><strong>해답풀이</strong> 1. No: <code>pwd</code> 는 디렉토리 명칭이 아님. 2. Yes: 디렉토리 인자가 없는 <code>ls</code> 명령어는 현재 디렉토리의 파일과 디렉토리를 화면에 출력함. 3. Yes: 절대 경로를 명시적으로 사용. 4. Correct: 상기 해설 참조.</p>
</blockquote>
</div>
</section>
<section id="nelle-filedir" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="nelle-filedir"><span class="header-section-number">4.4</span> 사례: 파일 구성</h2>
<p>파일과 디렉토리에 대해서 알았으니, Nelle은 단백질 분석기가 생성하는 파일을 구성할 준비를 마쳤다. 우선 <code>north-pacific-gyre</code> 디렉토리를 생성해서 데이터가 어디에서 왔는지를 상기하도록 한다. <code>2012-07-03</code> 디렉토리를 생성해서 시료 처리를 시작한 날짜를 명기했다. Nelle은 <code>conference-paper</code>와 <code>revised-results</code>같은 이름을 사용하곤 했다. 하지만, 몇년이 지난 후에 이해하기 어렵다는 것을 발견했다. (마지막 지푸라기는 <code>revised-revised-results-3</code> 디렉토리를 본인이 생성했다는 것을 발견했을 때였다.)</p>
<div id="shell-output-sort" class="rmdcaution">
<p><strong>출력결과 정렬</strong></p>
<p>Nelle은 월과 일에 0을 앞에 붙여 디렉토리를 “년-월-일(year-month-day)” 방식으로 이름지었다. 왜냐하면 쉘이 알파벳 순으로 파일과 디렉토리 이름을 화면에 출력하기 때문이다. 만약 월이름을 사용한다면, 12월(December)이 7월(July) 앞에 위치할 것이다: 만약 앞에 0을 붙이지 않으면 11월이 7월 앞에 올 것이다.</p>
</div>
<p>각각의 물리적 시료는 “NENE01729A”처럼 10자리 중복되지 않는 ID로 연구실 관례에 따라 표식을 붙였다. 시료의 장소, 시간, 깊이, 그리고 다른 특징을 기록하기 위해서 수집 기록에 사용된 것과 동일하다. 그래서 이를 각 파일 이름으로 사용하기로 결정했다. 분석기 출력값이 텍스트 형식이기 때문에 <code>NENE01729A.txt</code>, <code>NENE01812A.txt</code>, … 같이 확장자를 붙였다. 총 1,520개 파일 모두 동일한 디렉토리에 저장되었다.</p>
<p>이제 <code>data-shell</code> 현재 작업 디렉토리에서 Nelle은 다음 명령어를 사용해서, 무슨 파일이 있는지 확인할 수 있다:</p>
<pre><code>$ ls north-pacific-gyre/2012-07-03/</code></pre>
<p>엄청나게 많은 타이핑이지만 <strong>탭 자동완성(tab completion)</strong>을 통해 쉘에게 많은 일을 시킬 수도 있다. 만약 다음과 같이 타이핑하고:</p>
<pre><code>$ ls nor</code></pre>
<p>그리고 나서 탭(키보드에 탭 키)을 누르면, 자동으로 쉘이 디렉토리 이름을 자동완성 시켜준다:</p>
<pre><code>$ ls north-pacific-gyre/</code></pre>
<p>탭을 다시 누르면, Bash가 명령문에 <code>2012-07-03/</code>을 추가하는데, 왜냐하면 유일하게 가능한 자동완성조건이기 때문이다. 한번더 탭을 누려면 아무것도 수행하지 않는다. 왜냐하면 1520가지 경우의 수가 있기 때문이다; 탭을 두번 누르면 모든 파일 목록을 가져온다. 이것을 <strong>탭 자동완성(tab completion)</strong>이라고 부르고, 앞으로도 다른 많은 툴에서도 많이 볼 것이다.</p>
</section>
<section id="쉘-명령-일반구문" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="쉘-명령-일반구문"><span class="header-section-number">4.5</span> 쉘 명령 일반구문</h2>
<p>지금까지 명령어, 선택옵션 및 명령인자를 살펴보았지만 몇 가지 용어를 공식화하는 것이 필요하다. 아래 쉘 명령어를 쉘 명령어 사용의 일반적인 사례로 간주하고 구성요소로 분해하자:</p>
<pre class="{bash}"><code>ls -F /</code></pre>
<p><img src="images/prompt-grammar.jpg" class="img-fluid"></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./shell-intro.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">쉘(Shell) 소개</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link">
        <span class="nav-page-text">참고문헌</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>