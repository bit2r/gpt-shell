<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR" xml:lang="ko-KR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.299">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>챗GPT 유닉스 쉘 - 6&nbsp; 쉘 스크립트</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./07-shell-find.html" rel="next">
<link href="./05-shell-loop.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-shell-intro.html">쉘 프로그래밍</a></li><li class="breadcrumb-item"><a href="./06-shell-script.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">쉘 스크립트</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="검색" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">챗GPT 유닉스 쉘</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">쉘 프로그래밍</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-shell-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">쉘(Shell) 소개</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-shell-filedir.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">파일과 폴더 넘나들기</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-shell-create.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">파일과 디렉토리 작업</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-shell-pipefilter.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파이프와 필터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-shell-loop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">루프(Loops)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-shell-script.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">쉘 스크립트</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-shell-find.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">파일, 텍스트, 폴더 찾기</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">참고문헌</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#nelle-script" id="toc-nelle-script" class="nav-link active" data-scroll-target="#nelle-script"><span class="header-section-number">6.1</span> Nelle 파이프라인: 스크립트 생성하기</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="shell-script" class="quarto-section-identifier"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">쉘 스크립트</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>마침내 쉘을 그토록 강력한 프로그래밍 환경으로 탈바꾼할 준비가 되었다. 자주 반복적으로 사용되는 명령어들을 파일에 저장시키고 나서, 단 하나의 명령어를 타이핑함으써 나중에 이 모든 연산 작업작업을 다시 재실행할 수 있다. 역사적 이유로 파일에 저장된 명령어 꾸러미를 통상 <strong>쉘 스크립트(shell script)</strong>라고 부르지만, 실수로 그렇게 부르는 것은 아니다: 실제로 작은 프로그램이다.</p>
<p><code>molecules/</code> 디렉토리로 돌아가서 <code>middle.sh</code> 파일에 다음 행을 추가하게 되면 쉘스크립트가 된다:</p>
<pre><code>$ cd molecules
$ nano middle.sh</code></pre>
<p><code>nano middle.sh</code> 명령어는 <code>middle.sh</code> 파일을 텍스트 편집기 “nano”로 열게 한다. (편집기 프로그램은 쉘 내부에서 실행된다.) <code>middle.sh</code> 파일이 존재하지 않는 경우, <code>middle.sh</code> 파일을 생성시킨다. 텍스트 편집기를 사용해서 직접 파일을 편집한다 – 단순히 다음 행을 삽입시킨다:</p>
<pre><code>head -n 15 octane.pdb | tail -n 5</code></pre>
<p>앞서 작성한 파이프에 변형이다: <code>octane.pdb</code> 파일에서 11-15 행을 선택한다. 기억할 것은 명령어로서 실행하지 <em>않고</em>: 명령어를 파일에 적어 넣는다는 것이다.</p>
<p>그리고 나서 나노 편집기에서 <code>Ctrl-O</code>를 눌러 파일을 저장하고, 나노 편집기에서 <code>Ctrl-X</code>를 눌러 텍스트 편집기를 빠져나온다. <code>molecules</code> 디렉토리에 <code>middle.sh</code> 파일이 포함되어 있는지 확인한다.</p>
<p>Once we have saved the file, we can ask the shell to execute the commands it contains. Our shell is called <code>bash</code>, so we run the following command:</p>
<p>파일을 저장하면, 쉘로 하여금 파일에 담긴 명령어를 실행하도록 한다. 지금 쉘은 <code>bash</code>라서, 다음과 같이 다음 명령어를 실행시킨다:</p>
<pre><code>$ bash middle.sh

ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00</code></pre>
<p>아니나 다를까, 스크립트의 출력은 정확하게 파이프라인을 직접적으로 실행한 것과 동일하다.</p>
<div id="shell-script-text" class="rmdcaution">
<p><strong>텍스트 vs.&nbsp;텍스트가 아닌 것 아무거나</strong></p>
<p>종종 마이크로소프트 워드 혹은 리브르오피스 Writer 프로그램을 “텍스트 편집기”라고 부른다. 하지만, 프로그래밍을 할때 조금더 주의를 기울일 필요가 있다. 기본 디폴트로, 마이크로소프트 워드는 <code>.docx</code> 파일을 사용해서 텍스트를 저장할 뿐만 아니라, 글꼴, 제목, 등등의 서식 정보도 함께 저장한다. 이런 추가 정보는 문자로 저장되지 않아서, <code>head</code> 같은 도구에게는 무의미하다: <code>head</code> 같은 도구는 입력 파일에 문자, 숫자, 표준 컴퓨터 키보드 특수문자만이 포함되어 있는 것을 예상한다. 따라서, 프로그램을 편집할 때, 일반 텍스트 편집기를 사용하거나, 혹은 일반 텍스트로 파일을 저장하도록 주의한다.</p>
</div>
<p>만약 임의 파일의 행을 선택하고자 한다면 어떨까요? 파일명을 바꾸기 위해서 매번 <code>middle.sh</code>을 편집할 수 있지만, 단순히 명령어를 다시 타이핑하는 것보다 아마 시간이 더 걸릴 것이다. 대신에 <code>middle.sh</code>을 편집해서 좀더 다양한 기능을 제공하도록 만들어보자:</p>
<pre><code>$ nano middle.sh</code></pre>
<p>나노 편집기로 <code>octane.pdb</code>을 <code>$1</code>으로 불리는 특수 변수로 변경하자:</p>
<pre><code>head -n 15 "$1" | tail -n 5</code></pre>
<p>쉘 스크립트 내부에서, <code>$1</code>은 “명령라인의 첫 파일 이름(혹은 다른 인자)”을 의미한다. 이제 스크립트를 다음과 같이 바꿔 실행해 보자:</p>
<pre><code>$ bash middle.sh octane.pdb

ATOM      9  H           1      -4.502   0.681   0.785  1.00  0.00
ATOM     10  H           1      -5.254  -0.243  -0.537  1.00  0.00
ATOM     11  H           1      -4.357   1.252  -0.895  1.00  0.00
ATOM     12  H           1      -3.009  -0.741  -1.467  1.00  0.00
ATOM     13  H           1      -3.172  -1.337   0.206  1.00  0.00</code></pre>
<p>혹은 다음과 같이 다른 파일에 대해 스크립트 프로그램을 실행해 보자:</p>
<pre><code>$ bash middle.sh pentane.pdb

ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00
ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00
ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00
ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00
ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00</code></pre>
<div id="shell-script-argument" class="rmdcaution">
<p><strong>인자 주위를 이중 인용부호로 감싸기</strong></p>
<p>파일명에 공백이 포함된 경우 루프 변수 내부에 이중 인용부호로 감싼 것과 동일한 사유로, 파일명에 공백이 포함된 경우 이중 인용부호로 <code>$1</code>을 감싼다.</p>
</div>
<p>하지만, 매번 줄 범위를 조정할 때마다 여전히 <code>middle.sh</code> 파일을 편집할 필요가 있다. 이 문제를 특수 변수 <code>$2</code> 와 <code>$3</code> 을 사용해서 고쳐보자: <code>head</code>, <code>tail</code> 명령어에 해당 줄수를 출력하도록 인자로 넘긴다.</p>
<pre><code>$ nano middle.sh</code></pre>
<pre><code>head -n "$2" "$1" | tail -n "$3"</code></pre>
<p>이제 다음을 실행시킨다:</p>
<pre><code>$ bash middle.sh pentane.pdb 15 5

ATOM      9  H           1       1.324   0.350  -1.332  1.00  0.00
ATOM     10  H           1       1.271   1.378   0.122  1.00  0.00
ATOM     11  H           1      -0.074  -0.384   1.288  1.00  0.00
ATOM     12  H           1      -0.048  -1.362  -0.205  1.00  0.00
ATOM     13  H           1      -1.183   0.500  -1.412  1.00  0.00</code></pre>
<p>명령문의 인자를 변경함으로써 스크립트 동작을 바꿀 수 있게 된다:</p>
<pre><code>$ bash middle.sh pentane.pdb 20 5

ATOM     14  H           1      -1.259   1.420   0.112  1.00  0.00
ATOM     15  H           1      -2.608  -0.407   1.130  1.00  0.00
ATOM     16  H           1      -2.540  -1.303  -0.404  1.00  0.00
ATOM     17  H           1      -3.393   0.254  -0.321  1.00  0.00
TER      18              1</code></pre>
<p>제대로 동작하지만, <code>middle.sh</code> 쉘스크립트를 읽는 다른 사람은 잠시 시간을 들여, 스크립트가 무엇을 수행하는지 알아내야 할지 모른다. 스크립트를 상단에 <strong>주석(comments)</strong>을 추가해서 좀더 낫게 만들 수 있다:</p>
<pre><code>$ nano middle.sh</code></pre>
<pre><code># Select lines from the middle of a file.
# Usage: bash middle.sh filename end_line num_lines
head -n "$2" "$1" | tail -n "$3"</code></pre>
<p>주석은 <code>#</code>문자로 시작하고 해당 행 끝까지 주석으로 처리된다. 컴퓨터는 주석을 무시하지만, 사람들이(미래의 본인 자신도 포함) 스크립트를 이해하고 사용하는데 정말 귀중한 존재다. 유일한 단점은 스크립트를 변경할 때마다, 주석이 여전히 유효한지 확인해야 된다는 점이다: 잘못된 방향으로 독자를 오도하게 만드는 설명은 아무것도 없는 것보다 더 나쁘다.</p>
<p>만약 많은 파일을 단 하나 파이프라인으로 처리하고자 한다면 어떨까? 예를 들어, <code>.pdb</code> 파일을 길이 순으로 정렬하려면, 다음과 같이 타이핑한다:</p>
<pre><code>$ wc -l *.pdb | sort -n</code></pre>
<p><code>wc -l</code>은 파일에 행갯수를 출력하고(wc는 ’word count’로 -l 플래그를 추가하면 ’count lines’의미가 됨을 상기한다), <code>sort -n</code>은 숫자순으로 파일의 행갯수를 정렬한다. 파일에 담을 수 있지만, 현재 디렉토리에 <code>.pdb</code> 파일만을 정렬한다. 다른 유형의 파일에 대한 정렬된 목록을 얻으려고 한다면, 스크립트에 이 모든 파일명을 얻는 방법이 필요하다. <code>$1</code>, <code>$2</code> 등등은 사용할 수 없는데, 이유는 얼마나 많은 파일이 있는지를 예단할 수 없기 때문이다. 대신에, 특수 변수 <code>$@</code>을 사용한다. <code>$@</code>은 “쉘 스크립트 모든 명령-라인 인자”를 의미한다. 공백을 포함한 매개변수를 처리하려면 이중 인용부호로 <code>$@</code>을 감싸두어야 된다. (<code>"$@"</code>은 <code>"$1"</code> <code>"$2"</code> … 와 동치다). 예제가 다음에 있다:</p>
<pre><code>$ nano sorted.sh</code></pre>
<pre><code># Sort filenames by their length.
# Usage: bash sorted.sh one_or_more_filenames
wc -l "$@" | sort -n</code></pre>
<p>실행방법과 실행결과는 다음과 같다.</p>
<pre><code>$ bash sorted.sh *.pdb ../creatures/*.dat

9 methane.pdb
12 ethane.pdb
15 propane.pdb
20 cubane.pdb
21 pentane.pdb
30 octane.pdb
163 ../creatures/basilisk.dat
163 ../creatures/unicorn.dat</code></pre>
<div id="shell-script-unique" class="rmdcaution">
<p>유일무이한 개체 목록으로 나열 정훈이는 데이터 파일 수백개를 갖고 있는데, 각각은 다음과 같은 형식을 가지고 있다:</p>
<pre><code>2013-11-05,deer,5
2013-11-05,rabbit,22
2013-11-05,raccoon,7
2013-11-06,rabbit,19
2013-11-06,deer,2
2013-11-06,fox,1
2013-11-07,rabbit,18
2013-11-07,bear,1</code></pre>
<p><code>data-shell/data/animal-counts/animals.txt</code> 파일을 대상으로 예제를 작성한다. 임의 파일이름을 명령-라인 인자로 갖는 <code>species.sh</code> 이름의 쉘 스크립트를 작성하라. <code>cut</code>, <code>sort</code>, <code>uniq</code>를 사용해서 각각의 파일별로 나오는 유일무이한 개체에 대한 목록을 화면에 출력하세요.</p>
<blockquote class="blockquote">
<p><strong>해답</strong></p>
<pre><code># csv 파일에 유일무이한 개체를 찾는 스크립트로 개체는 두번째 데이터 필드가 된다.
# 스크립트는 명령라인 인자로 모든 파일명을 인자로 받는다.

# 모든 파일에 대해 루프를 돌려 반복한다.</code></pre>
<p>for file in $@ do echo “Unique species in $file:” # 개체명을 추출한다. cut -d , -f 2 $file | sort | uniq done ```</p>
</blockquote>
</div>
<div id="shell-script-nothing" class="rmdcaution">
<p><strong>왜 쉘 스크립트가 어떤 작업도 수행하지 않을까?</strong></p>
<p>스크립트가 아주 많은 파일을 처리하고 했지만, 어떠한 파일 이름도 부여하지 않는다면 무슨 일이 발생할까? 예를 들어, 만약 다음과 같이 타이핑한다면 어떻게 될까요?:</p>
<pre><code>$ bash sorted.sh</code></pre>
<p>하지만 <code>*.dat</code> (혹은 다른 어떤 것)를 타이핑하지 않는다면 어떨까요? 이 경우 <code>$@</code>은 아무 것도 전개하지 않아서, 스크립트 내부의 파이프라인은 사실상 다음과 같다:</p>
<pre><code>$ wc -l | sort -n</code></pre>
<p>어떠한 파일이름도 주지 않아서, <code>wc</code>은 표준 입력을 처리하려 한다고 가정한다. 그래서, 단지 앉아서 사용자가 인터랙티브하게 어떤 데이터를 전달해주길 대기하고만 있게 된다. 하지만, 밖에서 보면 사용자에게 보이는 것은 스크립트가 거기 앉아서 정지한 것처럼 보인다: 스크립트가 아무 일도 수행하지 않는 것처럼 보인다.</p>
</div>
<p>유용한 무언가를 수행하는 일련의 명령어를 방금 실행했다고 가정하자 — 예를 들어, 논문에 사용될 그래프를 스크립트가 생성. 필요하면 나중에 그래프를 다시 생성할 필요가 있어서, 파일에 명령어를 저장하고자 한다. 명령문을 다시 타이핑(그리고 잠재적으로 잘못 타이핑할 수도 있다)하는 대신에, 다음과 같이 할 수도 있다:</p>
<pre><code>$ history | tail -n 5 &gt; redo-figure-3.sh</code></pre>
<p><code>redo-figure-3.sh</code> 파일은 이제 다음을 담고 있다:</p>
<pre><code>297 bash goostats NENE01729B.txt stats-NENE01729B.txt
298 bash goodiff stats-NENE01729B.txt /data/validated/01729.txt &gt; 01729-differences.txt
299 cut -d ',' -f 2-3 01729-differences.txt &gt; 01729-time-series.txt
300 ygraph --format scatter --color bw --borders none 01729-time-series.txt figure-3.png
301 history | tail -n 5 &gt; redo-figure-3.sh</code></pre>
<p>명령어의 일련 번호를 제거하고, <code>history</code> 명령어를 포함한 마지막 행을 지우는 작업을 편집기에서 한동안 작업한 후에, 그림을 어떻게 생성시켰는지에 관한 정말 정확한 기록을 갖게 되었다.</p>
<div id="shell-script-record" class="rmdcaution">
<p><strong>왜 명령어를 실행하기 전에 <code>history</code>에 명령어를 기록할까?</strong></p>
<p>다음 명령어를 실행시키게 되면:</p>
<pre><code>$ history | tail -n 5 &gt; recent.sh</code></pre>
<p>파일에 마지막 명령어는 <code>history</code> 명령 그자체다; 즉 쉘이 실제로 명령어를 실행하기 전에 명령 로그에 먼저 <code>history</code>를 추가했다. 실제로 <em>항상</em> 쉘은 명령어를 실행시키기 전에 로그에 명령어를 기록한다. 왜 이런 동작을 쉘이 한다고 생각하는가?</p>
<blockquote class="blockquote">
<p><strong>해답</strong> 만약 명령어가 죽던가 멈추게 되면, 어떤 명령어에서 문제가 발생했는지 파악하는 것이 유용할 수 있다. 명령어가 실행된 후에 기록하게 되면, 크래쉬(crash)가 발생된 마지막 명령어에 대한 기록이 없게 된다.</p>
</blockquote>
</div>
<p>실무에서, 대부분의 사람들은 쉘 프롬프트에서 몇번 명령어를 실행해서 올바르게 수행되는지를 확인한 다음, 재사용을 위해 파일에 저장한다. 이런 유형의 작업은 데이터와 작업흐름(workflow)에서 발견한 것을 <code>history</code>를 호출해서 재사용할 수 있게 하고, 출력을 깔끔하게 하기 위해 약간의 편집을 하고 나서, 쉘 스크립트로 저장하는 흐름을 탄다.</p>
<section id="nelle-script" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="nelle-script"><span class="header-section-number">6.1</span> Nelle 파이프라인: 스크립트 생성하기</h2>
<p>Nelle의 지도교수는 모든 분석결과가 재현가능해야 된다는 고집을 갖고 있다. 모든 분석 단계를 담아내는 가장 쉬운 방법은 스크립트에 있다. 편집기를 열어서 다음과 같이 작성한다:</p>
<pre><code># 데이터 파일별로 통계량 계산.
for datafile in "$@"
do
    echo $datafile
    bash goostats $datafile stats-$datafile
done</code></pre>
<p><code>do-stats.sh</code> 이름으로된 파일에 저장해서, 다음과 같이 타이핑해서 첫번째 단계 분석을 다시 실행할 수 있게 되었다:</p>
<pre><code>$ bash do-stats.sh NENE*[AB].txt</code></pre>
<p>또한 다음과 같이도 할 수 있다:</p>
<pre><code>$ bash do-stats.sh NENE*[AB].txt | wc -l</code></pre>
<p>그렇게 해서 출력은 처리된 파일 이름이 아니라 처리된 파일의 숫자만 출력된다.</p>
<p>Nelle의 스크립트에서 주목할 한가지는 스크립트를 실행하는 사람이 무슨 파일을 처리할지를 결정하게 하는 것이다. 스크립트를 다음과 같이 작성할 수 있다:</p>
<pre><code># Site A, Site B 데이터 파일에 대한 통계량 계산
for datafile in NENE*[AB].txt
do
    echo $datafile
    bash goostats $datafile stats-$datafile
done</code></pre>
<p>장점은 이 스크립트는 항상 올바른 파일만을 선택한다: ‘Z’파일을 제거했는지 기억할 필요가 없다. 단점은 <em>항상</em> 이 파일만을 선택한다는 것이다 — 모든 파일(’Z’를 포함하는 파일), 혹은 남극 동료가 생성한 ’G’, ‘H’ 파일에 대해서 스크립트를 편집하지 않고는 실행할 수 없다. 좀더 모험적이라면, 스크립트를 변경해서 명령-라인 매개변수를 검증해서 만약 어떠한 매개변수도 제공되지 않았다면 <code>NENE*[AB].txt</code>을 사용하도록 바꿀수도 있다. 물론, 이런 접근법은 유연성과 복잡성 사이에 서로 대립되는 요소 사이의 균형, 즉 트레이드오프(trade-off)를 야기한다.</p>
<div id="shell-script-variable" class="rmdcaution">
<p><strong>쉘 스크립트의 변수</strong></p>
<p><code>molecules</code> 디렉토리에서, 다음 명령어를 포함하는 <code>script.sh</code>라는 쉘스크립트가 있다고 가정한다:</p>
<pre><code>head -n $2 $1
tail -n $3 $1</code></pre>
<p><code>molecules</code> 디렉토리에서 다음 명령어를 타이핑한다:</p>
<pre><code>bash script.sh '*.pdb' 1 1</code></pre>
<p>다음 출력물 결과 중 어떤 결과가 나올 것으로 예상하나요? 1. <code>molecules</code> 디렉토리에 있는 <code>*.pdb</code> 확장자를 갖는 각 파일의 첫번줄과 마지막줄 사이 모든 줄을 출력. 2. <code>molecules</code> 디렉토리에 있는 <code>*.pdb</code> 확장자를 갖는 각 파일의 첫번줄과 마지막 줄을 출력. 3. <code>molecules</code> 디렉토리에 있는 각 파일의 첫번째와 마지막 줄을 출력. 4. <code>*.pdb</code> 를 감싸는 인용부호로 오류가 발생.</p>
<blockquote class="blockquote">
<p><strong>해답</strong> 정답은 2.</p>
<p>특수 변수 $1, $2, $3은 스크립트에 명령라인 인수를 나타낸다. 따라서 실행되는 명령어는 다음과 같다:</p>
<pre><code>$ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb
$ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb</code></pre>
<p>인용부호로 감싸져서 쉘이 <code>'*.pdb'</code>을 명령라인에서 확장하지 않는다. 이를 테면, 스크립트의 첫번째 인자는 <code>'*.pdb'</code>으로 전달되어 스크립트 내부에서 확장되어 <code>head</code>와 <code>tail</code> 명령어를 실행시키게 된다.</p>
</blockquote>
</div>
<div id="shell-script-long-file" class="rmdcaution">
<p>주어진 확장자 내에서 가장 긴 파일을 찾아낸다 인자로 디렉토리 이름과 파일이름 확장자를 갖는 <code>longest.sh</code>이름의 쉘 스크립트를 작성해서, 그 디렉토리에서 해당 확장자를 가지는 파일 중에 가장 긴 줄을 가진 파일이름을 화면에 출력하세요. 예를 들어, 다음은</p>
<pre><code>$ bash longest.sh /tmp/data pdb</code></pre>
<p><code>/tmp/data</code> 디렉토리에 <code>.pdb</code> 확장자를 가진 파일 중에 가장 긴 줄을 가진 파일이름을 화면에 출력한다.</p>
<blockquote class="blockquote">
<p><strong>해답</strong></p>
<pre><code># 쉘 스크립트는 다음 두 인자를 갖는다: 
#    1. 디렉토리명
#    2. 파일 확장자
# 해당 디렉토리에서 파일 확장자와 매칭되는 가장 길이가 긴 파일명을 출력한다.

wc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1</code></pre>
</blockquote>
</div>
<div id="shell-script-reading" class="rmdcaution">
<p><strong>스크립트 독해 능력</strong></p>
<p>이번 문제에 대해, 다시 한번 <code>data-shell/molecules</code> 디렉토리에 있다고 가정한다. 지금까지 생성한 파일에 추가해서 디렉토리에는 <code>.pdb</code> 파일이 많다. 만약 다음 행을 담고 있는 스크립트로 <code>bash example.sh *.dat</code>을 실행할 때, <code>example.sh</code> 이름의 스크립트가 무엇을 수행하는지 설명하세요:</p>
<pre><code># 스크립트 1
echo *.*</code></pre>
<pre><code># 스크립트 2
for filename in $1 $2 $3
do
    cat $filename
done</code></pre>
<pre><code># 스크립트 3
echo $@.pdb</code></pre>
<blockquote class="blockquote">
<p><strong>해답</strong> 스크립트 1은 파일명에 구두점(<code>.</code>)이 포함된 모든 파일을 출력한다.</p>
<p>스크립트 2는 파일 확장자가 매칭되는 첫 3 파일의 내용을 화면에 출력시킨다. 쉘이 인자를 <code>example.sh</code> 스크립트에 전달하기 전에 와일드카드를 확장시킨다.</p>
<p>스크립트 3은 <code>.pdb</code>로 끝나는 스크립트의 모든 인자(즉, 모든 <code>.pdb</code> 파일)를 화면에 출력시킨다.</p>
<pre><code>cubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb</code></pre>
</blockquote>
</div>
<div id="shell-script-debugging" class="rmdcaution">
<p><strong>스크립트 디버깅</strong></p>
<p>Nelle 컴퓨터 <code>north-pacific-gyre/2012-07-03</code> 디렉토리의 <code>do-errors.sh</code> 파일에 다음과 같은 스크립트가 저장되었다고 가정하자.</p>
<pre><code># Calculate stats for data files.
for datafile in "$@"
do
    echo $datfile
    bash goostats $datafile stats-$datafile
done</code></pre>
<p>다음을 실행하게 되면:</p>
<pre><code>$ bash do-errors.sh NENE*[AB].txt</code></pre>
<p>출력결과는 아무 것도 없다. 원인을 파악하고자 <code>-x</code> 선택옵션을 사용해서 스크립트를 재실행시킨다:</p>
<pre><code>bash -x do-errors.sh NENE*[AB].txt</code></pre>
<p>보여지는 출력결과는 무엇인가? 몇번째 행에서 오류가 발생했는가? &gt; <strong>해답</strong> &gt; <code>-x</code> 플래그를 사용하면 디버그 모드에서 <code>bash</code>를 실행시키게 된다. &gt; 각 명령어를 행단위로 실행시키고 출력결과를 보여주는데, 오류를 특정하는데 도움이 된다. &gt; 이번 예제에서 <code>echo</code> 명령어는 아무 것도 출력하지 않는 것을 볼 수 있다. &gt; 루프 변수명의 철자가 잘못 타이핑 되어 있다. &gt; <code>datfile</code> 변수가 존재하지 않아서 빈 문자열이 반환되었다.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./05-shell-loop.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">루프(Loops)</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./07-shell-find.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">파일, 텍스트, 폴더 찾기</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>