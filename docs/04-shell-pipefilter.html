<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR" xml:lang="ko-KR"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>챗GPT 유닉스 쉘 – 4&nbsp; 파이프와 필터</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./05-shell-loop.html" rel="next">
<link href="./03-shell-create.html" rel="prev">
<link href="./images/logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-229551680-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-shell-intro.html">쉘 프로그래밍</a></li><li class="breadcrumb-item"><a href="./04-shell-pipefilter.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파이프와 필터</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">챗GPT 유닉스 쉘</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/bit2r/gpt-shell/" title="소스 코드" class="quarto-navigation-tool px-1" aria-label="소스 코드"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">감사의 글</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">쉘 프로그래밍</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-shell-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">유닉스 쉘</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-shell-filedir.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">파일과 폴더 넘나들기</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-shell-create.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">파일과 디렉토리 작업</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-shell-pipefilter.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파이프와 필터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-shell-loop.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">루프(Loops)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-shell-script.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">쉘 스크립트</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-shell-find.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">파일, 텍스트, 폴더 찾기</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">GPT 데이터 과학</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_cli_ds.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">CLI 데이터 과학</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_cli_ds_gpt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">챗GPT 데이터 과학</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">참고문헌</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">목차</h2>
   
  <ul>
  <li><a href="#pipefilter-capture" id="toc-pipefilter-capture" class="nav-link active" data-scroll-target="#pipefilter-capture"><span class="header-section-number">4.1</span> 명령어에서 출력 캡처하기</a></li>
  <li><a href="#pipefilter-filtering" id="toc-pipefilter-filtering" class="nav-link" data-scroll-target="#pipefilter-filtering"><span class="header-section-number">4.2</span> 출력 필터링</a></li>
  <li><a href="#pipefilter-redirection" id="toc-pipefilter-redirection" class="nav-link" data-scroll-target="#pipefilter-redirection"><span class="header-section-number">4.3</span> 다른 명령에 출력 전달하기</a></li>
  <li><a href="#동작방식" id="toc-동작방식" class="nav-link" data-scroll-target="#동작방식"><span class="header-section-number">4.4</span> 동작방식</a></li>
  <li><a href="#pipefilter-together" id="toc-pipefilter-together" class="nav-link" data-scroll-target="#pipefilter-together"><span class="header-section-number">4.5</span> 여러 명령 결합하기</a></li>
  <li><a href="#pipefilter-why" id="toc-pipefilter-why" class="nav-link" data-scroll-target="#pipefilter-why"><span class="header-section-number">4.6</span> 함께 작동하도록 설계된 도구</a></li>
  <li><a href="#사례-파일-확인하기" id="toc-사례-파일-확인하기" class="nav-link" data-scroll-target="#사례-파일-확인하기"><span class="header-section-number">4.7</span> 사례: 파일 확인하기</a>
  <ul class="collapse">
  <li><a href="#행수가-가장-많은-파일-찾기" id="toc-행수가-가장-많은-파일-찾기" class="nav-link" data-scroll-target="#행수가-가장-많은-파일-찾기">행수가 가장 많은 파일 찾기</a></li>
  <li><a href="#animals.csv-관측동물-빈도수" id="toc-animals.csv-관측동물-빈도수" class="nav-link" data-scroll-target="#animals.csv-관측동물-빈도수"><code>animals.csv</code> 관측동물 빈도수</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/bit2r/gpt-shell/edit/main/04-shell-pipefilter.qmd" class="toc-action"><i class="bi bi-github"></i>편집</a></li><li><a href="https://github.com/bit2r/gpt-shell/issues/new" class="toc-action"><i class="bi empty"></i>이슈 보고</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./01-shell-intro.html">쉘 프로그래밍</a></li><li class="breadcrumb-item"><a href="./04-shell-pipefilter.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파이프와 필터</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-pipe-filter" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">파이프와 필터</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>몇가지 기초 유닉스 명령어를 배웠기 때문에, 마침내 쉘의 가장 강력한 기능을 살펴볼 수 있게 되었다: 새로운 방식으로 기존에 존재하던 프로그램을 쉽게 조합해 낼 수 있게 한다. 간단한 유기 분자를 설명하는 6개의 파일이 들어 있는 <code>shell-lesson-data/exercise-data/alkanes</code> 디렉토리에서 시작한다. <code>.pdb</code> 파일 확장자는 단백질 데이터 은행 (Protein Data Bank) 형식으로, 분자의 각 원자 형식과 위치를 표시하는 간단한 텍스트 형식으로 되어 있다. <span class="citation" data-cites="garlan1993introduction">[@garlan1993introduction]</span> <span class="citation" data-cites="bass2003software">[@bass2003software]</span></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cubane.pdb</span>    ethane.pdb    methane.pdb</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">octane.pdb</span>    pentane.pdb   propane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>예제 명령을 실행해 본다:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc cubane.pdb</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">20</span>  156 1158 cubane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>wc</code> 명령어는 “word count”의 축약어로 파일의 라인 수, 단어수, 문자수를 계산한다. (왼쪽에서 오른쪽 순서대로 값을 반환)</p>
<p><code>wc *.pdb</code> 명령어를 실행하면, <code>*.pdb</code>에서 <code>*</code>은 0 혹은 더 많이 일치하는 문자를 매칭한다. 그래서 쉘은 <code>*.pdb</code>을 통해 <code>.pdb</code> 전체 리스트 목록을 반환한다:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="pp">*</span>.pdb</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">20</span>  156  1158  cubane.pdb</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">12</span>  84   622   ethane.pdb</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span>  57   422   methane.pdb</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">30</span>  246  1828  octane.pdb</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">21</span>  165  1226  pentane.pdb</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">15</span>  111  825   propane.pdb</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">107</span>  819  6081  total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>wc *.pdb</code>는 출력 마지막 줄에 있는 모든 줄의 총 개수도 표시한다.</p>
<p><code>wc</code> 대신에 <code>wc -l</code>을 실행하면, 출력결과는 파일마다 행의 수를 보여준다:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.pdb</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">20</span>  cubane.pdb</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">12</span>  ethane.pdb</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span>  methane.pdb</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">30</span>  octane.pdb</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">21</span>  pentane.pdb</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">15</span>  propane.pdb</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">107</span>  total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>-m</code> 및 <code>-w</code> 옵션을 <code>wc</code> 명령과 함께 사용하면 각각 문자 수 또는 단어 수만 표시할 수도 있다.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
왜 아무것도 하지 않을까?
</div>
</div>
<div class="callout-body-container callout-body">
<p>명령어를 통해 파일을 처리해야 하는데 파일 이름을 지정하지 않으면 어떻게 될까? 예를 들어 다음과 같이 입력하면 어떻게 될까요?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>명령 뒤에 <code>*.pdb</code>(또는 다른 파일명)를 입력하지 않으면 어떻게 될까? 파일 이름이 없기 때문에 <code>wc</code>는 명령 프롬프트에서 주어진 입력을 처리해야 한다고 가정하고, 그냥 데이터를 입력할 때까지 대기한다. 하지만 밖에서 보면, 아무 일도 하지 않고 그냥 대기하고 있는 것으로 비춰진다.</p>
<p>이런 실수를 하는 경우, 컨트롤 키(Ctrl)를 누른 상태에서 문자 <code>C</code>를 한 번 누르면 이 상태에서 벗어날 수 있다: <code>Ctrl+C</code>. 그런 다음 눌렀던 두 키를 모두 놓는다.</p>
</div>
</div>
<section id="pipefilter-capture" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="pipefilter-capture"><span class="header-section-number">4.1</span> 명령어에서 출력 캡처하기</h2>
<p>파일 중에서 어느 파일이 가장 짧을까요? 단지 6개의 파일이 있기 때문에 질문에 답하기는 쉬울 것이다. 하지만 만약에 6,000개 파일이 있다면 어떨까요? 해결에 이르는 첫번째 단계로 다음 명령을 실행한다:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.pdb <span class="op">&gt;</span> lengths.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>&gt;</code> 기호는 쉘로 하여금 처리 결과를 화면에 뿌리는 대신, 파일로 <strong>방향변경(redirect)</strong>하게 한다. 만약 파일이 존재하지 않으면 파일을 생성하고 파일이 존재하면 파일에 내용을 덮어쓰기 한다. 조용하게 덮어쓰기를 하기 때문에 자료가 유실될 수 있어 주의가 요구된다. <code>ls lengths.txt</code> 을 통해 파일이 존재하는 것을 확인한다:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls lengths.txt</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">lengths.txt</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>cat lengths.txt</code>을 사용해서 화면으로 <code>lengths.txt</code>의 내용을 보낼 수 있다. <code>cat</code>은 “concatenate”(연결, 함께 연결)의 줄임말로 하나씩 하나씩 파일의 내용을 출력한다. 이번 경우에는 파일이 하나만 있어, <code>cat</code> 명령어는 한 파일이 담고 있는 내용만 보여준다:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat lengths.txt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">20</span>  cubane.pdb</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">12</span>  ethane.pdb</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span>  methane.pdb</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">30</span>  octane.pdb</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">21</span>  pentane.pdb</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">15</span>  propane.pdb</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">107</span>  total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
페이지 단위 출력결과 살펴보기
</div>
</div>
<div class="callout-body-container callout-body">
<p>편리성과 일관성을 위해 <code>cat</code> 명령어를 계속 사용하지만, 파일 전체를 화면에 쭉 뿌린다는 면에서 단점도 있다. 실무적으로 <code>less</code> 명령어가 더 유용한데 <code>$ less lengths.txt</code>와 같이 사용한다. 파일을 화면 단위로 출력한다. 아래로 내려가려면 스페이스바를 누르고, 뒤로 돌아가려면 <code>b</code>를 누르면 되고, 빠져 나가려면 <code>q</code>를 누른다. </p>
</div>
</div>
</section>
<section id="pipefilter-filtering" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="pipefilter-filtering"><span class="header-section-number">4.2</span> 출력 필터링</h2>
<p>이제 <code>sort</code> 명령어를 사용해서 파일 내용을 정렬한다. 먼저 정렬 명령에 대해 조금 알아보기 위해 연습문제를 풀어보자. </p>
<div id="exr-sort" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.1 (<code>sort -n</code> 명령어는 어떤 작업을 수행할까?)</strong></span> 다음 파일 행을 포함하고 있는 파일에 <code>sort</code> 명령어를 실행하면, </p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">10</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ex">2</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ex">19</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ex">22</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ex">6</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>출력결과는 다음과 같다:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">10</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">19</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ex">22</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ex">6</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>동일한 입력에 대해서 <code>sort -n</code>을 실행하면, 대신에 다음 결과를 얻게 된다:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">6</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ex">10</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ex">19</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ex">22</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>인수 <code>-n</code>이 왜 이런 효과를 가지는지 설명하세요.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>-n</code> 플래그는 알파벳 정렬이 아닌, 숫자 기준으로 정렬하도록 명세한다.</p>
</div>
</div>
</div>
<p><code>-n</code> 플래그를 사용해서 알파벳 대신에 숫자 방식으로 정렬할 것을 지정할 수 있다. 이 명령어는 파일 자체를 변경하지 <em>않고</em> 대신에 정렬된 결과를 화면으로 보낸다:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sort <span class="at">-n</span> lengths.txt</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">9</span>  methane.pdb</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">12</span>  ethane.pdb</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">15</span>  propane.pdb</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">20</span>  cubane.pdb</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a> <span class="ex">21</span>  pentane.pdb</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a> <span class="ex">30</span>  octane.pdb</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="ex">107</span>  total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>&gt; lengths.txt</code>을 사용해서 <code>wc</code> 실행결과를 <code>lengths.txt</code>에 넣었듯이, 명령문 다음에 <code>&gt; sorted-lengths.txt</code>을 넣음으로서, 임시 파일이름인 <code>sorted-lengths.txt</code>에 정렬된 목록 정보를 담을 수 있다. 이것을 실행한 다음에, 또 다른 <code>head</code> 명령어를 실행해서 <code>sorted-lengths.txt</code>에서 첫 몇 행을 뽑아낼 수 있다: </p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sort <span class="at">-n</span> lengths.txt <span class="op">&gt;</span> sorted-lengths.txt</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> head <span class="at">-n</span> 1 sorted-lengths.txt</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">9</span>  methane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>head</code>에 <code>-n 1</code> 매개변수를 사용해서 파일의 첫번째 행만이 필요하다고 지정한다. <code>-n 20</code>은 처음 20개 행만을 지정한다. <code>sorted-lengths.txt</code>이 가장 작은 것에서부터 큰 것으로 정렬된 파일 길이 정보를 담고 있어서, <code>head</code>의 출력 결과는 가장 짧은 행을 가진 파일이 되어야만 된다.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
동일한 파일로 방향변경
</div>
</div>
<div class="callout-body-container callout-body">
<p>명령어 출력결과를 방향변경하는데 동일한 파일에 보내는 것은 매우 나쁜 생각이다. 예를 들어:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sort <span class="at">-n</span> lengths.txt <span class="op">&gt;</span> lengths.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>위와 같이 작업하게 되면 틀린 결과를 얻을 수 있을 뿐만 아니라 경우에 따라서는 <code>lengths.txt</code> 파일 자체 내용을 잃어버릴 수도 있다.</p>
</div>
</div>
<div id="exr-redirection" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.2 (<code>&gt;&gt;</code>은 무엇을 의미하는가?)</strong></span> <code>&gt;</code> 사용법을 살펴봤지만, 유사한 연산자로 <code>&gt;&gt;</code>도 있는데 다소 다른 방식으로 동작한다. 문자열을 출력하는 <code>echo</code> 명령어를 사용해서, 아래 명령을 테스트하여 두 연산자 차이점을 확인한다: </p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo hello <span class="op">&gt;</span> testfile01.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> echo hello <span class="op">&gt;&gt;</span> testfile02.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>힌트: 각 명령문을 연속해서 두번 실행하고 나서, 출력결과로 나온 파일을 면밀히 조사한다.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>&gt;</code> 연산자를 갖는 첫번째 예제에서 문자열 “hello”는 <code>testfile01.txt</code> 파일에 저장된다. 하지만, 매번 명령어를 실행할 때마다 동일한 문자열 “hello”가 파일에 덮어쓰기 된다.</p>
<p>두번째 예제에서 <code>&gt;&gt;</code> 연산자도 마찬가지로 “hello”를 파일에 저장(이 경우 <code>testfile02.txt</code>)하는 것을 알 수 있다. 하지만, 파일이 이미 존재하는 경우(즉, 두번째 명령어를 실행하게 되면) 파일에 문자열을 덧붙인다. 계속 반복할 경우 “hello”가 파일에 줄바꿈하여 계속 추가된다.</p>
</div>
</div>
</div>
<div id="exr-data" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.3 (데이터 덧붙이기)</strong></span> <code>head</code> 명령어는 이미 살펴봤고, 파일 시작하는 몇줄을 화면에 출력하는 역할을 수행한다. <code>tail</code> 명령어도 유사하지만, 반대로 파일 마지막 몇줄을 화면에 출력하는 역할을 수행한다. <code>shell-lesson-data/exercise-data/animal-counts/animals.csv</code> 파일을 생각해 보자. 다음 명령어를 실행하게 되면 <code>animals-subset.csv</code> 파일에 저장될 내용이 어떤 것일지 아래에서 정답을 고르세요: </p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> head <span class="at">-n</span> 3 animals.csv <span class="op">&gt;</span> animals-subset.csv</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> tail <span class="at">-n</span> 2 animals.csv <span class="op">&gt;&gt;</span> animals-subset.csv</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li><code>animals.csv</code> 파일 첫 3줄.</li>
<li><code>animals.csv</code> 파일 마지막 2줄.</li>
<li><code>animals.csv</code> 파일의 첫 3줄과 마지막 2줄.</li>
<li><code>animals.csv</code> 파일의 두번째 세번째 줄.</li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p>정답은 3. 1번이 정답이 되려면, <code>head</code> 명령어만 실행한다. 2번이 정답이 되려면, <code>tail</code> 명령어만 실행한다. 4번이 정답이 되려면, <code>head -3 animals.csv | tail -2 &gt;&gt; animals-subset.csv</code> 명령어를 실행해서 <code>head</code> 출력결과를 파이프에 넣어 <code>tail -2</code>를 실행해야 한다.</p>
</div>
</div>
</div>
</section>
<section id="pipefilter-redirection" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="pipefilter-redirection"><span class="header-section-number">4.3</span> 다른 명령에 출력 전달하기</h2>
<p>줄이 가장 적은 파일을 찾는 예제에서 출력을 저장하기 위해 <code>lengths.txt</code>와 <code>sorted-lengths.txt</code> 파일을 중간에 사용했다. 하지만, 이런 방식은 번잡한하다. 이유는 <code>wc</code>, <code>sort</code>, <code>head</code> 명령어 각각이 어떻게 동작하는지 이해해도, 중간에 산출되는 파일에 무슨 일이 진행되고 있는지 따라가기는 쉽지 않기 때문이다. <code>sort</code>와 <code>head</code>을 함께 실행하는 경우 이해하기 훨씬 쉽게 만들 수 있다:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sort <span class="at">-n</span> lengths.txt <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n</span> 1</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">9</span>  methane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>두 명령문 사이의 수직 막대를 <strong>파이프(pipe)</strong>라고 부른다. 수직막대는 쉘에게 왼편 명령문의 출력결과를 오른쪽 명령문의 입력값으로 사용된다는 뜻을 전달한다. 컴퓨터는 필요하면 임시 파일을 생성하거나, 한 프로그램에서 주기억장치의 다른 프로그램으로 데이터를 복사하거나, 혹은 완전히 다른 작업을 수행할 수도 있다. 사용자는 알 필요도 없고 관심을 가질 이유도 없다. 중요한 것은 중간에 생성된 <code>sorted-lengths.txt</code> 파일이 필요없게 되었다는 점이다.</p>
</section>
<section id="동작방식" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="동작방식"><span class="header-section-number">4.4</span> 동작방식</h2>
<p>파이프를 생성할 때 뒤에서 실질적으로 일어나는 일은 다음과 같다. 컴퓨터가 한 프로그램(어떤 프로그램도 동일)을 실행할 때 프로그램에 대한 소프트웨어와 현재 상태 정보를 담기 위해서 주기억장치 메모리에 <strong>프로세스(process)</strong>를 생성한다. 모든 프로세스는 <strong>표준 입력(standard input)</strong>이라는 입력 채널을 가지고 있다. (여기서 이름이 너무 기억하기 좋아서 놀랄지도 모른다. 하지만 걱정하지 말자. 대부분의 유닉스 프로그래머는 “stdin”이라고 부른다). 또한 모든 프로세스는 <strong>표준 출력(standard output)</strong>(혹은 “stdout”)이라고 불리는 기본디폴트 출력 채널도 있다. 이 채널이 일반적으로 오류 혹은 진단 메시지 용도로 사용되어서 터미널로 오류 메시지를 받으면서도 그 와중에 프로그램 출력값이 또다른 프로그램에 파이프되어 들어가는 것이 가능하게 한다. </p>
<p>쉘은 실질적으로 또다른 프로그램이다. 정상적인 상황에서 사용자가 키보드로 타이핑하는 모든 것은 표준 입력으로 쉘에 보내지고, 표준 출력에서 만들어지는 무엇이 든지 화면에 출력된다. 쉘에게 프로그램을 실행하게 할때, 새로운 프로세스를 생성하고, 임시로 키보드에 타이핑하는 무엇이든지 그 프로세스의 표준 입력으로 보내지고, 프로세스는 표준 출력을 무엇이든 화면에 전송한다.</p>
<p><code>wc -l *.pdb &gt; lengths</code>을 실행할 때 여기서 일어나는 것을 설명하면 다음과 같다. <code>wc</code> 프로그램을 실행할 새로운 프로세스를 생성하라고 쉘이 컴퓨터에 지시한다. 파일이름을 인자로 제공했기 때문에 표준입력 대신 <code>wc</code>는 인자에서 입력값을 읽어온다. <code>&gt;</code>을 사용해서 출력값을 파일로 방향변경 했기 때문에, 쉘은 프로세스의 표준 출력결과를 파일에 연결한다.</p>
<p><code>wc -l *.pdb | sort -n</code>을 실행한다면, 쉘은 프로세스 두개를 생성한다. (파이프 프로세스 각각에 대해서 하나씩) 그래서 <code>wc</code>과 <code>sort</code>은 동시에 실행된다. <code>wc</code>의 표준출력은 직접적으로 <code>sort</code>의 표준 입력으로 들어간다. <code>&gt;</code>같은 방향변경이 없기 때문에 <code>sort</code>의 출력은 화면으로 나가게 된다. <code>wc -l *.pdb | sort -n | head -1</code>을 실행하면, 파일에서 <code>wc</code>에서 <code>sort</code>로, <code>sort</code>에서 <code>head</code>을 통해 화면으로 나가게 되는 데이터 흐름을 가진 프로세스 3개가 있게 된다.</p>
</section>
<section id="pipefilter-together" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="pipefilter-together"><span class="header-section-number">4.5</span> 여러 명령 결합하기</h2>
<p>어떤 것도 파이프를 연속적으로 사슬로 엮어 사용하는 것을 막을 수는 없다. 즉, 예를 들어 또 다른 파이프를 사용해서 <code>wc</code>의 출력결과를 <code>sort</code>에 바로 보내고 나서, 다시 처리 결과를 <code>head</code>에 보낸다. <code>wc</code> 출력결과를 <code>sort</code>로 보내는데 파이프를 사용했다:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.pdb <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-n</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span> methane.pdb</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="ex">12</span> ethane.pdb</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="ex">15</span> propane.pdb</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">20</span> cubane.pdb</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">21</span> pentane.pdb</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">30</span> octane.pdb</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">107</span> total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>또 다른 파이프를 사용해서 <code>wc</code>의 출력결과를 <code>sort</code>에 바로 보내고 나서, 다시 처리 결과를 <code>head</code>로 보내게 되면 전체 파이프라인은 다음과 같이 된다:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.pdb <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-n</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n</span> 1</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span>  methane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이것이 정확하게 수학자가 <em>log(3x)</em> 같은 중첩함수를 사용하는 것과 같다. “<em>log(3x)</em>은 x에 3을 곱하고 로그를 취하는 것과 같다.” 이번 경우는, <code>*.pdb</code>의 행수를 세어서 정렬해서 첫부분만 계산하는 것이 된다. 시각적으로 <a href="#fig-pipe-redirect" class="quarto-xref">그림&nbsp;<span>4.1</span></a> 에 표현되어 있다.</p>
<div id="fig-pipe-redirect" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pipe-redirect-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/redirects-and-pipes.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" width="429">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pipe-redirect-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;4.1: 방향변경과 파이프
</figcaption>
</figure>
</div>
<div id="exr-pipe" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.4 (명령문을 파이프로 연결하기)</strong></span> 현재 작업 디렉토리에, 최소 행수를 갖는 파일을 3개 찾고자 한다. 아래 열거된 어떤 명령어 중 어떤 것이 원하는 파일 3개를 찾아줄까?</p>
<ol type="1">
<li><code>wc -l * &gt; sort -n &gt; head -n 3</code></li>
<li><code>wc -l * | sort -n | head -n 1-3</code></li>
<li><code>wc -l * | head -n 3 | sort -n</code></li>
<li><code>wc -l * | sort -n | head -n 3</code></li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p>해답은 4. 파이프 문자 <code>|</code>을 사용해서 이 프로세스 표준출력을 다른 프로세스 표준입력으로 넣어준다. <code>&gt;</code> 기호는 표준입력을 파일로 방향변경할 때 사용한다. <code>shell-lesson-data/exercise-data/alkanes</code> 디렉토리에서 확인해 보자.</p>
</div>
</div>
</div>
</section>
<section id="pipefilter-why" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="pipefilter-why"><span class="header-section-number">4.6</span> 함께 작동하도록 설계된 도구</h2>
<p>프로그램을 연결하는 아이디어가 왜 유닉스가 그토록 성공적이었는지를 잘 보여준다. 다양한 작업을 수행하는 거대한 프로그램을 생성하는 대신에, 유닉스 개발자는 각자 한가지 작업만을 아주 잘 수행하는 간단한 도구를 많이 생성하고, 상호 유기적으로 잘 작동하는데 집중한다. 이러한 프로그래밍 모델을 파이프와 필터(pipes and filters)라고 부른다. 파이프는 이미 살펴봤고, <strong>필터(filter)</strong>는 입력 스트림을 출력 스트림으로 변환하는 <code>wc</code>, <code>sort</code>같은 프로그램이다. 거의 모든 표준 유닉스 도구는 이런 방식으로 동작한다: 별도로 언급되지 않는다면, 표준 입력에서 읽고, 읽은 것을 가지고 무언가를 수행하고 표준출력에 쓴다.</p>
<p>중요한 점은 표준입력에서 텍스트 행을 읽고, 표준 출력에 텍스트 행을 쓰는 거의 모든 프로그램이 이런 방식으로 동작하는 모든 다른 프로그램과 조합될 수 있다는 점이다. 여러분도 본인이 작성한 프로그램을 이러한 방식으로 작성할 수 있어야 하고 <em>작성해야 한다</em>. 그래서 여러분과 다른 사람들이 이러한 프로그램을 파이프에 넣어 생태계 전체 힘을 배가할 수 있다.</p>
<div id="exr-rc" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.5 (파이프 독해능력)</strong></span> <code>shell-lesson-data/exercise-data/animal-counts</code> 폴더에 <code>animals.csv</code>로 불리는 파일은 다음 데이터를 포함하고 있다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,deer,5</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,rabbit,22</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,raccoon,7</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,rabbit,19</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,deer,2</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,fox,4</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-07,rabbit,16</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-07,bear,1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>다음 아래 파이프라인에 각 파이프를 통과하고, 마지막 방향변경을 마친 텍스트는 무엇이 될까요? <code>sort -r</code> 명령어는 역방향으로 정렬함에 주목한다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cat animals.csv <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n</span> 5 <span class="kw">|</span> <span class="fu">tail</span> <span class="at">-n</span> 3 <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-r</span> <span class="op">&gt;</span> final.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>힌트: 명령어를 한번에 하나씩 작성해서 파이프라인을 구축한 뒤에 이해한 것이 맞는지 시험한다.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>head</code> 명령어는 <code>animals.csv</code> 파일에서 첫 5 행을 추출한다. 그리고 나서, <code>tail</code> 명령어로 이전 5 행에서 마지막 3 행을 추출된다. <code>sort -r</code> 명령어는 역순으로 정렬을 시키게 된다. 마지막으로 출력결과는 <code>final.txt</code> 파일에 방향변경하여 화면이 아닌 파일로 보낸다. 파일에 저장된 내용은 <code>cat final.txt</code> 명령어를 실행하면 확인이 가능하다. 파일에는 다음 내용이 저장되어야 한다:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,rabbit,19</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,deer,2</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,raccoon,7</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<div id="exr-pipe-construct" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.6 (파이프 구성)</strong></span> 이전 예제에 사용된 <code>animals.csv</code> 파일을 가지고 다음 명령어를 실행한다:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cut <span class="at">-d</span> , <span class="at">-f</span> 2 animals.csv</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>콤마를 구분자로 각 행을 쪼개려고 하면 <code>-d</code> 플래그를 사용하고, <code>-f</code> 플래그는 각행의 두번째 필드를 지정하게 되서 출력결과는 다음과 같다:</p>
<p><code>cut</code> 명령은 파일에서 각 행의 특정 부분을 제거하거나 ’잘라내기’하는 데 사용되며, <code>cut</code> 명령어는 행을 탭(Tab) 문자를 구분자로 사용하여 열을 쪼갠다. 이러한 방식으로 사용되는 문자를 <strong>구분 기호(delimiter)</strong>라고 합니다. 앞에서 <code>-d</code> 옵션을 사용하여 쉼표(<code>,</code>)를 구분 기호 문자로 지정했다. 또한 <code>-f</code> 옵션을 사용하여 두 번째 필드(열)를 추출하도록 지정했다. 그러면 다음과 같은 출력이 생성된다: </p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">deer</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ex">rabbit</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ex">raccoon</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ex">rabbit</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ex">deer</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="ex">fox</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ex">rabbit</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="ex">bear</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>uniq</code> 명령은 파일에 인접한 일치하는 행을 필터링하여 중복을 제거한다. 파일에 담겨 있는 동물이 무엇인지를 알아내려면, 다른 어떤 명령어가 파이프라인에 추가되어야 하나요? (동물 이름에 어떠한 중복도 없어야 합니다.)</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb26"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cut <span class="at">-d</span> , <span class="at">-f</span> 2 animals.csv <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">uniq</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
<div id="exr-selection" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.7 (파이프 선택?)</strong></span> <code>animals.csv</code> 파일은 아래 형식으로 8줄로 구성되어 있다:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,deer,5</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,rabbit,22</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,raccoon,7</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,rabbit,19</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>uniq</code> 명령에 <code>-c</code> 옵션을 넣어 발생한 횟수를 카운트할 수 있다. <code>shell-lesson-data/exercise-data/animal-counts</code> 현재 디렉토리로 가정하고, 다음 중 어떤 명령어가 동물 종류별로 전체 출현 빈도수를 나타내는 표를 작성하는데 사용하면 좋을까요?</p>
<ol type="1">
<li><code>sort animals.csv | uniq -c</code></li>
<li><code>sort -t, -k2,2 animals.csv | uniq -c</code></li>
<li><code>cut -d, -f 2 animals.csv | uniq -c</code></li>
<li><code>cut -d, -f 2 animals.csv | sort | uniq -c</code></li>
<li><code>cut -d, -f 2 animals.csv | sort | uniq -c | wc -l</code></li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p>정답은 4.</p>
<p>정답을 이해하는데 어려움이 있으면, (<code>shell-lesson-data/exercise-data/animal-counts</code> 디렉토리에 위치한 것을 확인한 후) 명령어 전체를 실행하거나, 파이프라인 일부를 실행해 본다.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
입력 방향변경
</div>
</div>
<div class="callout-body-container callout-body">
<p>프로그램의 출력 결과 방향변경을 위해서 <code>&gt;</code>을 사용하는 것과 마찬가지로, <code>&lt;</code>을 사용해서 입력을 되돌릴 수도 있다. 즉, 표준입력 대신에 파일로부터 읽어 들일 수 있다. 예를 들어, <code>wc ammonia.pdb</code> 와 같이 작성하는 대신에, <code>wc &lt; ammonia.pdb</code> 작성할 수 있다. 첫째 사례는, <code>wc</code>는 무슨 파일을 여는지를 명령 라인의 매개변수에서 얻는다. 두번째 사례는, <code>wc</code>에 명령 라인 매개변수가 없다. 그래서 표준 입력에서 읽지만, 쉘에게 <code>ammonia.pdb</code>의 내용을 <code>wc</code>에 표준 입력으로 보내라고 했다.</p>
</div>
</div>
<div id="exr-stdin-reverse" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.8 (<code>&lt;</code> 기호의 의미는?)</strong></span> 다운로드 예제 데이터를 갖고 있는 최상위 <code>shell-lesson-data</code> 디렉토리로 작업 디렉토리를 변경한다. 다음 두 명령어 차이는 무엇인가?</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> notes.txt</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="op">&lt;</span> notes.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<p><code>&lt;</code> 기호는 입력을 방향변경을 해서 명령어로 전달한다.</p>
<p>상기 예제 모두에서, 쉘은 입력에서 <code>wc</code> 명령어를 통해 행수를 반환한다. 첫번째 예제에서, 입력은 <code>notes.txt</code> 파일이고, 파일명이 <code>wc</code> 명령어로부터 출력으로 주어지게 된다. 두번째 예제로부터, <code>notes.txt</code> 파일 내용이 표준입력으로 방향변경을 통해 보내지게 된다. 이것은 마치 프롬프트에서 파일 콘텐츠를 타이핑하는 것과 같다. 따라서, 파일명이 출력에 주어지지 않는다 - 단지 행번호만 주어진다. 다음과 같이 타이핑해보자:</p>
<pre><code>$ wc -l
this
is
a test
Ctrl-D</code></pre>
<p><code>Ctrl-D</code>를 타이핑하게 되면 쉘이 입력을 마무리한 것을 알게 전달하는 역할을 한다.</p>
</div>
</div>
</div>
<div id="exr-uniq" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.9 (<code>uniq</code>가 왜 인접한 중복 행만을 단지 제거한다고 생각합니까?)</strong></span> 명령문 <code>uniq</code>는 입력으로부터 인접한 중복된 행을 제거한다. 예를 들어, <code>salmon.txt</code> 파일에 다음이 포함되었다면,</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">coho</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ex">coho</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="ex">steelhead</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ex">coho</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ex">steelhead</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="ex">steelhead</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>shell-lesson-data/data</code> 디렉토리의 <code>uniq salmon.txt</code> 명령문 실행은 다음을 출력한다.</p>
<pre><code>coho
steelhead
coho
steelhead</code></pre>
<p><code>uniq</code>가 왜 인접한 중복 행만을 단지 제거한다고 생각합니까? (힌트: 매우 큰 파일을 생각해보세요.) 모든 중복된 행을 제거하기 위해, 파이프로 다른 어떤 명령어를 조합할 수 있을까요?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb32"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sort salmon.txt <span class="kw">|</span> <span class="fu">uniq</span> </span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="사례-파일-확인하기" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="사례-파일-확인하기"><span class="header-section-number">4.7</span> 사례: 파일 확인하기</h2>
<p>앞에서 설명한 것처럼 넬(nelle) 박사는 분석기를 통해 시료를 시험해서 <code>north-pacific-gyre</code> 디렉토리에 17개 파일을 생성했다. 빠르게 확인하기 위해, <code>shell-lesson-data</code> 디렉토리에서 다음과 같이 타이핑한다:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cd north-pacific-gyre/2012-07-03</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>결과는 다음과 같은 18 행이 출력된다:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01729A.txt</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01729B.txt</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01736A.txt</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01751A.txt</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01751B.txt</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01812A.txt</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span> ...</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이번에는 다음과 같이 타이핑한다:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.txt <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-n</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-n</span> 5</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="ex">240</span> NENE02018B.txt</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01729A.txt</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01729B.txt</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01736A.txt</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="ex">300</span> NENE01751A.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>이런, 파일중에 하나가 다른 것보다 60행이 짧다. 다시 돌아가서 확인하면, 월요일 아침 8:00 시각에 분석을 수행한 것을 알고 있다 — 아마도 누군가 주말에 기계를 사용했고, 다시 재설정하는 것을 깜빡 잊었을 것이다. 시료를 다시 시험하기 전에 파일 중에 너무 큰 데이터가 있는지를 확인한다:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> wc <span class="at">-l</span> <span class="pp">*</span>.txt <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-n</span> <span class="kw">|</span> <span class="fu">tail</span> <span class="at">-n</span> 5</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a> <span class="ex">300</span> NENE02040B.txt</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a> <span class="ex">300</span> NENE02040Z.txt</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a> <span class="ex">300</span> NENE02043A.txt</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a> <span class="ex">300</span> NENE02043B.txt</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="ex">5040</span> total</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>숫자는 예뻐 보인다 — 하지만 끝에서 세번째 줄에 ‘Z’는 무엇일까? 모든 시료는 ’A’ 혹은 ’B’로 표시되어야 한다. 시험실 관례로 ’Z’는 결측치가 있는 시료를 표식하기 위해 사용된다. 더 많은 결측 시료를 찾기 위해, 다음과 같이 타이핑한다:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls <span class="pp">*</span>Z.txt</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ex">NENE01971Z.txt</span>    NENE02040Z.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>노트북의 로그 이력을 확인할 때, 상기 샘플 각각에 대해 깊이(depth) 정보에 대해서 기록된 것이 없었다. 다른 방법으로 정보를 더 수집하기에는 너무 늦어서, 분석에서 두 파일을 제외하기로 했다. <code>rm</code> 명령어를 사용하여 삭제할 수 있지만, 향후에 깊이(depth)정보가 관련없는 다른 분석을 실시할 수도 있다. 대신 나중에 와일드카드 표현식 <code>NENE*A.txt</code> <code>NENE*B.txt</code>를 사용하여 파일을 선정하는데 주의를 기울여야된다.</p>
<div id="exr-remove" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.10 (불필요한 파일 제거)</strong></span> 저장공간을 절약하고자 중간 처리된 데이터 파일을 삭제하고 원본 파일과 처리 스크립트만 보관했으면 한다고 가정하자.</p>
<p>원본 파일은 <code>.dat</code>으로 끝나고, 처리된 파일은 <code>.txt</code>으로 끝난다. 다음 중 어떤 명령어가 처리과정에서 생긴 중간 모든 파일을 삭제하게 하는가?</p>
<ol type="1">
<li><code>rm ?.txt</code></li>
<li><code>rm *.txt</code></li>
<li><code>rm * .txt</code></li>
<li><code>rm *.*</code></li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
정답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li>한문자 .txt 파일을 제거한다.</li>
<li>정답</li>
<li><ul>
<li>기호로 인해 현재 디렉토리 모든 파일과 디렉토리를 매칭시킨다. 그래서 * 기호로 매칭되는 모든 것과 추가로 .txt 파일도 삭제한다.</li>
</ul></li>
<li><em>.</em> 기호는 임의 확장자를 갖는 모든 파일을 매칭시킨다. 따라서 <em>.</em> 기호는 모든 파일을 삭제한다.</li>
</ol>
</div>
</div>
</div>
<div id="exr-wildcard" class="theorem exercise">
<p><span class="theorem-title"><strong>예제 4.11 (와일드카드 표현식)</strong></span> 와일드카드 표현식(Wildcard Expressions)은 매우 복잡할 수 있지만, 종종 다소 장황할 수 있는 비용을 지불하고 간단한 구문만 사용해서 작성하기도 한다.</p>
<p><code>/shell-lesson-data/north-pacific-gyre</code> 디렉토리를 생각해 보자: <code>*[AB].txt</code> 와일드카드 표현식은 <code>A.txt</code> 혹은 <code>B.txt</code>으로 끝나는 모든 파일을 매칭시킨다. 이 와일드카드 표현식을 잊었다고 상상해보자:</p>
<ol type="1">
<li>[] 구문을 사용하지 않는 기본 와일드드카드 표현식으로 동일하게 파일을 매칭할 수 있을까? 힌트: 표현식이 하나 이상 필요할 수도 있다.</li>
<li>[] 구문을 사용하지 않고 작성한 표현식은 동일한 파일을 매칭한다. 두 출력결과의 작은 차이점은 무엇인가?</li>
<li>최초 와일드카드 표현식은 오류가 나지 않는데 어떤 상황에서 본인 표현식은 오류 메시지를 출력하는가?</li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
해답과 설명
</div>
</div>
<div class="callout-body-container callout-body">
<ol type="1">
<li></li>
</ol>
<div class="sourceCode" id="cb38"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls <span class="pp">*</span>A.txt</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls <span class="pp">*</span>B.txt</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>새로운 명령어에서 나온 출력결과는 명령어가 두개라 구분된다.</li>
<li>A.txt로 끝나는 파일이 없거나 B.txt로 끝나는 파일이 없는 경우 그렇다.</li>
</ol>
</div>
</div>
</div>
<p>PDB (Protein Data Bank)는 큰 생물학적 분자, 예를 들면 단백질이나 핵산의 3차원 구조 데이터를 저장한 데이터베이스다. 이 데이터는 보통 X-선 결정학, NMR 분광학, 혹은 점점 더 많이 사용되는 cryo-전자 현미경을 통해 얻어지며, PDB 웹사이트를 통해 무료로 이용할 수 있다. 파일 확장자는 <code>.pdb</code> 를 갖고 예를 들어 “methane.pdb”라는 파일은 메테인이라는 화합물의 3차원 구조 정보를 담고 있는 PDB (Protein Data Bank) 파일을 지칭합하고 메테인 분자의 원자들의 위치, 분자의 종류 등의 정보를 포함하고 있을 것이다.</p>
<section id="행수가-가장-많은-파일-찾기" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="행수가-가장-많은-파일-찾기">행수가 가장 많은 파일 찾기</h3>
<p><code>shell-lesson-data/exercise-data/</code> 디렉토리에 있는 모든 <code>*.pdb</code> 파일을 찾아 각 파일의 행수를 구한 후 가장 행수가 많은 파일부터 역순으로 정렬하는 유닉스 쉘 명령어를 작성해보자.</p>
<blockquote class="blockquote">
<p>프롬프트: shell-lesson-data/exercise-data/ 디렉토리로 이동한 후 확 장자가 .pdb인 파일 행수를 구한 후에 파일별 행수를 내림차순으로 출력하도록 하세요.</p>
</blockquote>
<p>얻어진 유닉스 쉘 명령어를 실행하게 되면 앞서 순차적으로 작성한 유닉스 명령어와 동일한 결과를 얻게 된다.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sgpt <span class="at">-s</span> <span class="st">"shell-lesson-data/exercise-data/ 디렉토리로 이동한 후 확</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="st">장자가 .pdb인 파일 행수를 구한 후에 파일별 행수를 내림차순으로 출력하도록 하세요."</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> shell-lesson-data/exercise-data/ <span class="kw">&amp;&amp;</span> <span class="fu">find</span> . <span class="at">-name</span> <span class="st">"*.pdb"</span> <span class="kw">|</span> <span class="fu">xargs</span> wc <span class="at">-l</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-nr</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="ex">[E]xecute,</span> <span class="pp">[</span><span class="ss">D</span><span class="pp">]</span>escribe, <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span>bort: D</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="ex">This</span> command changes the current directory to <span class="st">"shell-lesson-data/exercise-data/"</span>, then finds all files with the extension <span class="st">".pdb"</span> in that directory and its subdirectories, counts the number of lines in each file using <span class="st">"wc -l"</span>, and finally sorts the results in descending order.</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="ex">[E]xecute,</span> <span class="pp">[</span><span class="ss">D</span><span class="pp">]</span>escribe, <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span>bort: E</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a> <span class="ex">107</span> total</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  <span class="ex">30</span> ./alkanes/octane.pdb</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="ex">21</span> ./alkanes/pentane.pdb</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  <span class="ex">20</span> ./alkanes/cubane.pdb</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="ex">15</span> ./alkanes/propane.pdb</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="ex">12</span> ./alkanes/ethane.pdb</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>   <span class="ex">9</span> ./alkanes/methane.pdb</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>챗GPT가 프롬프트로 작성한 유닉스 쉘 명령어를 해석하면 다음과 같다.</p>
<blockquote class="blockquote">
<p>현재 디렉터리를 “shell-lesson-data/exercise-data/”로 변경한 다음 해당 디렉터리 및 하위 디렉터리에서 확장자가 “.pdb”인 모든 파일을 찾고, “wc -l”을 사용하여 각 파일의 줄 수를 세고, 마지막으로 결과를 내림차순으로 정렬한다.</p>
</blockquote>
<p>바로 실행시키게 되면 앞서 실행한 것과 역순으로 정렬된 것만 반대로 차이가 있고 결과는 동일함을 알 수 있다.</p>
</section>
<section id="animals.csv-관측동물-빈도수" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="animals.csv-관측동물-빈도수"><code>animals.csv</code> 관측동물 빈도수</h3>
<p><code>shell-lesson-data/exercise-data/animal-counts</code> 디렉토리에 있는 <code>animals.csv</code>은 다음과 같은 형태로 되어 있다. 즉, 콤마로 구분되는 3개의 칼럼과 8개의 관측점으로 구성되어 있지만 <code>.csv</code> 파일에 칼럼명이 없는 구조를 갖고 있다. <code>animals.csv</code>에 종별 관측빈도를 구해보자. 챗GPT 프롬프트를 이에 맞춰 작성하고 <code>sgpt -s</code>로 실행해서 결과를 얻어보자.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,deer,5</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,rabbit,22</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-05,raccoon,7</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,rabbit,19</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,deer,2</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-06,fox,4</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-07,rabbit,16</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="ex">2012-11-07,bear,1</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<blockquote class="blockquote">
<p>프롬프트: shell-lesson-data/exercise-data/animal-counts 디렉토리로 이동한 후 animals.csv 파일에서 두번째 칼럼에서 관측된 동물의 빈도수를 역순으로 구해서 출력하시요</p>
</blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sgpt <span class="at">-s</span> <span class="st">"shell-lesson-data/exercise-data/animal-counts 디렉토리로 이동한 후 animals.csv 파일에서 두번째 칼럼에서 관측된 동물의 빈도수를 역순으로 구해서 출력하시요"</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> shell-lesson-data/exercise-data/animal-counts <span class="kw">&amp;&amp;</span> <span class="fu">awk</span> <span class="at">-F</span><span class="st">','</span> <span class="st">'{print $2}'</span> animals.csv <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">uniq</span> <span class="at">-c</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-nr</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ex">[E]xecute,</span> <span class="pp">[</span><span class="ss">D</span><span class="pp">]</span>escribe, <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span>bort: D</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ex">This</span> command changes the directory to <span class="st">"shell-lesson-data/exercise-data/animal-counts"</span> and then uses awk to print the second column of the file <span class="st">"animals.csv"</span>, sorts the output, counts the unique values, and sorts them in descending order.</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="ex">[E]xecute,</span> <span class="pp">[</span><span class="ss">D</span><span class="pp">]</span>escribe, <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span>bort: E</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>      <span class="ex">3</span> rabbit</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>      <span class="ex">2</span> deer</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>      <span class="ex">1</span> raccoon</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>      <span class="ex">1</span> fox</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>      <span class="ex">1</span> bear</span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>챗GPT가 프롬프트로 작성한 유닉스 쉘 명령어를 해석하면 다음과 같다.</p>
<blockquote class="blockquote">
<p>디렉터리를 “shell-lesson-data/exercise-data/animal-counts”로 변경한 다음 awk를 사용하여 파일 “animals.csv”의 두 번째 열을 인쇄하고 출력결과를 정렬하고 유일무이한 고유값을 계산한 다음 내림차순으로 정렬한다.</p>
</blockquote>
<p>얻어진 유닉스 쉘 명령어를 실행하게 되면 토끼(rabbit)가 3회 등 정확한 계산결과가 도출된다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./03-shell-create.html" class="pagination-link" aria-label="파일과 디렉토리 작업">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">파일과 디렉토리 작업</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./05-shell-loop.html" class="pagination-link" aria-label="루프(Loops)">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">루프(Loops)</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>챗GPT SQL 책은 소프트웨어 카펜트리 Unix Shell 번역한 것이 포함되어 있습니다.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/bit2r/gpt-shell/edit/main/04-shell-pipefilter.qmd" class="toc-action"><i class="bi bi-github"></i>편집</a></li><li><a href="https://github.com/bit2r/gpt-shell/issues/new" class="toc-action"><i class="bi empty"></i>이슈 보고</a></li></ul></div></div>
    <div class="nav-footer-right">
<p>순수하게 <a href="https://quarto.org/">쿼토(Quarto)</a>로 제작되었습니다.</p>
</div>
  </div>
</footer>




</body></html>