[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gpt-shell",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\nls -F\n\n00_setup.qmd*\n01_openAI.qmd*\nLICENSE*\n_quarto.yml*\ncode/\ncover.png*\ndocs/\ngpt-shell.Rproj*\nimages/\nindex.qmd*\nindex.rmarkdown*\nreferences.bib*\nreferences.qmd*\nshell-create.Rmd*\nshell-filedir.qmd*\nshell-find.Rmd*\nshell-intro.qmd*\nshell-loop.Rmd*\nshell-novice/\nshell-pipefilter.Rmd*\nshell-script.Rmd*"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "참고문헌",
    "section": "",
    "text": "Vaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion\nJones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017.\n“Attention Is All You Need.” https://arxiv.org/abs/1706.03762."
  },
  {
    "objectID": "00_setup.html",
    "href": "00_setup.html",
    "title": "1  환경설정",
    "section": "",
    "text": "2 OpenAI 모형\nOpenAI에서 제공하는 다양한 모델을 확인할 수 있다. system이 소유한 GPT 모형을 살펴보자.\n프로그램 코드(code) 관련된 GPT 모형도 확인할 수 있다."
  },
  {
    "objectID": "00_setup.html#가상환경-설정",
    "href": "00_setup.html#가상환경-설정",
    "title": "1  환경설정",
    "section": "1.1 가상환경 설정",
    "text": "1.1 가상환경 설정\n다양한 가상환경이 있어 필요한 패키지를 사용하여 파이썬 가상환경을 구축한다. 파이썬 3.3 버전부터 내장된 venv, 많이 사용되는 virtualenvwrapper, virtualenv 등이 유명하다. 본인 취향에 맞는 가상환경을 특정하여 업무에 사용한다. 다음은 venv를 사용해서 가상 개발환경을 구축하는 것을 예시로 보여주고 있다.\n## 디렉토리 생성 및 프로젝트 디렉토리 이동\nmkdir myproject\ncd myproject\n\n## 가상환경 생성\npython -m venv myenv\n\n## 가상환경 활성화\nmyenv\\Scripts\\activate # 윈도우즈\nsource myenv/bin/activate # 리눅스/맥\n\n## 가상환경 비활성화\ndeactivate"
  },
  {
    "objectID": "00_setup.html#api-key-얻기",
    "href": "00_setup.html#api-key-얻기",
    "title": "1  환경설정",
    "section": "1.2 API KEY 얻기",
    "text": "1.2 API KEY 얻기\n가상환경을 구축한 다음 OpenAI에서 제공하는 공식 API에 접근할 수 있는 API 키를 생성하는 것이다. https://openai.com/api/ 1 로 이동하여 계정을 만듭니다.\n안내에 따라 계정을 생성한 다음 https://platform.openai.com/account/api-keys 2 로 이동하여 API 키를 생성한다.\nAPI 키는 조직에 속해야 하며, 조직을 생성하라는 메시지가 표시되는 경우 조직명을 입력한다. 하나의 조직에 속한 경우 조직 ID(Organization ID)를 별도 생성할 필요는 없다. OpenAI 계정을 통해서는 생성한 API KEY는 다시 볼 수 없기 때문에 생성한 비밀 키를 안전하고 접근하기 쉬운 곳에 저장한다."
  },
  {
    "objectID": "00_setup.html#api-key-저장",
    "href": "00_setup.html#api-key-저장",
    "title": "1  환경설정",
    "section": "1.3 API KEY 저장",
    "text": "1.3 API KEY 저장\nAPI KEY를 환경변수로 지정하여 호출하는 방식도 있고, 작업 프로젝트 디렉토리에 로컬 파일에 저장하여 사용하는 방식도 있다. 먼저 윈도우에서 시스템으로 들어가서 환경 변수로 지정하면 해당 변수(OPENAI_API_KEY)를 다양한 프로그램에서 호출하여 사용할 수 있다.\n\n다른 방식은 .env와 같은 파일을 프로젝트 디렉토리 아래 숨긴 파일에 지정하여 사용하는 방식이다. 이런 경우 .gitignore 파일에 버전제어 대상에서 제외시켜 두는 것을 필히 기억한다."
  },
  {
    "objectID": "00_setup.html#헬로월드",
    "href": "00_setup.html#헬로월드",
    "title": "1  환경설정",
    "section": "1.4 헬로월드",
    "text": "1.4 헬로월드\nOpenAI API KEY도 준비가 되었으면 헬로월드 프로그램을 작성해보자. 개발자가 하나의 조직에 속한 경우, API KEY를 운영체제 환경변수로 지정한 경우 다음과 같이 시스템 환경에서 OPENAI_API_KEY 키를 가져와서 OpenAI에서 제공하는 모델목록을 확인할 수 있다.\n\nimport os\nimport openai\n\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\n# API 호출 및 모델 목록 출력\nmodels = openai.Model.list()\nprint(models['data'][0])\n\n{\n  \"created\": 1649358449,\n  \"id\": \"babbage\",\n  \"object\": \"model\",\n  \"owned_by\": \"openai\",\n  \"parent\": null,\n  \"permission\": [\n    {\n      \"allow_create_engine\": false,\n      \"allow_fine_tuning\": false,\n      \"allow_logprobs\": true,\n      \"allow_sampling\": true,\n      \"allow_search_indices\": false,\n      \"allow_view\": true,\n      \"created\": 1669085501,\n      \"group\": null,\n      \"id\": \"modelperm-49FUp5v084tBB49tC4z8LPH5\",\n      \"is_blocking\": false,\n      \"object\": \"model_permission\",\n      \"organization\": \"*\"\n    }\n  ],\n  \"root\": \"babbage\"\n}\n\n\n다른 방식은 로컬 파일에 API KEY와 ORG ID 를 저장하고 이를 불러와서 개발에 사용하는 방식이다.\n\nimport os\nimport openai\n\n# .env 파일에서 API_KEY 와 ORG_ID 을 읽어온다.\nwith open(\".env\") as lines:\n  for line in lines:\n    key, value = line.strip().split(\"=\")\n    os.environ[key] = value\n    \n# api_key와 organization 지정\nopenai.api_key = os.environ.get(\"API_KEY\")\nopenai.organization = os.environ.get(\"ORG_ID\")\n\n# API 호출 및 모델 목록 출력\ngpt_models = openai.Model.list()\n\nprint(gpt_models['data'][0])\n\n{\n  \"created\": 1649358449,\n  \"id\": \"babbage\",\n  \"object\": \"model\",\n  \"owned_by\": \"openai\",\n  \"parent\": null,\n  \"permission\": [\n    {\n      \"allow_create_engine\": false,\n      \"allow_fine_tuning\": false,\n      \"allow_logprobs\": true,\n      \"allow_sampling\": true,\n      \"allow_search_indices\": false,\n      \"allow_view\": true,\n      \"created\": 1669085501,\n      \"group\": null,\n      \"id\": \"modelperm-49FUp5v084tBB49tC4z8LPH5\",\n      \"is_blocking\": false,\n      \"object\": \"model_permission\",\n      \"organization\": \"*\"\n    }\n  ],\n  \"root\": \"babbage\"\n}"
  },
  {
    "objectID": "01_openAI.html#텍스트-완성",
    "href": "01_openAI.html#텍스트-완성",
    "title": "2  OpenAI 들어가며",
    "section": "2.1 텍스트 완성",
    "text": "2.1 텍스트 완성\nGPT를 사용하여 다양한 작업을 수행할 수 있지만 가장 기본적인 작업은 글쓰기다. GPT가 생성형 AI로 해당 텍스트를 주어지면 나머지 텍스트를 해당 최대 토큰 크기(max_tokens) 길이만큼 텍스트를 생성해준다.\n\nimport os\nimport openai\n\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\ncomplete_next = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=\"나의 살던 고향은\",\n  max_tokens=7,\n  temperature=0)\n  \ncomplete_next['choices'][0]['text']\n\n'\\n\\n나의'\n\n\n토큰 크기를 100으로 지정하면 제법 긴 텍스트를 출력한다. 영어 토큰에 최적화되어 있는 관계로 한글의 경우 토큰 낭비(?)가 심한 것으로 보인다. 고로 비용이 제법 나가는 점은 한국어로 작업을 할 때 고려해야만 된다.\n\ncomplete_next_100 = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=\"나의 살던 고향은\",\n  max_tokens=100,\n  temperature=0)\n  \ncomplete_next_100['choices'][0]['text']\n\n'\\n\\n나의 고향은 전라도 익산입니다. 익산은 전라도의 중부에 위치한 도시로, 전라도의 중'"
  },
  {
    "objectID": "01_openAI.html#키워드-추출",
    "href": "01_openAI.html#키워드-추출",
    "title": "2  OpenAI 들어가며",
    "section": "2.2 키워드 추출",
    "text": "2.2 키워드 추출\n조금더 흥미로운 주제로 해당 문서를 제시하고 관련 텍스트의 주요 키워드를 추출해보자. Attention Is All You Need 논문(Vaswani et al. 2017)은 AI 분야에서 획기적인 논문으로 평가받있지만 별도 키워드는 제시되고 있지 않아 논문 초록을 앞에 제시하고 Keywords:를 뒤에 두고 논문의 주요 키워드를 추출하게 한다.\n\nprompt_keywords = \"The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder. The best performing models also connect the encoder and decoder through an attention mechanism. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely. Experiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train. Our model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature. We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.\\n\\n keywords:\"\n\nkeywords = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=prompt_keywords,\n  temperature = 0.5,\n  max_tokens  = 50)\n\nkeywords['choices'][0]['text']\n\nmax_tokens을 50으로 제한하여 temperature = 0.5로 너무 창의적이지 않게 키워드 추출 작업을 지시한 경우 다음과 같은 결과를 어덱 된다.\n'\\nSequence transduction, neural networks, attention mechanisms, machine translation, parsing'\n이번에는 한글 논문초록에서 키워드를 추출해보자. 2020년 출간된 논문(lee2020?)의 한글 초록에서 제시된 키워드와 OpenAI GPT가 제시하고 있는 키워드와 비교해보자.\n\n논문 소스코드: 바로가기\nPDF 출판 논문: 다운로드\n\n\nprompt_keywords = \"알파고가 2016년 바둑 인간 챔피언 이세돌 9단을 현격한 기량차이로 격파하면서 인공지능에 대한 관심이 급격히 증가하였다. 그와 동시에 기계가 인간의 일자리 잠식을 가속화하면서 막연한 불안감이 삽시간에 전파되었다. 기계와의 일자리 경쟁은 컴퓨터의 출현이전부터 시작되었지만 인간만의 고유한 영역으로 알고 있던 인지, 창작 등 다양한 분야에서 오히려 인간보다 더 우수한 성능과 저렴한 가격 경쟁력을 보여주면서 기존 인간의 일자리가 기계에 대체되는 것이 가시권에 들었다. 이번 문헌조사와 실증 데이터 분석을 통해서 기계가 인간의 일자리를 대체하는 자동화의 본질에 대해서 살펴보고, 인간과 기계의 업무 분장을 통해 더 생산성을 높일 수 있는 방안을 제시하고자 한다.\\n\\n 키워드:\"\n\nkeywords = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=prompt_keywords,\n  temperature = 0.5,\n  max_tokens  = 100)\n\nkeywords['choices'][0]['text']\n\n' 인공지능, 자동화, 인간과 기계의 업무 분장, 생산성 \\n\\n이 문헌조사는 인공지능이 인'\nGPT가 생성한 키워드를 논문저자가 추출한 키워드와 비교하면 다소 차이가 있지만 그래도 상위 3개 키워드는 높은 일치도를 보이고 있다.\n\n\n\nOpenAI GPT 키워드\n\n인공지능\n자동화\n인간과 기계의 업무 분장\n생산성 문헌조사는 인공지능이 인’\n\n\n\n\n논문저자 추출\n\n자동화\n데이터 과학\n인공지능\n일자리\n기계와 사람의 업무분장\n\n\n\n\nGPT-4는 더 높은 성능을 보여주고 있다. https://chat.openai.com/chat?model=gpt-4에 해당 텍스트를 던져주면 다음과 같이 키워드를 추출하고 요약을 해준다."
  },
  {
    "objectID": "01_openAI.html#텍스트-요약",
    "href": "01_openAI.html#텍스트-요약",
    "title": "2  OpenAI 들어가며",
    "section": "2.3 텍스트 요약",
    "text": "2.3 텍스트 요약\nAttention Is All You Need 논문(Vaswani et al. 2017) 초록은 https://platform.openai.com/tokenizer 계산기를 통해 230개 토큰 1,138 문자로 작성된 것이 확인된다. 영어 기준 다음과 같은 맥락을 이해하고 이를 대략 20% 수준 50 토큰으로 줄여보자.\n\n100 토큰은 대략 75 단어\n평균 단어는 대략 5 문자로 구성\n100 토큰은 375개 문자\n\n\nprompt_keywords = \"The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder. The best performing models also connect the encoder and decoder through an attention mechanism. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely. Experiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train. Our model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature. We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.\\n\\n summary:\"\n\nkeywords = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=prompt_keywords,\n  temperature = 0.5,\n  max_tokens  = 50)\n\nkeywords['choices'][0]['text']\n\n상기 논문 초록을 50개 토큰으로 요약하면 다음과 같이 48개 토큰, 277 문자수로 요약해준다.\n'\\n\\nThe Transformer is a new neural network architecture based solely on attention mechanisms, which is shown to outperform existing models on two machine translation tasks. It is more parallelizable and requires significantly less time to train than existing models, achieving a B'"
  },
  {
    "objectID": "01_openAI.html#여론조사-할일-생성",
    "href": "01_openAI.html#여론조사-할일-생성",
    "title": "2  OpenAI 들어가며",
    "section": "2.4 여론조사 할일 생성",
    "text": "2.4 여론조사 할일 생성\nTO-DO 리스트를 제작하는 것은 해당 작업을 절차적으로 구분지어 수행할 수 있게 되어 해당 작업의 성공가능성을 높이고 생산성도 높일 수 있다. 여론조사를 한사람이 수행하는 경우는 거의 없지만 일반적으로 여론조사에서 수행할 일에 대해서 지시명령어를 작성하여 결과를 살펴보자.\n\ntodo_list = openai.Completion.create(\n  model=\"text-davinci-003\",\n  prompt=\"여론조사를 위해서 해야될 일을 작성하세요\\n\\n1.\",\n  temperature=0.3,\n  max_tokens = 1000,\n  top_p = 0.1,\n  frequency_penalty=0,\n  presence_penalty=0.5,\n  stop=[\"6.\"]\n)\n\ntodo_text = todo_list['choices'][0]['text']\n\n' 여론조사 대상자를 선정하고, 여론조사 대상자의 수를 결정합니다.\\n\\n2. 여론조사 대상자들에게 여론조사 질문지를 배포합니다.\\n\\n3. 여론조사 대상자들에게 여론조사 응답을 요청합니다.\\n\\n4. 여론조사 응답을 수집하고, 분석합니다.\\n\\n5. 여론조사 결과를 보고서로 작성합니다.'\n\nlibrary(reticulate)\ncat(glue::glue(\"1. {py$todo_text}\"))\n\n작업수행결과를 가독성 좋게 정리하면 다음과 같다.\n\n여론조사 대상자를 선정하고, 여론조사 대상자의 수를 결정합니다.\n여론조사 대상자들에게 여론조사 질문지를 배포합니다.\n여론조사 대상자들에게 여론조사 응답을 요청합니다.\n여론조사 응답을 수집하고, 분석합니다.\n여론조사 결과를 보고서로 작성합니다.\n\n지금까지 OpenAI API를 사용하여 텍스트 자동생성기능을 활용하여 키워드 추출, 문서요약, 작업목록 생성과 같은 업무를 통해 가능성을 살펴봤다. 이제 데이터 과학업무 생산성의 주요한 도구인 유닉스 쉘(Unix Shell)을 챗GPT로 또 다른 데이터 과학의 세계로 나아가자.\n\n\n\n\nVaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. “Attention Is All You Need.” https://arxiv.org/abs/1706.03762."
  },
  {
    "objectID": "shell-intro.html#shell-background",
    "href": "shell-intro.html#shell-background",
    "title": "1  쉘(Shell) 소개",
    "section": "1.1 배경",
    "text": "1.1 배경\n상위 수준에서 컴퓨터는 네가지 일을 수행한다:\n\n프로그램 실행\n데이터 저장\n컴퓨터간 상호 의사소통\n사람과 상호작용\n\n마지막 작업을 뇌-컴퓨터 연결, 음성 인터페이스를 포함한 다양한 많은 방식으로 수행하고 있지만 아직은 초보적인 수준이어서, 대부분은 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)를 사용한다. 1980년대까지 이러한 기술은 보편적이지 않았지만, 기술의 뿌리는 1960년대 Doug Engelbart의 작업에 있고, “The Mother of All Demos”로 불리는 것에서 볼 수 있다.\n조금 더 멀리 거슬러 올라가면, 초기 컴퓨터와 상호작용하는 유일한 방법은 와이어로 다시 연결하는 것이다. 하지만, 중간에 1950년에서 1980년 사이 대부분의 사람들이 라인 프린터(line printer)를 사용했다. 이런 장치는 표준 키보드에 있는 문자, 숫자, 특수부호의 입력과 출력만 허용해서, 프로그래밍 언어와 인터페이스는 이러한 제약사항에서 설계됐다.\n여전히 전통적인 화면, 마우수, 터치패드, 키보드를 사용하지만 터치 인터페이스와 음성 인터페이스가 보편화되고 있다.\n이런 종류의 인터페이스를 지금 대부분의 사람들이 사용하는 그래픽 사용자 인터페이스(GUI, graphical user interface)과 구별하기 위해서 명령-라인 인터페이스(CLI, command-line interface)라고 한다. CLI의 핵심은 읽기-평가-출력(REPL,read-evaluate-print loop)이다: 사용자가 명령어를 타이핑하고 엔터(enter)/반환(return)키를 입력하면, 컴퓨터가 읽고, 실행하고, 결과를 출력한다. 그러고 나면, 사용자는 다른 명령를 타이핑하는 것을 로그 오프해서 시스템을 빠져 나갈때까지 계속한다.\nGUI는 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)로 구성되는데 배우기 쉽고, 단순 작업에 대해서는 환상적이다. “클릭”하게 되면 명령이 “내가 원하는 작업을 수행해”라고 손쉽게 컴퓨터에 통역된다. 하지만, 이런 마술은 단순한 작업을 수행하고, 정확하게 이러한 유형의 작업을 수행할 수 있는 프로그램에 불과하다.\n만약 복잡하고, 특정 목적에 부합되는 훨씬 묵직한 작업을 컴퓨터에 내리고자 한다고 해서, 난해하거나 어렵거나할 필요는 없고, 단지 명령 어휘가 필요하고 이를 사용하는데 필요한 단순한 문법만 필요로 한다.\n쉘이 이런 기능을 제공한다 - 단순한 언어로 이를 사용하는데 명령-라인 인터페이스가 필요하다. 명령라인 인터페이스의 심장은 읽기-평가-출력(REPL,read-evaluate-print loop)이다. REPL로 불리는 이유는 쉘에 명령어를 타이핑하고 Return를 치게되면 컴퓨터가 명령어를 읽어들이고 나서, 평가(혹은 실행)하고 출력결과를 화면에 뿌린다. 또 다른 명령어를 입력할 때까지 대기하는 루푸를 반복하게 되서 그렇다.\n상기 묘사가 마치 사용자가 직접 명령어를 컴퓨터에 보내고, 컴퓨터는 사용자에게 직접적으로 출력을 보내는 것처럼 들린다. 사실 중간에 명령 쉘(command shell)로 불리는 프로그램이 있다. 사용자가 타이핑하는 것은 쉘로 간다. 쉘은 무슨 명령어를 수행할지 파악해서 컴퓨터에게 수행하도록 지시한다. 쉘을 조개 껍데기(shell)로 불리는데 이유는 운영체제를 감싸서, 복잡성 일부를 숨겨서 운영체제와 더 단순하게 상호작용하게 만든다."
  },
  {
    "objectID": "shell-intro.html#shell-shell",
    "href": "shell-intro.html#shell-shell",
    "title": "1  쉘(Shell) 소개",
    "section": "1.2 쉘(Shell)",
    "text": "1.2 쉘(Shell)\n쉘(Shell)은 다른 것과 마찬가지로 프로그램이다. 조금 특별한 것은 자신이 연산을 수행하기 보다 다른 프로그램을 실행한다는 것이다. 가장 보편적인 유닉스 쉘(Unix Shell)은 Bash(Bourne Again SHell)다. Stephen Bourne이 작성한 쉘에서 나와서 그렇게 불리우고 — 프로그래머 사이에 재치로 통한다. Bash는 대부분의 유닉스 컴퓨터에 기본으로 장착되는 쉘이고, 윈도우용으로 유닉스스런 도구로 제공되는 패키지 대부분에도 적용된다.\nBash나 다른 쉘을 사용하는 것이 마우스를 사용하는 것보다 프로그래밍 작성하는 느낌이 난다. 명령어는 간략해서 (흔히 단지 2~3자리 문자다), 명령어는 자주 암호스럽고, 출력은 그래프같이 시각적인 것보다 텍스트줄로 쭉 뿌려진다. 다른 한편으로, 쉘을 사용하여 좀더 강력한 방식으로 현존하는 도구를 단지 키보드 입력값 몇개를 조합해서 대용량의 데이터를 자동적으로 처리할 수 있는 파이프라인을 구축할 수 있게 한다. 추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다. 클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다. 여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다."
  },
  {
    "objectID": "shell-intro.html#shell-looks-like",
    "href": "shell-intro.html#shell-looks-like",
    "title": "1  쉘(Shell) 소개",
    "section": "1.3 어떻게 생겼을까?",
    "text": "1.3 어떻게 생겼을까?\n전형적인 쉘 윈도우는 다음과 같다:\nbash-3.2$ \nbash-3.2$ ls -F / \nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\nbash-3.2$ \n첫번째 줄은 프롬프트(prompt)만 보여주고 있고, 쉘이 입력준비가 되었다는 것을 나타낸다. 프롬프트로 다른 텍스트를 지정할 수도 있다. 가장 중요한 것: 명령어를 타이핑할 때, 프롬프트를 타이핑하지 말고, 인식되거나 수행할 수 있는 명령어만 타이핑한다.\n예제 두번째 줄에서 타이핑한 ls -F / 부분이 전형적인 구조를 보여주고 있다: 명령어(command), 플래그(flags) (선택옵션(options) 혹은 스위치(switches)) 그리고 인자(argument). 플래그는 대쉬(-) 혹은 더블 대쉬(--)로 시작하는데 명령어의 행동에 변화를 준다.\n인자는 명령어에 작업할 대상을 일러준다(예를 들어, 파일명과 디렉토리). 종종 플래그를 매개변수(parameter)라고도 부른다. 명령어를 플래그 한개 이상, 인자도 한개 이상 사용하기도 한다: 하지만, 명령어가 항상 인자 혹은 플래그를 요구하지는 않는다.\n상기 예제의 두번째 줄에서, 명령어는 ls, 플래그는 -F, 인자는 /이 된다. 각각은 공백으로 뚜렸하게 구분된다: 만약 ls 와 -F 사이 공백을 빼먹게 되면 쉘은 ls-F 명령어를 찾게 되는데, 존재하지 않는 명령어다. 또한, 대문자도 문제가 될 수 있다: LS 명령어와 ls 명령어는 다르다.\n다음으로 명령어가 생성한 출력결과를 살펴보자. 이번 경우에 / 폴더에 위치한 파일 목록을 출력하고 있다. 금일 해당 출력결과가 무엇을 의미하는지 다룰 예정이다. 맥OS를 사용하시는 참석자분들은 이번 출력결과를 이미 인지하고 있을지도 모른다.\n마지막으로, 쉘은 프롬프트를 출력하고 다음 명령어가 타이핑되도록 대기모드로 바뀐다.\n이번 학습예제에서 프롬프트가 $이 된다. 명령어를 PS1='$ ' 타이핑하게 되면 동일하게 프롬프트를 맞출 수 있다. 하지만, 본인 취향에 맞추어 프롬프트를 둘 수도 있다 - 흔히 프롬프트에 사용자명과 디렉토리 현재 위치정보를 포함하기도 하다.\n쉘 윈도우를 열고, ls -F / 명령어를 직접 타이핑한다. (공백과 대문자가 중요함으로 잊지 말자.) 원하는 경우 프롬프트도 변경해도 좋다."
  },
  {
    "objectID": "shell-intro.html#shell-ls",
    "href": "shell-intro.html#shell-ls",
    "title": "1  쉘(Shell) 소개",
    "section": "1.4 ls 와 플래그 의미 파악",
    "text": "1.4 ls 와 플래그 의미 파악\n모든 쉘 명령어는 컴퓨터 어딘가에 저장된 프로그램으로, 쉘은 명령어를 검색해서 찾을 장소를 목록으로 이미 가지고 있다. (명령목록은 PATH로 불리는 변수(variable)에 기록되어 있지만, 이 개념을 나중에 다룰 것이라 현재로서는 그다지 중요하지는 않다.) 명령어, 플래그, 인자가 공백으로 구분된다는 점을 다시 상기하자.\nREPL(읽기-평가-출력(read-evaluate-print) 루프)를 좀더 살펴보자. “평가(evaluate)” 단계는 두가지 부분으로 구성됨에 주목한다:\n\n타이핑한 것을 읽어들인다(이번 예제에서 ls -F /) 쉘은 공백을 사용해서 명령어로 입력된 것을 명령어, 플래그, 인자로 쪼갠다.\n평가(Evaluate):\n\nls 라는 프로그램을 찾는다.\n\n찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.\n\n프로그램 실행 결과를 출력한다.\n\n그리고 나서, 프롬프트를 출력하고 또다른 명령어를 입력받도록 대기한다.\n\n\n\n\n\n\nCommand not found 오류\n\n\n\n쉘이 타이핑한 명령어 이름을 갖는 프로그램을 찾을 수 없는 경우, 다음과 같은 오류 메시지가 출력된다:\n$ ls-F\n-bash: ls-F: command not found\n일반적으로 명령어를 잘못 타이핑했다는 의미가 된다 - 이 경우, ls 와 -F 사이 공백을 빼먹어서 그렇다. 즉, ls -F와 같이 명령을 전달하면 의도한 바가 기계에 정확히 전달된다."
  },
  {
    "objectID": "shell-intro.html#shell-difficulty",
    "href": "shell-intro.html#shell-difficulty",
    "title": "1  쉘(Shell) 소개",
    "section": "1.5 어려운가요?",
    "text": "1.5 어려운가요?\nGUI와 비교하여 컴퓨터와 상호작용하는데 있어 어려운 모형이고 학습하는데 노력과 시간이 다소 소요된다. GUI는 선택지를 보여주고, 사용자가 선택지중에서 선택하는 하는 것이다. 명령라인 인터페이스(CLI)로 선택지가 명령어와 패러미터의 조합으로 표현된다. 사용자에게 제시되는 것이 아니라서 새로운 언어의 어휘를 학습하듯이 일부 학습이 필요하다. 명령어의 일부만 배우게 되면 정말 도움이 많이 되고, 핵심적인 명령어를 다뤄보자."
  },
  {
    "objectID": "shell-intro.html#shell-flexibility",
    "href": "shell-intro.html#shell-flexibility",
    "title": "1  쉘(Shell) 소개",
    "section": "1.6 유연성과 자동화",
    "text": "1.6 유연성과 자동화\n쉘문법(Grammar of Shell)은 기존 도구를 조합해서 강력한 파이프라인을 구축하도록 해서 방대한 데이터를 자동화하여 다룰 수 있다. 명령 순서는 스크립트(script)로 작성하여 작업흐름의 재현가능성을 향상시켜서 쉽게 반복이 가능하도록 한다.\n추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다. 클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다. 여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다."
  },
  {
    "objectID": "shell-intro.html#shell-nelle",
    "href": "shell-intro.html#shell-nelle",
    "title": "1  쉘(Shell) 소개",
    "section": "1.7 사례: 문제정의",
    "text": "1.7 사례: 문제정의\n해양 생물학자 넬 니모(Nell Nemo) 박사가 방금전 6개월간 북태평양 소용돌이꼴 조사를 마치고 방금 귀환했다. 태평양 거대 쓰레기 지대에서 젤리같은 해양생물을 표본주출했다. 총 합쳐서 1,520개 시료가 있고 다음 작업이 필요하다:\n\n서로 다른 300개 단백질의 상대적인 함유량을 측정하는 분석기계로 시료를 시험한다. 한 시료에 대한 컴퓨터 출력결과는 각 단백질에 대해 한 줄 파일형식으로 표현된다.\ngoostat으로 명명된 그녀의 지도교수가 작성한 프로그램을 사용하여 각 단백질에 대한 통계량을 계산한다.\n다른 대학원 학생중 한명이 작성한 goodiff로 명명된 프로그램을 사용해서, 각 단백질에 대한 통계량과 다른 단백질에 대해 상응하는 통계량을 비교한다.\n결과를 작성한다. 그녀의 지도교수는 이달 말까지 이 작업을 정말로 마무리해서, 논문이 다음번 Aquatic Goo Letters 저널 특별판에 게재되기를 희망한다.\n\n각 시료를 분석장비가 처리하는데 약 반시간 정도 소요된다. 좋은 소식은 각 시료를 준비하는데는 단지 2분만 소요된다. 연구실에 병렬로 사용할 수 있는 분석장비 8대가 있어서, 이 단계는 약 2주정도만 소요될 것이다.\n나쁜 소식은 goostat, goodiff를 수작업으로 실행한다면, 파일이름 입력하고 “OK” 버튼을 45,150번 눌려야 된다는 사실이다 (goostat 300회 더하기 goodiff \\(\\frac{300 \\times 299}{2}\\)). 매번 30초씩 가정하면 2주 이상 소요될 것이다. 논문 마감일을 놓칠 수도 있지만, 이 모든 명령어를 올바르게 입력할 가능성은 거의 0 에 가깝다.\n다음 수업 몇개는 대신에 그녀가 무엇을 해야되는지 탐색한다. 좀더 구체적으로, 처리하는 파이프라인 중간에 반복되는 작업을 자동화하는데 쉘 명령어(command shell)를 어떻게 사용하는지 설명해서, 논문을 쓰는 동안에 컴퓨터가 하루에 24시간 작업한다. 덤으로 중간 처리작업 파이프라인을 완성하면, 더 많은 데이터를 얻을 때마다 다시 재사용할 수 있게 된다."
  },
  {
    "objectID": "shell-intro.html#쉘-gpt",
    "href": "shell-intro.html#쉘-gpt",
    "title": "1  쉘(Shell) 소개",
    "section": "1.8 쉘 GPT",
    "text": "1.8 쉘 GPT\nOpenAI의 ChatGPT(GPT-3.5)는 콘텐츠 생성에 주된 방점이 있지만 다양한 프로그래밍 코드도 작성함은 물론 유닉스 쉘 프로그램도 작성하여 CLI 생산성을 높이는데 사용될 수 있다. ChatGPT 기능을 활용하여 쉘 명령, 코드 스니펫, 주석, 문서 등을 생성할 수 있다. 즉, 데이터 과학자를 비롯한 개발자가 기존에 업무를 수행하던 방식이 전혀 다르게 된다. 즉, 책, 매뉴얼, 비밀노트(Cheat Sheet), 인터넷 북마크, 구글링 같은 검색없이 바로 터미널에서 바로 정확한 답변을 얻어 귀중한 시간과 노력을 절약할 수 있다.\n예를 들어 앞서 프로젝트를 할 때 해당 유닉스 쉘 명령어가 기억나지 않는다고 하면 shell gpt를 사용하여 해당 작업을 신속하게 수행할 수 있다. shell_gpt는 파이썬 패키지라 다음 파이썬 명령어로 패키지 설치를 할 수 있다.\npip install shell-gpt\n사용방법은 Git Bash를 설치한 후 터미널을 열구 sgpt --shell 다음에 자연어를 넣게 되면 해당되는 쉘 명령어를 알려준다. 이를 실행하게 되면 유닉스 쉘을 이용하여 해당 자동화 작업에 생산성을 높일 수 있다. 현재는 한국어는 지원하지 않아 한글로 작성한 다음 번역기를 사용하여 영어로 입력해야 하고 결과를 얻게 되면 이를 실행하는 방식으로 활용한다.\n\n$ sgpt --shell 'List the contents of the current directory and display a special character at the end of each filename to indicate its file type.'\n\n\nls -F\n\n00_setup.qmd*\n01_openAI.qmd*\nLICENSE*\n_quarto.yml*\ncode/\ncover.png*\ndocs/\ngpt-shell.Rproj*\nimages/\nindex.qmd*\nreferences.bib*\nreferences.qmd*\nshell-create.Rmd*\nshell-filedir.qmd*\nshell-find.Rmd*\nshell-intro.qmd*\nshell-intro.rmarkdown*\nshell-intro_files/\nshell-loop.Rmd*\nshell-novice/\nshell-pipefilter.Rmd*\nshell-script.Rmd*"
  },
  {
    "objectID": "shell-filedir.html#shell-help",
    "href": "shell-filedir.html#shell-help",
    "title": "1  파일과 폴더 넘나들기",
    "section": "1.1 도움말 얻기",
    "text": "1.1 도움말 얻기\nls 명령어에 딸린 플래그가 많다. 일반적으로 명령어와 수반되는 플래그 사용법을 파악하는 방식이 두개 있다:\n\n--help 플래그를 명령어에 다음과 같이 전달하는 방법:\n\n$ ls --help\n\nman 명령어로 다음과 같이 매뉴얼을 읽는 방법:\n\n$ man ls \n본인 컴퓨터 환경에 따라 상기 방법 중 하나만 동작(man 혹은 --help)할 수도 있다. 아래에서 두가지 방법 모두 살펴보자.\n\n1.1.1 --help 플래그\n배쉬 내부에서 동작하도록 작성된 배쉬 명령어와 프로그램은 --help 플래그를 지원해서 명령어 혹은 프로그램을 사용하는 방식에 대한 더 많은 정보를 볼 수 있게 해 준다.\n$ ls --help\n\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n\n... 중략\n\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any security context of each file\n  -1                         list one file per line.  Avoid '\\n' with -q or -b\n      --help     display this help and exit\n      --version  output version information and exit\n\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\nUnits are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n\nUsing color to distinguish file types is disabled both by default and\nwith --color=never.  With --color=auto, ls emits color codes only when\nstandard output is connected to a terminal.  The LS_COLORS environment\nvariable can change the settings.  Use the dircolors command to set it.\n\nExit status:\n 0  if OK,\n 1  if minor problems (e.g., cannot access subdirectory),\n 2  if serious trouble (e.g., cannot access command-line argument).\n\nGNU coreutils online help: <http://www.gnu.org/software/coreutils/>\nFull documentation at: <http://www.gnu.org/software/coreutils/ls>\nor available locally via: info '(coreutils) ls invocation'\n\n지원되지 않는 명령-라인 선택옵션\n지원되지 않는 선택옵션(플래그)를 사용하게 되면, ls를 비롯한 다른 프로그램은 다음과 같은 오류 메시지를 일반적으로 출력하게 된다:\n$ ls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\n1.1.2 man 명령어\nls에 대해 배울 수 있는 다른 방식은 다음 명령어를 타이핑하는 것이다.\n$ man ls\n상기 명령어를 실행하게 되면 ls 명령어와 선택 옵션에 대해 기술된 페이지로 탈바꿈하게 된다. 만약 운이 좋은 경우 상용법에 대한 예제도 포함되어 있다.\nman 페이지를 살펴보는 방법은 행단위로 이동하는데 ↑, ↓을 사용하거나 전체 페이지 단위로 건너뛰거나 아래 페이지로 이동할 경우 B, Spacebar을 사용한다. man 페이지에서 단어나 문자를 찾는 경우 / 다음에 검색할 문자 혹은 단어를 타이핑하면 된다.\nman 페이지에서 빠져 나오고자 종료(quit)하고자 한다면 Q을 누른다.\n\n웹상의 매뉴얼 페이지\n물론 명령어에 대한 도움말에 접근하는 세번째 방식이 있다: 웹브라우저를 통해서 인터넷을 검색하는 것이다. 인터넷 검색을 이용할 때, 검색쿼리에 unix man page 문구를 포함할 경우 연관된 정보를 찾는데 도움이 될 수 있다.\nGNU도 GNU 핵심 유틸리티(core GNU utilities)이 포함된 매뉴얼을 제공하고 있는데 이번 학습에 소개된 많은 명령어를 망라하고 있다.\n\n\n더많은 ls 플래그 탐색\n-l, -h 플래그를 붙여 ls 명령어를 수행하게 되면 출력결과는 어떻게 나올까?\n출력결과의 일부는 이번 학습에서 다루지 않는 속성(property)에 대한 것으로 파일 권한과 파일 소유에 대한 것이다. 그럼에도 불구하고 나머지는 유용할 것이다.\n\nls와 사용되는 -l 플래그는 long을 축약한 것으로 파일/디렉토리 명칭 뿐만 아니라 파일 크기, 최종 변경 시간 같은 부가정보가 출력된다. -h 플래그는 “human readable” 사람이 읽기 편한 형태로 파일크기를 지정한다. 예를 들어, 5369 대신에 5.3K이 화면에 출력된다.\n\n\n\n재귀적으로 시간순으로 목록 출력\nls -R 명령어는 디렉토리에 담긴 내용을 재귀적으로 화면에 출력한다; 즉, 각 단계별로 하위 디렉토리, 하위-하위 디렉토리 내용을 확면에 출력한다. ls -t 명령어는 마지막 변경된 시점순으로 가장 최근에 변경된 파일 혹은 디렉토리를 화면에 정렬해서 출력한다. ls -R -t 명령어는 어떤 순서로 화면엘 출력할까?\n힌트: ls -l 명령어를 사용해서 시간도장(timestamp)을 볼 수 있도록 전체 목록을 화면에 출력한다.\n\n각 디렉토리의 파일/디렉토리가 가장 마지막 시간 변경순으로 정렬되어 출력된다.\n\n\n여기서 홈 디렉토리가 하위 디렉토리(sub-directories)가 포함된것을 알 수 있다. 슬래쉬(/)가 붙지 않는 명칭을 갖는 것은 것은 평범한 파일(file)이다. ls 와 -F 사이에 공백이 있는 것에 주목한다: 공백이 없다면 쉘은 존재하지 않는 ls-F 명령어를 실행시키려 한다고 간주한다.\nls 명령어를 사용해서 다른 디렉토리에 들어 있는 파일과 디렉토리를 살펴볼 수 있다. ls -F Desktop 명령어를 실행해서 바탕화면 Desktop 디렉토리에 담긴 것을 살펴보자. 즉, ls 명령어는 -F 플래그, 그리고 인자(argument) Desktop으로 구성된다. Desktop 인자는 ls로 하여금 현재 작업 디렉토리가 아닌 바탕화면 디렉토리 내용을 출력하도록 지정하는 역할을 수행한다:\n$ ls -F Desktop\ndata-shell/\n작업한 출력결과는 웹사이트에서 다운로드 받아 압축을 풀어 작업하여 생성한 data-shell 디렉토리와 본인 바탕화면에 저장된 모든 파일과 하위디렉토리가 출력되어야 한다."
  },
  {
    "objectID": "shell-filedir.html#shell-cd-change",
    "href": "shell-filedir.html#shell-cd-change",
    "title": "1  파일과 폴더 넘나들기",
    "section": "1.2 cd 디렉토리 변경",
    "text": "1.2 cd 디렉토리 변경\n지금 확인했듯이, 배쉬 쉘은 파일을 계층적 파일 시스템으로 구성한다는 아이디어에 강력히 의존하고 있다. 이런 방식으로 계층적으로 파일과 디렉토리를 구조화하게 되면 본인 작업을 추적하는데 도움이 된다: 책상위에 출력한 논문 수백개를 쌓아놓은 것는 것이 가능하듯이, 홈 디렉토리에 파일 수백개를 저장하는 것도 가능하다. 하지만, 이런 접근법은 자멸하는 전략이나 마찬가지다.\ndata-shell 디렉토리가 바탕화면(Desktop)에 위치하는 것을 확인했으니, 다음 두가지를 수행할 수 있다.\n먼저, data-shell 디렉토리에 담긴 것을 살펴보자; 디렉토리 이름에 ls를 전달해서 앞서 확인된 동일한 전략을 사용하자:\n$ ls -F Desktop/data-shell\ncreatures/          molecules/          notes.txt           solar.pdf\ndata/               north-pacific-gyre/ pizza.cfg           writing/\n둘째로, 다른 디렉토리로 위치를 실제로 바꿀 수 있다. 그렇게 하면 더이상 홈 디렉토리에 있지는 않게 된다.\n작업 디렉토리를 변경하기 위해서 cd 다음에 디렉토리 이름을 사용한다. cd는 “change directory”의 두문어다. 하지만 약간 오해의 소지가 있다: 명령어 자체가 디렉토리를 변경하지는 않고, 단지 사용자가 어느 디렉토리에 있는지에 대한 쉘의 생각만 바꾼다.\n앞서 확인한 data 디렉토리로 이동해 보자. 다음 명령어를 쭉 이어서 실행하게 되면 목적지에 도달할 수 있다:\n$ cd Desktop\n$ cd data-shell\n$ cd data\n상기 명령어는 홈 디렉토리에 바탕화면(Desktop) 디렉토리로 이동하고 나서, data-shell 디렉토리로 이동하고 나서, data 디렉토리에 이동하게 된다. cd 명령어는 아무것도 출력하지는 않지만, pwd 명령어를 실행하게 되면 /Users/nelle/Desktop/data-shell/data 위치한 것을 확인하게 된다. 인자 없이 ls 명령어를 실행하게 되면, /Users/nelle/Desktop/data-shell/data 디렉토리 파일과 디렉토리를 출력하게 되는데 이유는 지금 있는 위치이기 때문이다:\n$ pwd\n/Users/nelle/Desktop/data-shell/data\n$ ls -F\namino-acids.txt   elements/     pdb/            salmon.txt\nanimals.txt       morse.txt     planets.txt     sunspot.txt\n이제 디렉토리 나무를 타서 아래로 내려가는 방법을 익혔다. 하지만 어떻게 하면 위로 올라갈 수 있을까? 다음 명령어를 시도해보자:\n$ cd data-shell\n-bash: cd: data-shell: No such file or directory\n하지만, 오류 발생! 이유가 뭘까?\n지금까지 방법으로 cd 명령어는 현재 디렉토리 내부에 하위 디렉토리만 볼 수 있다. 현재 디렉토리에서 상위 디렉토리를 볼 수 있는 다른 방법이 있다; 가장 단순한 것부터 시작해보자.\n쉘에서 한단계 위 디렉토리로 이동할 수 있는 단축키가 존재하는데 다음과 같이 생겼다:\n$ cd ..\n..은 특별한 디렉토리명인데 “현재 디렉토리를 포함하는 디렉토리”, 좀더 간결하게 표현하면 현재 디렉토리의 부모를 의미한다. 물론, cd .. 명령어를 실행하고 나서 pwd을 실행하게 되면 /Users/nelle/Desktop/data-shell로 되돌아 간다:\n$ pwd\n/Users/nelle/Desktop/data-shell\n단순히 ls 명령어를 실행하게 되면 특수 디렉토리 ..이 화면에 출력되지는 않는다. .. 디렉토리를 출력하려면 ls 명령어와 -a 플래그를 사용한다:\n$ ls -F -a\n./   .bash_profile  data/       north-pacific-gyre/  pizza.cfg  thesis/\n../  creatures/     molecules/  notes.txt            solar.pdf  writing/\n-a은 “show all”의 축약으로 모두 보여주기를 의미한다; ls로 하여금 ..와 같은 .로 시작하는 파일과 디렉토리명도 화면에 출력하게 강제한다. (/Users/nelle 디렉토리에 위치한다면, /Users 디렉토리를 지칭) .도 또다른 특별한 디렉토리로, “현재 작업 디렉토리(current working directory)”를 의미한다. 중복되어 불필요해 보일 수 있지만, 곧 .에 대한 사용법을 학습할 것이다.\n대부분의 명령라인 도구에서 플래그 다수룰 조합해서 플래그 사이 공백없이 단일 -로 사용함에 주목한다: ls -F -a은 ls -Fa와 동일하다.\n\n다른 숨은 파일들\n숨은 .., . 디렉토리에 더해서, .bash_profile 파일도 봤을 것이다. .bash_profile 파일에는 쉘 환경설정 정보가 담겨져 있다. .으로 시작하는 다른 파일과 디렉토리를 봤을 수도 있다. 이런 파일은 본인 컴퓨터의 다른 프로그램에서 환경설정을 하기 위해서 사용되는 파일과 디렉토리라고 보면 된다. . 접두어를 사용해서 ls 명령어를 사용할 때 이러한 환경설정 파일들이 터미널을 난잡하게 만드는 것을 방지하는 기능을 수행한다.\n\n\n직교(Orthogonality)\n특수 이름 .과 ..는 ls에만 속하는 것이 아니고; 모든 프로그램에서 같은 방식으로 해석된다. 예를 들어, /Users/nelle/data 디렉토리에 있을 때, ls .. 명령어는 /Users/nelle의 목록을 보여줄 것이다. 어떻게 조합되든 상관없이 동일한 의미를 가지게 될 때, 프로그래머는 이를 직교(orthogonal)한다고 부른다. 직교 시스템은 사람들이 훨씬 배우기 쉬운데, 이유는 기억하고 추적할 특수 사례와 예외가 더 적기 때문이다."
  },
  {
    "objectID": "shell-filedir.html#shell-path-absolute",
    "href": "shell-filedir.html#shell-path-absolute",
    "title": "1  파일과 폴더 넘나들기",
    "section": "1.3 상대/절대 경로",
    "text": "1.3 상대/절대 경로\n컴퓨터에 파일시스템을 돌아다니는데 기본 명령어는 pwd, ls, cd을 들 수 있다. 지금까지 사용했던 했던 방식을 벗어난 사례를 살펴보자. 프롬프트에서 cd 명령어를 디렉토리를 특정하지 않고 실행시키면 어떻게 될까?\n$ cd\n상기 명령어 실행 결과를 어떻게 확인할 수 있을까? pwd 명령어가 정답을 제시한다!\n$ pwd\n/Users/nelle\n어떤 플래그도 없는 cd 명령어는 홈디렉토리로 이동시킨다. 파일시스템에서 방향을 잃었을 경우 큰 도움이 된다.\ndata 디렉토리로 되돌아가자. 앞서 명령어 세개를 동원했지만 한방에 해당 디렉토리를 명세해서 바로 이동할 수 있다.\n$ cd Desktop/data-shell/data\npwd 와 ls -F 명령어를 실행해서 올바른 자리로 돌아왔는지 확인하자. data 디렉토리에서 한단계 위로 올라가려고 하면 cd .. 명령어를 사용했다. 현재 디렉토리 위치에 관계없이 특정 디렉토리로 이동할 수 있는 다른 방식도 있다.\n지금까지 디렉토리명을 명세할 때 상대경로(relative paths)를 사용했다. ls 혹은 cd와 같은 명령어와 상대 경로를 사용할 때는 시스템이 파일시스템의 루트 위치(/)에서 차근차근 찾기보다 해당 위치를 현재 위치를 찾아 명령을 실행시킨다.\n하지만, / 슬래쉬로 표현되는 루트 디렉토리에서 전체 경로를 추가한 절대경로(absolute path)로 명세하는 것도 가능하다. / 슬래쉬는 컴퓨터가 루트 디렉토리에서 경로를 탐색하도록 지시한다. 따라서, 명령어를 실행할 때 현재 디렉토리 위치에 관계없이 정확한 특정 디렉토리를 항상 명세하게 된다.\n절대경로를 사용하면 파일 시스템에 어느 위치에서든 있던 관계없이 data-shell 디렉토리로 이동할 수 있다. 절대경로를 찾기 쉬운 방법은 pwd 명령어를 사용해서 필요한 디렉토리 정보를 추출하고 이를 활용해서 data-shell 디렉토리로 이동한다.\n$ pwd\n/Users/nelle/Desktop/data-shell/data\n$ cd /Users/nelle/Desktop/data-shell\npwd와 ls -F 명령어를 실행하게 되면 원하던 디렉토로리 제대로 이동되었는지 확인이 가능하다.\n\n단축(Shortcuts) 두개 더\n쉘을 ~ (틸드) 문자를 경로의 시작으로 해석해서 “현재 사용자 홈 디렉토리”를 의미하게 된다. 예를 들어, Nelle의 홈 디렉토리가 /Users/nelle이라면, ~/data은 /Users/nelle/data와 동치가 된다. 경로명에 첫 문자로 있을 때만 이것이 동작한다: here/there/~/elsewhere이 here/there/Users/nelle/elsewhere이 되는 것은 아니다. 따라서, cd ~을 홈 디렉토리로 변경하는데 사용한다.\n또 다룩 단축은 대쉬(-) 문자다. cd는 - 문자를 지금 있는 이전 디렉토리로 변역한다. 이 방법이 전체 경로를 기억하고 있다가 타이핑하는 것보다 더 빠르다. 이를 통해 디렉토리를 앞뒤로 매우 효율적으로 이동하게 된다. cd .. 와 cd - 명령어 사이 차이점은 전자(cd ..)는 위로, 후자(cd -)는 아래로 이동하게 위치를 바꾸는 역할을 수행한다. TV 리모컨의 이전 채널 기능으로 생각하면 편하다.\n\n\n동일 작업을 수행하는 수많은 방법 - 절대 경로 vs. 상대 경로\n/home/amanda/data/ 디렉토리에서 시작할 때, Amanda가 홈디렉토리인 /home/amanda로 돌아가도록 사용할 수 있는 명령어를 아래에서 선택하시요.\n\ncd .\ncd /\ncd /home/amanda\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n해답 풀이 1. No: .은 현재 디렉토리를 나타냄. 2. No: /는 루트 디렉토리를 나타냄. 3. No: Amanda 홈 디렉토리른 /Users/amanda임. 4. No: ../..은 두 단계 거슬러 올라간다; 즉, /Users에 도달함. 5. Yes: ~은 사용자 홈 디렉토리를 나타남; 이 경우 /Users/amanda이 됨. 6. No: 현재 디렉토리 내부에 home 디렉토리가 존재하는 경우 home 디렉토리로 이동하게 됨. 7. Yes: 불필요하게 복잡하지만, 정답이 맞음. 8. Yes: 사용자 홈 디렉토리로 이동할 수 있는 단축키를 사용함. 9. Yes: 한 단계 위로 이동.\n\n\n\n상대경로 해결\n만약 pwd 명령어를 쳤을 때, 화면에 /Users/thing이 출력된다면, ls -F ../backup은 무엇을 출력할까요?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n도전과제 질문 파일 시스템\n\n\n\n해답 풀이\n\nNo: backup in /Users 디렉토리 내부에 backup 디렉토리가 있다. \nNo: Users/thing/backup 디렉토리에 담긴 것을 출력한다. 하지만 ..으로 한 단계 상위 레벨 위를 찾도록 요청했다.\nNo: 이전 해답을 참조한다.\nYes: ../backup/ 은 /Users/backup/을 지칭한다.\n\n\n\n\nls 독해 능력\n상기 그림(도전과제 질문에 사용되는 파일 시스템)에 나온 디렉토리 구조를 상정한다. 만약 pwd 명령어를 쳤을 때 화면에 /Users/backup이 출력되고, -r 인자는 ls 명령어가 역순으로 화면에 출력하게 한다면, 어떤 명령어가 다음을 화면에 출력할까요?\npnas_sub/ pnas_final/ original/\n1.  `ls pwd`\n2.  `ls -r -F`\n3.  `ls -r -F /Users/backup`\n4.  위 #2 혹은 #3, 하지만, #1은 아님.\n\n해답풀이 1. No: pwd 는 디렉토리 명칭이 아님. 2. Yes: 디렉토리 인자가 없는 ls 명령어는 현재 디렉토리의 파일과 디렉토리를 화면에 출력함. 3. Yes: 절대 경로를 명시적으로 사용. 4. Correct: 상기 해설 참조."
  },
  {
    "objectID": "shell-filedir.html#nelle-filedir",
    "href": "shell-filedir.html#nelle-filedir",
    "title": "1  파일과 폴더 넘나들기",
    "section": "1.4 사례: 파일 구성",
    "text": "1.4 사례: 파일 구성\n파일과 디렉토리에 대해서 알았으니, Nelle은 단백질 분석기가 생성하는 파일을 구성할 준비를 마쳤다. 우선 north-pacific-gyre 디렉토리를 생성해서 데이터가 어디에서 왔는지를 상기하도록 한다. 2012-07-03 디렉토리를 생성해서 시료 처리를 시작한 날짜를 명기했다. Nelle은 conference-paper와 revised-results같은 이름을 사용하곤 했다. 하지만, 몇년이 지난 후에 이해하기 어렵다는 것을 발견했다. (마지막 지푸라기는 revised-revised-results-3 디렉토리를 본인이 생성했다는 것을 발견했을 때였다.)\n\n출력결과 정렬\nNelle은 월과 일에 0을 앞에 붙여 디렉토리를 “년-월-일(year-month-day)” 방식으로 이름지었다. 왜냐하면 쉘이 알파벳 순으로 파일과 디렉토리 이름을 화면에 출력하기 때문이다. 만약 월이름을 사용한다면, 12월(December)이 7월(July) 앞에 위치할 것이다: 만약 앞에 0을 붙이지 않으면 11월이 7월 앞에 올 것이다.\n\n각각의 물리적 시료는 “NENE01729A”처럼 10자리 중복되지 않는 ID로 연구실 관례에 따라 표식을 붙였다. 시료의 장소, 시간, 깊이, 그리고 다른 특징을 기록하기 위해서 수집 기록에 사용된 것과 동일하다. 그래서 이를 각 파일 이름으로 사용하기로 결정했다. 분석기 출력값이 텍스트 형식이기 때문에 NENE01729A.txt, NENE01812A.txt, … 같이 확장자를 붙였다. 총 1,520개 파일 모두 동일한 디렉토리에 저장되었다.\n이제 data-shell 현재 작업 디렉토리에서 Nelle은 다음 명령어를 사용해서, 무슨 파일이 있는지 확인할 수 있다:\n$ ls north-pacific-gyre/2012-07-03/\n엄청나게 많은 타이핑이지만 탭 자동완성(tab completion)을 통해 쉘에게 많은 일을 시킬 수도 있다. 만약 다음과 같이 타이핑하고:\n$ ls nor\n그리고 나서 탭(키보드에 탭 키)을 누르면, 자동으로 쉘이 디렉토리 이름을 자동완성 시켜준다:\n$ ls north-pacific-gyre/\n탭을 다시 누르면, Bash가 명령문에 2012-07-03/을 추가하는데, 왜냐하면 유일하게 가능한 자동완성조건이기 때문이다. 한번더 탭을 누려면 아무것도 수행하지 않는다. 왜냐하면 1520가지 경우의 수가 있기 때문이다; 탭을 두번 누르면 모든 파일 목록을 가져온다. 이것을 탭 자동완성(tab completion)이라고 부르고, 앞으로도 다른 많은 툴에서도 많이 볼 것이다."
  },
  {
    "objectID": "shell-filedir.html#쉘-명령-일반구문",
    "href": "shell-filedir.html#쉘-명령-일반구문",
    "title": "1  파일과 폴더 넘나들기",
    "section": "1.5 쉘 명령 일반구문",
    "text": "1.5 쉘 명령 일반구문\n지금까지 명령어, 선택옵션 및 명령인자를 살펴보았지만 몇 가지 용어를 공식화하는 것이 필요하다. 아래 쉘 명령어를 일반적인 쉘 명령어 사례로 간주하고 구성요소별로 분해하면 다음과 같다:\n\nls -F /\n\n\n\n\n\n\n상기 쉘 명령어는 ls 명령어, 선택옵션 -F, 명령인자 /로 구성되어 있다. 이미 대시(-) 하나 또는 대시 두개(--)가 명령의 동작을 변경한다. 명령인자는 명령에 작업할 대상(예: 파일 및 디렉터리)을 지정해준다. 선택옵션과 명령인자를 매개변수라고 부른다. 쉘 명령은 둘 이상의 선택옵션과 둘 이상의 명령인자를 사용하여 실행할 수도 있지만, 쉘 명령어 작성에 항상 선택옵션과 명령인자가 필요한 것은 아니다.\n선택옵션을 스위치(switches) 또는 플래그(flag)라고 부르는 경우도 있다. 특히 명령인자가 없는 선택옵션을 스위치나 플래그로 부르지만, 선택옵션이라는 용어를 통일해서 사용한다.\n쉘 명령어 각 부분은 공백으로 구분된다. ls와 -F 사이에 공백을 생략하는 경우 공백을 생략하면 쉘은 ls-F라는 명령을 찾지만 이런 명령어는 존재하지 않는다. 쉘 명령어에서 대소문자 구분도 중요하다. 예를 들어 ls -s는 파일 및 디렉터리의 크기를 이름과 함께 표시하지반, ls -S는 아래와 같이 파일과 디렉터리를 크기별로 정렬한다:\n\ncd shell-lesson-data\nls -s exercise-data\n\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 proteins   4 writing\nls -s가 반환하는 크기는 블록 단위로 운영 체제마다 다르게 정의되어 있으므로 예제와 동일한 수치를 얻지 못할 수도 있다. 참고로 윈도우 10 운영체제에서 작성되었다.\nls -S는 파일과 디렉토리를 크기별로 정렬한다.\n\nls -S exercise-data\n\nanimal-counts  creatures  proteins  writing  numbers.txt\n이 모든 것을 종합하면 위의 ls -F / 명령은 루트 디렉터리 /에 있는 파일 및 디렉터리 목록을 출력한다. 참고로 윈도우 10 환경에 WSL 우분투 리눅스를 환경 사례다. 사용자의 운영체제에 따라 달리 나올 수도 있다.\n\nls -F /\n\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/"
  },
  {
    "objectID": "shell-create.html#파일과-디렉토리를-위한-좋은-명칭",
    "href": "shell-create.html#파일과-디렉토리를-위한-좋은-명칭",
    "title": "1  파일과 디렉토리 작업",
    "section": "1.1 파일과 디렉토리를 위한 좋은 명칭",
    "text": "1.1 파일과 디렉토리를 위한 좋은 명칭\n명령라인으로 작업할 때, 복잡하고 어려운 파일과 디렉토리는 삶을 질을 현격히 저하시킨다. 다음에 파일 명칭에 대한 유용한 팁이 몇개 있다.\n\n공백(whitespaces)을 사용하지 마라 공백은 이름을 의미있게 할 수도 있지만, 공백이 명령라인 인터페이스에서 인자를 구별하는데 사용되기에, 파일과 디렉토리 명에서는 피하는 것이 상책이다. 공백 대신에 - 혹은 _ 문자를 사용한다.\n대쉬(-)로 명칭을 시작하지 않는다. 명령어가 -으로 시작되는 명칭을 선택옵션으로 처리하기 때문이다.\n명칭에 문자, 숫자, . (마침표), - (대쉬) and _ (밑줄)을 고수한다. 명령라인 인터페이스에서 다른 많은 문자는 특별한 의미를 갖는다. 학습을 진행하면서 이들 중 일부를 배울 것이다. 일부 특수 문자는 명령어가 기대했던 대로 동작하지 못하게 하거나, 심한 경우 데이터 유실을 야기할 수도 있다.\n\n공백을 포함하거나 알파벳이 아닌 문자를 갖는 파일명이나 디렉토리명을 굳이 지정할 필요가 있다면, 인용부호(\"\")로 파일명이나 디렉토리명을 감싸야 한다."
  },
  {
    "objectID": "shell-create.html#shell-move-file",
    "href": "shell-create.html#shell-move-file",
    "title": "1  파일과 디렉토리 작업",
    "section": "1.2 파일과 폴더 이동",
    "text": "1.2 파일과 폴더 이동\ndraft.txt가 특별한 정보를 제공하는 이름이 아니어서 mv를 사용하여 파일 이름을 변경하자. mv는 “move”의 줄임말이다:\n$ mv thesis/draft.txt thesis/quotes.txt\n첫번째 매개변수는 mv 명령어에게 이동하려는 대상을, 두번째 매개변수는 어디로 이동되는지를 나타낸다. 이번 경우에는 thesis/draft.txt 파일을 thesis/quotes.txt으로 이동한다. 이렇게 파일을 이동하는 것이 파일 이름을 바꾸는 것과 동일한 효과를 가진다. 아니나 다를까, ls 명령어를 사용하여 확인하면 thesis 디렉토리에는 이제 quotes.txt 파일만 있음을 확인할 수 있다:\n$ ls thesis\nquotes.txt\n목표 파일명을 명세할 때 주의를 기울일 필요가 있다. 왜냐하면, mv 명령어는 동일 명칭을 갖는 어떤 기존 파일도 아주 조용히 덮어 써버리는 재주가 있어 데이터 유실에 이르게 된다. 부가적인 옵션 플래그, mv -i (즉 mv --interactive)를 사용해서 덮어쓰기 전에 사용자가 확인하도록 mv 명령어를 활용할 수도 있다.\n일관성을 갖고 있어서, mv는 디렉토리에도 동작한다 — 별도 mvdir 명령어는 없다.\nquotes.txt 파일을 현재 작업 디렉토리로 이동합시다. mv를 다시 사용한다. 하지만 이번에는 두번째 매개변수로 디렉토리 이름을 사용해서 파일이름을 바꾸지 않고, 새로운 장소에 놓는다. (이것이 왜 명령어가 “move(이동)”으로 불리는 이유다.) 이번 경우에 사용되는 디렉토리 이름은 앞에서 언급한 특수 디렉토리 이름 . 이다.\n$ mv thesis/quotes.txt .\n과거에 있던 디렉토리에서 파일을 현재 작업 디렉토리로 옮긴 효과가 나타난다. ls 명령어가 thesis 디렉토리가 비였음을 보여준다:\n$ ls thesis\n더 나아가, ls 명령어를 인자로 파일 이름 혹은 디렉토리 이름과 함께 사용하면, 그 해당 파일 혹은 디렉토리만 화면에 보여준다. 이렇게 사용하면, quotes.txt 파일이 현재 작업 디렉토리에 있음을 볼 수 있다:\n$ ls quotes.txt\nquotes.txt\n\n현재 폴더로 이동하기\n다음 명령어를 실행한 후에, 정훈이는 sucrose.dat, maltose.dat 파일을 잘못된 폴더에 넣은 것을 인지하게 되었다:\n$ ls -F\n analyzed/ raw/\n$ ls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\n$ cd raw/\n해당 파일을 현재 디렉토리(즉, 현재 사용자가 위치한 폴더)로 이동시키도록 아래 빈칸을 채우시오:\n$ mv ___/sucrose.dat  ___/maltose.dat ___\n\n$ mv ../analyzed/sucrose.dat ../analyzed/maltose.dat .\n.. 디렉토리는 부모 디렉토리(즉, 현재 디렉토리에서 상위 디렉토리를 지칭) . 디렉토리는 현재 디렉토리를 지칭함을 상기한다.\n\n\ncp 명령어는 mv 명령어와 거의 동일하게 동작한다. 차이점은 이동하는 대신에 복사한다는 점이다. 인자로 경로를 두개 갖는 ls 명령어로 제대로 작업을 했는지 확인할 수 있다. 대부분의 유닉스 명령어와 마찬가지로, ls 명령어로 한번 경로 다수를 전달할 수도 있다:\n$ cp quotes.txt thesis/quotations.txt\n$ ls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\n복사를 제대로 수행했는지 증명하기 위해서, 현재 작업 디렉토리에 있는 quotes.txt 파일을 삭제하고 나서, 다시 동일한 ls 명령어를 실행한다.\n$ rm quotes.txt\n$ ls quotes.txt thesis/quotations.txt\nls: cannot access quotes.txt: No such file or directory\nthesis/quotations.txt\n이번에는 현재 디렉토리에서 quotes.txt 파일은 찾을 수 없지만, 삭제하지 않은 thesis 폴더의 복사본은 찾아서 보여준다.\n\n파일명이 뭐가 중요해?\nNelle의 파일 이름이 “무엇.무엇”으로 된 것을 알아챘을 것이다. 이번 학습에서, 항상 .txt 확장자를 사용했다. 이것은 단지 관례다: 파일 이름을 mythesis 혹은 원하는 무엇이든지 작명할 수 있다. 하지만, 대부분의 사람들은 두 부분으로 구분된 이름을 사용하여 사람이나 프로그램이 다른 유형의 파일임을 구분하도록 돕는다. 이름에 나온 두번째 부분을 파일 확장자(filename extension)라고 부르고, 파일에 어떤 유형의 데이터가 담고 있는지 나타낸다. .txt 확장자는 텍스트 파일임을, .pdf는 PDF 문서임을, .cfg 확장자는 어떤 프로그램에 대한 구성정보를 담고 있는 형상관리 파일임을 내고, .png 확장자는 PNG 이미지 등등을 나타낸다.\n단지 관습이기는 하지만 중요하다. 파일은 바이트(byte) 정보를 담고 있다: PDF 문서, 이미지, 등에 대해서 규칙에 따라 바이트를 해석하는 것은 사람과 작성된 프로그램에 맡겨졌다.\nwhale.mp3처럼 고래 PNG 이미지 이름을 갖는 파일을 고래 노래의 음성파일로 변환하는 마술은 없다. 설사 누군가 두번 클릭할 때, 운영체제가 음악 재생기로 열어 실행할 수는 있지만 동작은 되지 않을 것이다.\n\n\n파일 이름 바꾸기\n데이터를 분석하는데 필요한 통계 검정 목록을 담고 있는 .txt 파일을 현재 디렉토리에 생성했다고 가정하자; 파일명은 statstics.txt. 파일을 생성하고 저장한 후에 곰곰히 생각해 보니 파일명 철자가 틀린 것을 알게 되었다! 틀린 철자를 바로잡고자 하는데, 다음 중 어떤 명령어를 사용해야 하는가? 1. cp statstics.txt statistics.txt 2. mv statstics.txt statistics.txt 3. mv statstics.txt . 4. cp statstics.txt .\n\n해답 1. No. 철자오류가 수정된 파일이 생성되지만, 철자가 틀린 파일도 디렉토리에 여전히 존재하기 때문에 삭제작업이 필요하다. 2. Yes, 이 명령어를 통해서 파일명을 고칠 수 있다. 3. No, 마침표(.)는 파일을 이동할 디렉토리를 나타내지 새로운 파일명을 제시하고 있지는 않고 있다; 동일한 파일명은 생성될 수 없다. 4. No, 마침표(.)는 파일을 복사할 디렉토리를 나타내지 새로운 파일명을 제시하고 있지는 않고 있다; 동일한 파일명은 생성될 수 없다.\n\n\n\n이동과 복사 아래 보여진 일련의 명령문에 뒤에 ls명령어의 출력값은 무엇일까요?\n$ pwd\n/Users/jamie/data\n$ ls\nproteins.dat\n$ mkdir recombine\n$ mv proteins.dat recombine/\n$ cp recombine/proteins.dat ../proteins-saved.dat\n$ ls\n\nproteins-saved.dat recombine\nrecombine\nproteins.dat recombine\nproteins-saved.dat\n\n\n해답 /Users/jamie/data 디렉토리에서 출발해서, recombine 이름의 디렉토리를 새로 생성한다. 두번째 행은 proteins.dat 파일을 새로 만든 폴더 recombine으로 이동(mv) 시킨다. 세번째 행은 방금전에 이동한 파일에 대한 사본을 생성시킨다. 여기서 조금 까다로운 점은 파일이 복사되는 디렉토리다. .. 이 의미하는 바가 “한단계 위로 이동”하라는 의미라서, 복사되는 파일은 이제 /Users/jamie 디렉토리에 위치하게 됨을 상기한다. .. 이 의미하는 바는 복사되는 파일 위치에 대한 것이 아니라 현재 작업 디렉토리에 대한 것으로 해석됨에 유의한다. 그래서, 그래서, ls 명령어를 사용해서 보여지게 되는 것은 (/Users/jamie/data에 있기 때문에) recombine 폴더가 된다.\n\nNo, 상기 해설을 참조한다. proteins-saved.dat 데이터는 /Users/jamie 폴더에 위치한다.\nYes\nNo, 상기 해설을 참조한다. proteins.dat 데이터는 /Users/jamie/data/recombine 폴더에 위치한다.\nNo, 상기 해설을 참조한다. proteins-saved.dat 데이터는 /Users/jamie 폴더에 위치한다."
  },
  {
    "objectID": "shell-create.html#shell-moving-multiple",
    "href": "shell-create.html#shell-moving-multiple",
    "title": "1  파일과 디렉토리 작업",
    "section": "1.3 다수 파일과 폴더 작업",
    "text": "1.3 다수 파일과 폴더 작업\n\n다수 파일을 복사하기 이번 연습문제에서는 data-shell/data 디렉토리에서 명령어를 테스트한다. 아래 예제에서, 파일명 다수와 디렉토리명이 주어졌을 떄 cp 명령어는 어떤 작업을 수행하는가?\n$ mkdir backup\n$ cp amino-acids.txt animals.txt backup/\n아래 예제에서, 3개 혹은 그 이상의 파일명이 주어졌을 때 cp 명령어는 어떤 작업을 수행하는가?\n$ ls -F\namino-acids.txt  animals.txt  backup/  elements/  morse.txt  pdb/  planets.txt  salmon.txt  sunspot.txt\n$ cp amino-acids.txt animals.txt morse.txt \n\n해답 하나이상 파일명 다음에 디렉토리명이 주어지게 되면(즉, 목적지 디렉토리는 마지막 인자에 위치해야 한다.), cp 명령어는 파일을 해당 디렉토리에 복사한다.\n연달아 파일명이 세게 주어지면, cp 명령어는 오류를 던지는데 이유는 마지막 인자로 디렉토리를 기대했기 때문이다.\ncp: target ‘morse.txt’ is not a directory\n\n\n\n와일드 카드(Wildcards)\n*는 와일드카드(wildcard)다. 와일드카드는 0 혹은 그 이상의 문자와 매칭되서, *.pdb은 ethane.pdb, propane.pdb 등등에 매칭한다. 반면에, p*.pdb은 propane.pdb와 pentane.pdb만 매칭하는데, 맨 앞에 ’p’로 시작되는 파일명만 일치하기만 하면 되기 때문이다.\n?도 또한 와일드카드지만 단지 단일 문자만 매칭한다. 이것이 의미하는 바는 p?.pdb은 pi.pdb\n혹은 p5.pdb을 매칭하지만 (molecules 디렉토리에 두 파일이 있다면), propane.pdb은 매칭하지 않는다. 한번에 원하는 수만큼 와일드카드를 사용할 수 있다. 예를 들어, p*.p?*는 ‘p’로 시작하고’.’과 ‘p’, 그리고 최소 한자의 이상의 문자로 끝나는 임의의 문자열을 매칭한다고 표현할 수 있는데 ‘?’이 한 문자를 매칭해야하고 마지막’*‘은 끝에 임의의 문자숫자와 매칭할 수 있기 때문이다. 그래서 p*.p?*은 preferred.practice과 심지어 p.pi도 매칭한다(첫번째’*‘은 어떤 문자도 매칭할 수가 없음). 하지만 quality.practice은 매칭할 수 없는데 이유는 ’p’로 시작하지 않고, preferred.p도 매칭할 수 없는데 ’p’ 다음에 최소 하나의 문자가 필요한데 없기 때문이다.\n쉘이 와일드카드를 봤을 때, 요청된 명령문을 시작하기 전에 와일드카드를 확장하여 매칭할 파일 이름 목록을 생성한다. 예외로, 와일드카드 표현식이 어떤 파일과도 매칭되지 않게되면, 배수는 명령어에 인자로 표현식을 있는 그대로 전달한다. 예를 들어, molecules 디렉토리(.pdb 확장자로 끝나는 파일만 모여있다.)에 ls *.pdf을 타이핑하게 되면, *.pdf으로 불리는 파일이 없다고 오류 메시지를 출력한다. 하지만, 일반적으로 wc과 ls 명령어는 와일드카드 표현식과 매칭되는 파일명 목록을 보게 되고 와일드카드 자체가 아니다. 다른 프로그램은 아니지만, 쉘은 와일드카드를 확장한 것을 다룬다는 점에서 직교 설계(orthogonal design)의 또 다른 사례로 볼 수 있다.\n\n\n와일드카드 추가 문제\n정훈이는 미세조정(calibration), 원본 데이터(dataset), 데이터 설명 데이터를 디렉토리에 보관하고 있다:\n2015-10-23-calibration.txt\n2015-10-23-dataset1.txt\n2015-10-23-dataset2.txt\n2015-10-23-dataset_overview.txt\n2015-10-26-calibration.txt\n2015-10-26-dataset1.txt\n2015-10-26-dataset2.txt\n2015-10-26-dataset_overview.txt\n2015-11-23-calibration.txt\n2015-11-23-dataset1.txt\n2015-11-23-dataset2.txt\n2015-11-23-dataset_overview.txt\n또 다른 견학여행을 떠나기 전에, 정훈이는 데이터를 백업하고 일부 데이터를 랩실 동료 기민에게 보내고자 한다. 정훈이는 백업과 전송 작업을 위해서 다음 명령어를 사용한다:\n$ cp *dataset* /backup/datasets\n$ cp ____calibration____ /backup/calibration\n$ cp 2015-____-____ ~/send_to_bob/all_november_files/\n$ cp ____ ~/send_to_bob/all_datasets_created_on_a_23rd/\n정훈이가 빈칸을 채우도록 도움을 주세요. > 해답 > > > $ cp *calibration.txt /backup/calibration > $ cp 2015-11-* ~/send_to_bob/all_november_files/ > $ cp *-23-dataset* ~send_to_bob/all_datasets_created_on_a_23rd/ >\n\n\n디렉토리와 파일 조직화\n정훈이가 프로젝트 작업을 하고 있는데, 작업 파일이 그다지 잘 조직적으로 정리되어 있지 않음을 알게 되었다:\n$ ls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nfructose.dat 와 sucrose.dat 파일은 자료분석 결과 산출된 출력결과를 담고 있다. 이번 학습에서 배운 어떤 명령어를 실행해야, 아래 명령어를 실행했을 때 다음에 보여지는 출력을 생성할까요?\n$ ls -F\nanalyzed/   raw/\n$ ls analyzed\nfructose.dat    sucrose.dat\n\n해답\nmv *.dat analyzed\n정훈이는 analyzed 디렉토리에 fructose.dat, sucrose.dat 파일을 이동시킬 필요가 있다. 쉘에서 현재 디렉토리에서 *.dat 와일드카드가 .dat 확장자를 갖는 모든 파일을 매칭한다. mv 명령어가 .dat 확장자를 갖는 파일을 analyzed 디렉토리로 이동시킨다.\n\n\n\n폴더 구조를 복사하지만, 파일을 복사하지 말자.\n새로운 실험을 시작해 보자. 데이터 파일 없이 이전 실험에게 만들었던 파일 구조만 복제하자. 그렇게 하면 새로운 데이터를 쉽게 추가할 수 있게 된다. ‘2016-05-18-data’ 디렉토리에 data 폴더로 raw와 processed가 있는데, 각자 데이터 파일이 담겨있다.\n목적은 2016-05-18-data 폴더를 2016-05-20-data 폴더로 복사하는 것인데 복사된 폴더에는 모든 데이터 파일을 제거해야 된다. 다음 명령어 집합 중 어떤 명령어 집합이 상기 목적을 달성할까요? 다른 명령어 집합은 무슨 작업을 수행하는 것일가?\n$ cp -r 2016-05-18-data/ 2016-05-20-data/\n$ rm 2016-05-20-data/raw/*\n$ rm 2016-05-20-data/processed/*\n$ rm 2016-05-20-data/raw/*\n$ rm 2016-05-20-data/processed/*\n$ cp -r 2016-05-18-data/ 2016-5-20-data/\n$ cp -r 2016-05-18-data/ 2016-05-20-data/\n$ rm -r -i 2016-05-20-data/\n\n해답\n첫번째 명령어들이 해당 목적을 달성한다. 먼저 재귀적으로 데이터 폴더를 복사한다. 그리고 나서 rm 명령어 두번 사용해서 복사한 디렉토리의 모든 파일을 제거한다. 쉘은 * 와일드카드로 매칭되는 모든 파일과 하위디렉토리를 확장하도록 한다.\n두번째 명령어들은 순서가 잘못되었다: 복사하지 않는 파일을 샂게하고 나서 재귀 복사 명령어로 디렉토리를 복사했다.\n세번째 명령어도 목적을 달성하는데, 시간이 다소 소요된다: 첫번째 명령어가 디렉토리를 재귀적으로 복사하지만, 두번째 명령어는 인터랙티브하게 각 파일과 디렉토리에 대한 확인하는 과정을 거쳐 삭제를 하게 되어 시간이 추가로 소요된다."
  },
  {
    "objectID": "04-shell-pipefilter.html#nelle-file",
    "href": "04-shell-pipefilter.html#nelle-file",
    "title": "6  파이프와 필터",
    "section": "6.1 Nelle 파이프라인: 파일 확인하기",
    "text": "6.1 Nelle 파이프라인: 파일 확인하기\n앞에서 설명한 것처럼 Nelle은 분석기를 통해 시료를 시험해서 17개 파일을 north-pacific-gyre/2012-07-03 디렉토리에 생성했다. 빠르게 건전성 확인하기 위해, 홈디렉토리에서 시작해서, 다음과 같이 타이핑한다:\n$ cd north-pacific-gyre/2012-07-03\n$ wc -l *.txt\n결과는 다음과 같은 18 행이 출력된다:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\n이번에는 다음과 같이 타이핑한다:\n$ wc -l *.txt | sort -n | head -n 5\n\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\n이런, 파일중에 하나가 다른 것보다 60행이 짧다. 다시 돌아가서 확인하면, 월요일 아침 8:00 시각에 분석을 수행한 것을 알고 있다 — 아마도 누군가 주말에 기계를 사용했고, 다시 재설정하는 것을 깜빡 잊었을 것이다. 시료를 다시 시험하기 전에 파일중에 너무 큰 데이터가 있는지를 확인한다:\n$ wc -l *.txt | sort -n | tail -n 5\n\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\n숫자는 예뻐 보인다 — 하지만 끝에서 세번째 줄에 ‘Z’는 무엇일까? 모든 시료는 ’A’ 혹은 ’B’로 표시되어야 한다. 시험실 관례로 ’Z’는 결측치가 있는 시료를 표식하기 위해 사용된다. 더 많은 결측 시료를 찾기 위해, 다음과 같이 타이핑한다:\n$ ls *Z.txt\n\nNENE01971Z.txt    NENE02040Z.txt\n노트북의 로그 이력을 확인할 때, 상기 샘플 각각에 대해 깊이(depth) 정보에 대해서 기록된 것이 없었다. 다른 방법으로 정보를 더 수집하기에는 너무 늦어서, 분석에서 두 파일을 제외하기로 했다. rm 명령어를 사용하여 삭제할 수 있지만, 향후에 깊이(depth)정보가 관련없는 다른 분석을 실시할 수도 있다. 그래서 와일드 카드 표현식 *[AB].txt을 사용하여 파일을 조심해서 선택하기로 한다. 언제나 그렇듯이, ’*’는 임의 숫자의 문자를 매칭한다. [AB] 표현식은 ’A’혹은 ’B’를 매칭해서 Nelle이 가지고 있는 유효한 데이터 파일 모두를 매칭한다.\n\n와일드카드 표현식(Wildcard Expressions)\n와일드카드 표현식은 매우 복잡할 수 있지만, 종종 다소 장황할 수 있는 비용을 지불하고 간단한 구문만 사용해서 작성하기도 한다. data-shell/north-pacific-gyre/2012-07-03 디렉토리를 생각해 보자: *[AB].txt 와일드카드 표현식은 A.txt 혹은 B.txt으로 끝나는 모든 파일을 매칭시킨다. 이 와일드카드 표현식을 잊었다고 상상해보자:\n\n[] 구문을 사용하지 않는 기본 와일드드카드 표현식으로 동일하게 파일을 매칭할 수 있을까? 힌트: 표현식이 하나 이상 필요할 수도 있다.\n[] 구문을 사용하지 않고 작성한 표현식은 동일한 파일을 매칭한다. 두 출력결과의 작은 차이점은 무엇인가?\n최초 와일드카드 표현식은 오류가 나지 않는데 어떤 상황에서 본인 표현식은 오류 메시지를 출력하는가?\n\n\n해답 1.\n  $ ls *A.txt\n  $ ls *B.txt\n\n새로운 명령어에서 나온 출력결과는 명령어가 두개라 구분된다. The output from the new commands is separated because there are two commands.\nA.txt로 끝나는 파일이 없거나 B.txt로 끝나는 파일이 없는 경우 그렇다.\n\n\n\n\n불필요한 파일 제거하기\n저장공간을 절약하고자 중간 처리된 데이터 파일을 삭제하고 원본 파일과 처리 스크립트만 보관했으면 한다고 가정하자.\n원본 파일은 .dat으로 끝나고, 처리된 파일은 .txt으로 끝난다. 다음 중 어떤 명령어가 처리과정에서 생긴 중간 모든 파일을 삭제하게 하는가? 1. rm ?.txt 2. rm *.txt 3. rm * .txt 4. rm *.*\n\n해답 1. 한문자 .txt 파일을 제거한다. 2. 정답 3. * 기호로 인해 현재 디렉토리 모든 파일과 디렉토리를 매칭시킨다. 그래서 * 기호로 매칭되는 모든 것과 추가로 .txt 파일도 삭제한다. 4. *.* 기호는 임의 확장자를 갖는 모든 파일을 매칭시킨다. 따라서 *.* 기호는 모든 파일을 삭제한다."
  },
  {
    "objectID": "05-shell-loop.html#nelle-shell-loop",
    "href": "05-shell-loop.html#nelle-shell-loop",
    "title": "2  루프(Loops)",
    "section": "2.1 Nelle의 파이프라인: 많은 파일 처리하기",
    "text": "2.1 Nelle의 파이프라인: 많은 파일 처리하기\nNelle은 이제 goostats 프로그램(논문 지도교수가 작성한 쉘 스크립트)을 사용해서 데이터 파일을 처리할 준비가 되었다. goostats 프로그램은 표본추출 단백질 파일에서 통계량을 산출하는데 인자를 두개 받는다:\n\n입력파일 (원본 데이터를 포함)\n출력파일 (산출된 통계량을 저장)\n\n아직 쉘을 어떻게 사용하는지 학습단계에 있기 때문에, 단계별로 요구되는 명령어를 차근히 작성하기로 마음먹었다. 첫번째 단계는 적합한 파일을 선택했는지를 확인하는 것이다 — ‘Z’가 아닌 ’A’ 혹은 ’B’로 파일이름이 끝나는 것이 적합한 파일이라는 것을 명심한다. 홈 디렉토리에서 시작해서, 박사과정 Nelle이 다음과 같이 타이핑한다:\n$ cd north-pacific-gyre/2012-07-03\n$ for datafile in NENE*[AB].txt\n> do\n>     echo $datafile\n> done\n\nNENE01729A.txt\nNENE01729B.txt\nNENE01736A.txt\n...\nNENE02043A.txt\nNENE02043B.txt\n다음 단계는 goostats 분석 프로그램이 생성할 파일이름을 무엇으로 할지 결정하는 것이다. “stats”을 각 입력 파일에 접두어로 붙이는 것이 간단해 보여서, 루프를 변경해서 작업을 수행하도록 한다:\n$ for datafile in NENE*[AB].txt\n> do\n>     echo $datafile stats-$datafile\n> done\n\nNENE01729A.txt stats-NENE01729A.txt\nNENE01729B.txt stats-NENE01729B.txt\nNENE01736A.txt stats-NENE01736A.txt\n...\nNENE02043A.txt stats-NENE02043A.txt\nNENE02043B.txt stats-NENE02043B.txt\ngoostats을 아직 실행하지는 않았지만, 이제 확신할 수 있는 것은 올바른 파일을 선택해서, 올바른 출력 파일이름을 생성할 수 있다는 점이다.\n명령어를 반복적으로 타이핑하는 것은 귀찮은 일이지만, 더 걱정이 되는 것은 Nelle이 타이핑 실수를 하는 것이다. 그래서 루프를 다시 입력하는 대신에 위쪽 화살표를 누른다. 위쪽 화살표에 반응해서 컴퓨터 쉘은 한줄에 전체 루프를 다시 보여준다. (스크립트 각 부분이 구분되는데 세미콜론이 사용됨):\n$ for datafile in NENE*[AB].txt; do echo $datafile stats-$datafile; done\n왼쪽 화살표 키를 사용해서, Nelle은 echo명령어를 bash goostats으로 변경하고 백업한다:\n$ for datafile in NENE*[AB].txt; do bash goostats $datafile stats-$datafile; done\n엔터키를 누를 때, 쉘은 수정된 명령어를 실행한다. 하지만, 어떤 것도 일어나지 않는 것처럼 보인다 — 출력이 아무것도 없다. 잠시뒤에 Nelle은 작성한 스크립트가 화면에 아무것도 출력하지 않아서, 실행되고 있는지, 얼마나 빨리 실행되는지에 대한 정보가 없다는 것을 깨닫는다. 컨트롤+C(Control-C)를 눌러서 작업을 종료하고, 반복할 명령문을 위쪽 화살표로 선택하고, 편집해서 다음과 같이 작성한다:\n$ for datafile in NENE*[AB].txt; do echo $datafile; bash goostats $datafile stats-$datafile; done\n\n시작과 끝\n쉘에 ^A, 콘트롤+A(Control-A, Ctrl-a)를 타이핑해서 해당 라인 처음으로 가고, ^E (Ctrl-e, Control-E)를 쳐서 라인의 끝으로 이동한다.\n\n이번에 프로그램을 실행하면, 매 5초간격으로 한줄을 출력한다:\nNENE01729A.txt\nNENE01729B.txt\nNENE01736A.txt\n...\n\n1518 곱하기 5초를 60으로 나누면, 작성한 스크립트를 실행하는데 약 2시간 정도 소요된다고 볼 수 있다. 마지막 점검으로, 또다른 터미널 윈도우를 열어서, north-pacific-gyre/2012-07-03 디렉토리로 가서, cat stats-NENE01729B.txt을 사용해서 출력파일 중 하나를 면밀히 조사한다. 출력결과가 좋아보인다. 그래서 커피를 마시고 그동안 밀린 논문을 읽기로 한다.\n\n역사(history)를 아는 사람은 반복할 수 있다.\n앞선 작업을 반복하는 또다른 방법은 history 명령어를 사용하는 것이다. 실행된 마지막 수백개 명령어 리스트를 얻고 나서, 이들 명령어 중 하나를 반복실행하기 위해서 !123(“123”은 명령 숫자로 교체된다.)을 사용한다. 예를 들어 Nelle이 다음과 같이 타이핑한다면:\n$ history | tail -n 5\n  456  ls -l NENE0*.txt\n  457  rm stats-NENE01729B.txt.txt\n  458  bash goostats NENE01729B.txt stats-NENE01729B.txt\n  459  ls -l NENE0*.txt\n  460  history\n그리고 나서, 단순히 !458을 타이핑함으로써, NENE01729B.txt 파일에 goostats을 다시 실행할 수 있게 된다.\n\n\n다른 이력(history) 명령어\n이력(history)에 접근하는 단축 명령어가 다수 존재한다.\n\nCtrl-R 탄축키는 “reverse-i-search” 이력 검색모드로 입력한 텍스트와 매칭되는 가장 최슨 명령어를 이력에서 찾아서 제시한다. Ctrl-R 단축키를 한번 혹은 그 이상 누르게 되면 그 이전 매칭을 검색해 준다.\n!! 명령어는 바로 직전 명령어를 불러온다. (키보드 윗화살표를 사용하는 것보다 더 편리할수도 편리하지 않을 수도 있다.)\n!$ 명령어는 마지막 명령문의 마지막 단어를 불러온다. 기대했던 것보다 훨씬 유용할 수 있다: bash goostats NENE01729B.txt stats-NENE01729B.txt 명령문을 실행한 후에 less !$을 타이핑하게 되면 stats-NENE01729B.txt 파일을 찾아준다. 키보드 위화살표를 눌러 명령라인을 편집하는 것보다 훨씬 빠르다.\n\n\n\n루프 내부에서 파일에 저장하기 - 1부\ndata-shell/molecules 디렉토리에 있다고 가정하자. 다음 루프의 효과는 무엇인가?\n$ for alkanes in *.pdb\n> do\n>     echo $alkanes\n>     cat $alkanes > alkanes.pdb\n> done\n\nfructose.dat, glucose.dat, sucrose.dat을 출력하고, sucrose.dat에서 나온 텍스트를 xylose.dat에 저장된다.\nfructose.dat, glucose.dat, sucrose.dat을 출력하고, 모든 파일 3개에서 나온 텍스트를 합쳐 xylose.dat에 저장된다.\nfructose.dat, glucose.dat, sucrose.dat, xylose.dat을 출력하고, sucrose.dat에서 나온 텍스트를 xylose.dat에 저장된다.\n위 어느 것도 아니다.\n\n\n해답 1. 순차적으로 각 파일의 텍스트가 alkanes.pdb 파일에 기록된다. 하지만, 루프가 매번 반복될 때마다 파일에 덮어쓰기가 수행되어서 마지막 alkanes.pdb 파일 텍스트만 alkanes.pdb 파일에 기록된다.\n\n\n\n루프 내부에서 파일에 저장하기 - 2부\n이번에도 data-shell/molecules 디렉토리에 있다고 가정하고, 다음 루프 실행 출력결과는 무엇일까?\n$ for datafile in *.pdb\n> do\n>     cat $datafile >> all.pdb\n> done\n\ncubane.pdb, ethane.pdb, methane.pdb, octane.pdb, pentane.pdb 파일에 나온 모든 모든 텍스트가 하나로 붙여져서 all.pdb 파일에 저장된다.\nethane.pdb 파일에 나온 텍스트만 all.pdb 파일에 저장된다.\ncubane.pdb, ethane.pdb, methane.pdb, octane.pdb, pentane.pdb, propane.pdb 파일에서 나온 모든 텍스트가 하나로 풑여져서 all.pdb 파일에 저장된다.\ncubane.pdb, ethane.pdb, methane.pdb, octane.pdb, pentane.pdb, propane.pdb 파일에서 나온 모든 텍스트가 화면에 출력되고 all.pdb 파일에 저장된다.\n\n\n해답 정답은 3. 명령어 실행 출력결과를 방향변경하여 덮었는 것이 아니라 >> 기호는 파일에 덧붙인다. cat 명령어에서 나온 출력결과가 파일로 방향변경되어 어떤 출력결과도 화면에 출력되지는 않는다.\n\n\n\n시운전(Dry Run)\n루프는 한번에 많은 작업을 수행하는 방식이다 — 만약 잘못된 것이 있다면, 한번에 실수를 대단히 많이 범하게 된다. 루프가 수행하는 작업을 점검하는 한 방법이 실제로 루프를 돌리는 대신에 echo 명령어를 사용하는 것이다. 실제로 명령어를 실행하지 않고, 다음 루프가 실행할 명령어를 머릿속으로 미리보고자 한다고 가정한다:\n$ for file in *.pdb\n> do\n>   analyze $file > analyzed-$file\n> done\n아래 두 루프 사이에 차이는 무엇이고, 어느 것을 시운전으로 실행하고 싶은가?\n# Version 1\n$ for file in *.pdb\n> do\n>   echo analyze $file > analyzed-$file\n> done\n# Version 2\n$ for file in *.pdb\n> do\n>   echo \"analyze $file > analyzed-$file\"\n> done\n\n해답 두번째 버젼을 실행하면 좋을 것이다. 달러 기호로 접두명을 주었기 때문에 루프 변수를 확장해서 인용부호로 감싼 모든 것을 화면에 출력한다.\n첫번째 버전은 echo analyze $file 명령을 수행해서 analyzed-$file 파일로 출력결과를 방향변경하여 저장시킨다. 따라서 파일이 쭉 자동생성된다:analyzed-cubane.pdb, analyzed-ethane.pdb …\n두가지 버젼을 직접 실행해보고 출력결과를 살펴보자! analyzed-*.pdb 파일을 열어서 파일에 기록된 내용도 살펴본다.\n\n\n\n중첩루프(Nested Loops) 다른 화합물과 다른 온도를 갖는 조합을 해서, 각 반응율 상수를 측정하는 실험을 조직하도록 이에 상응하는 디렉토리 구조를 갖추고자 한다. 다음 코드 실행결과는 어떻게 될까?\n$ for species in cubane ethane methane\n> do\n>     for temperature in 25 30 37 40\n>     do\n>         mkdir $species-$temperature\n>     done\n> done\n\n해답 중첩 루프(루프 내부에 루프가 포함됨)를 생성하게 된다. 외부 루프에 각 화학물이, 내부 루프(중첩된 루프)에 온도 조건을 반복하게 되서, 화학물과 온도를 조합한 새로운 디렉토리가 쭉 생성된다.\n직접 코드를 실행해서 어떤 디렉토리가 생성되는지 확인한다!"
  },
  {
    "objectID": "01-shell-intro.html#shell-background",
    "href": "01-shell-intro.html#shell-background",
    "title": "3  쉘(Shell) 소개",
    "section": "3.1 배경",
    "text": "3.1 배경\n상위 수준에서 컴퓨터는 네가지 일을 수행한다:\n\n프로그램 실행\n데이터 저장\n컴퓨터간 상호 의사소통\n사람과 상호작용\n\n마지막 작업을 뇌-컴퓨터 연결, 음성 인터페이스를 포함한 다양한 많은 방식으로 수행하고 있지만 아직은 초보적인 수준이어서, 대부분은 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)를 사용한다. 1980년대까지 이러한 기술은 보편적이지 않았지만, 기술의 뿌리는 1960년대 Doug Engelbart의 작업에 있고, “The Mother of All Demos”로 불리는 것에서 볼 수 있다.\n조금 더 멀리 거슬러 올라가면, 초기 컴퓨터와 상호작용하는 유일한 방법은 와이어로 다시 연결하는 것이다. 하지만, 중간에 1950년에서 1980년 사이 대부분의 사람들이 라인 프린터(line printer)를 사용했다. 이런 장치는 표준 키보드에 있는 문자, 숫자, 특수부호의 입력과 출력만 허용해서, 프로그래밍 언어와 인터페이스는 이러한 제약사항에서 설계됐다.\n여전히 전통적인 화면, 마우수, 터치패드, 키보드를 사용하지만 터치 인터페이스와 음성 인터페이스가 보편화되고 있다.\n이런 종류의 인터페이스를 지금 대부분의 사람들이 사용하는 그래픽 사용자 인터페이스(GUI, graphical user interface)과 구별하기 위해서 명령-라인 인터페이스(CLI, command-line interface)라고 한다. CLI의 핵심은 읽기-평가-출력(REPL,read-evaluate-print loop)이다: 사용자가 명령어를 타이핑하고 엔터(enter)/반환(return)키를 입력하면, 컴퓨터가 읽고, 실행하고, 결과를 출력한다. 그러고 나면, 사용자는 다른 명령를 타이핑하는 것을 로그 오프해서 시스템을 빠져 나갈때까지 계속한다.\nGUI는 WIMP((Window) 윈도우, (Icon)아이콘, (Mouse)마우스, (Pointer)포인터)로 구성되는데 배우기 쉽고, 단순 작업에 대해서는 환상적이다. “클릭”하게 되면 명령이 “내가 원하는 작업을 수행해”라고 손쉽게 컴퓨터에 통역된다. 하지만, 이런 마술은 단순한 작업을 수행하고, 정확하게 이러한 유형의 작업을 수행할 수 있는 프로그램에 불과하다.\n만약 복잡하고, 특정 목적에 부합되는 훨씬 묵직한 작업을 컴퓨터에 내리고자 한다고 해서, 난해하거나 어렵거나할 필요는 없고, 단지 명령 어휘가 필요하고 이를 사용하는데 필요한 단순한 문법만 필요로 한다.\n쉘이 이런 기능을 제공한다 - 단순한 언어로 이를 사용하는데 명령-라인 인터페이스가 필요하다. 명령라인 인터페이스의 심장은 읽기-평가-출력(REPL,read-evaluate-print loop)이다. REPL로 불리는 이유는 쉘에 명령어를 타이핑하고 Return를 치게되면 컴퓨터가 명령어를 읽어들이고 나서, 평가(혹은 실행)하고 출력결과를 화면에 뿌린다. 또 다른 명령어를 입력할 때까지 대기하는 루푸를 반복하게 되서 그렇다.\n상기 묘사가 마치 사용자가 직접 명령어를 컴퓨터에 보내고, 컴퓨터는 사용자에게 직접적으로 출력을 보내는 것처럼 들린다. 사실 중간에 명령 쉘(command shell)로 불리는 프로그램이 있다. 사용자가 타이핑하는 것은 쉘로 간다. 쉘은 무슨 명령어를 수행할지 파악해서 컴퓨터에게 수행하도록 지시한다. 쉘을 조개 껍데기(shell)로 불리는데 이유는 운영체제를 감싸서, 복잡성 일부를 숨겨서 운영체제와 더 단순하게 상호작용하게 만든다."
  },
  {
    "objectID": "01-shell-intro.html#shell-shell",
    "href": "01-shell-intro.html#shell-shell",
    "title": "3  쉘(Shell) 소개",
    "section": "3.2 쉘(Shell)",
    "text": "3.2 쉘(Shell)\n쉘(Shell)은 다른 것과 마찬가지로 프로그램이다. 조금 특별한 것은 자신이 연산을 수행하기 보다 다른 프로그램을 실행한다는 것이다. 가장 보편적인 유닉스 쉘(Unix Shell)은 Bash(Bourne Again SHell)다. Stephen Bourne이 작성한 쉘에서 나와서 그렇게 불리우고 — 프로그래머 사이에 재치로 통한다. Bash는 대부분의 유닉스 컴퓨터에 기본으로 장착되는 쉘이고, 윈도우용으로 유닉스스런 도구로 제공되는 패키지 대부분에도 적용된다.\nBash나 다른 쉘을 사용하는 것이 마우스를 사용하는 것보다 프로그래밍 작성하는 느낌이 난다. 명령어는 간략해서 (흔히 단지 2~3자리 문자다), 명령어는 자주 암호스럽고, 출력은 그래프같이 시각적인 것보다 텍스트줄로 쭉 뿌려진다. 다른 한편으로, 쉘을 사용하여 좀더 강력한 방식으로 현존하는 도구를 단지 키보드 입력값 몇개를 조합해서 대용량의 데이터를 자동적으로 처리할 수 있는 파이프라인을 구축할 수 있게 한다. 추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다. 클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다. 여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다."
  },
  {
    "objectID": "01-shell-intro.html#shell-looks-like",
    "href": "01-shell-intro.html#shell-looks-like",
    "title": "3  쉘(Shell) 소개",
    "section": "3.3 어떻게 생겼을까?",
    "text": "3.3 어떻게 생겼을까?\n전형적인 쉘 윈도우는 다음과 같다:\nbash-3.2$ \nbash-3.2$ ls -F / \nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\nbash-3.2$ \n첫번째 줄은 프롬프트(prompt)만 보여주고 있고, 쉘이 입력준비가 되었다는 것을 나타낸다. 프롬프트로 다른 텍스트를 지정할 수도 있다. 가장 중요한 것: 명령어를 타이핑할 때, 프롬프트를 타이핑하지 말고, 인식되거나 수행할 수 있는 명령어만 타이핑한다.\n예제 두번째 줄에서 타이핑한 ls -F / 부분이 전형적인 구조를 보여주고 있다: 명령어(command), 플래그(flags) (선택옵션(options) 혹은 스위치(switches)) 그리고 인자(argument). 플래그는 대쉬(-) 혹은 더블 대쉬(--)로 시작하는데 명령어의 행동에 변화를 준다.\n인자는 명령어에 작업할 대상을 일러준다(예를 들어, 파일명과 디렉토리). 종종 플래그를 매개변수(parameter)라고도 부른다. 명령어를 플래그 한개 이상, 인자도 한개 이상 사용하기도 한다: 하지만, 명령어가 항상 인자 혹은 플래그를 요구하지는 않는다.\n상기 예제의 두번째 줄에서, 명령어는 ls, 플래그는 -F, 인자는 /이 된다. 각각은 공백으로 뚜렸하게 구분된다: 만약 ls 와 -F 사이 공백을 빼먹게 되면 쉘은 ls-F 명령어를 찾게 되는데, 존재하지 않는 명령어다. 또한, 대문자도 문제가 될 수 있다: LS 명령어와 ls 명령어는 다르다.\n다음으로 명령어가 생성한 출력결과를 살펴보자. 이번 경우에 / 폴더에 위치한 파일 목록을 출력하고 있다. 금일 해당 출력결과가 무엇을 의미하는지 다룰 예정이다. 맥OS를 사용하시는 참석자분들은 이번 출력결과를 이미 인지하고 있을지도 모른다.\n마지막으로, 쉘은 프롬프트를 출력하고 다음 명령어가 타이핑되도록 대기모드로 바뀐다.\n이번 학습예제에서 프롬프트가 $이 된다. 명령어를 PS1='$ ' 타이핑하게 되면 동일하게 프롬프트를 맞출 수 있다. 하지만, 본인 취향에 맞추어 프롬프트를 둘 수도 있다 - 흔히 프롬프트에 사용자명과 디렉토리 현재 위치정보를 포함하기도 하다.\n쉘 윈도우를 열고, ls -F / 명령어를 직접 타이핑한다. (공백과 대문자가 중요함으로 잊지 말자.) 원하는 경우 프롬프트도 변경해도 좋다."
  },
  {
    "objectID": "01-shell-intro.html#shell-ls",
    "href": "01-shell-intro.html#shell-ls",
    "title": "3  쉘(Shell) 소개",
    "section": "3.4 ls 와 플래그 의미 파악",
    "text": "3.4 ls 와 플래그 의미 파악\n모든 쉘 명령어는 컴퓨터 어딘가에 저장된 프로그램으로, 쉘은 명령어를 검색해서 찾을 장소를 목록으로 이미 가지고 있다. (명령목록은 PATH로 불리는 변수(variable)에 기록되어 있지만, 이 개념을 나중에 다룰 것이라 현재로서는 그다지 중요하지는 않다.) 명령어, 플래그, 인자가 공백으로 구분된다는 점을 다시 상기하자.\nREPL(읽기-평가-출력(read-evaluate-print) 루프)를 좀더 살펴보자. “평가(evaluate)” 단계는 두가지 부분으로 구성됨에 주목한다:\n\n타이핑한 것을 읽어들인다(이번 예제에서 ls -F /) 쉘은 공백을 사용해서 명령어로 입력된 것을 명령어, 플래그, 인자로 쪼갠다.\n평가(Evaluate):\n\nls 라는 프로그램을 찾는다.\n\n찾은 프로그램을 실행하고 프로그램이 인식하고 해석한 플래그와 인자를 전달한다.\n\n프로그램 실행 결과를 출력한다.\n\n그리고 나서, 프롬프트를 출력하고 또다른 명령어를 입력받도록 대기한다.\n\n\n\n\n\n\nCommand not found 오류\n\n\n\n쉘이 타이핑한 명령어 이름을 갖는 프로그램을 찾을 수 없는 경우, 다음과 같은 오류 메시지가 출력된다:\n$ ls-F\n-bash: ls-F: command not found\n일반적으로 명령어를 잘못 타이핑했다는 의미가 된다 - 이 경우, ls 와 -F 사이 공백을 빼먹어서 그렇다. 즉, ls -F와 같이 명령을 전달하면 의도한 바가 기계에 정확히 전달된다."
  },
  {
    "objectID": "01-shell-intro.html#shell-difficulty",
    "href": "01-shell-intro.html#shell-difficulty",
    "title": "3  쉘(Shell) 소개",
    "section": "3.5 어려운가요?",
    "text": "3.5 어려운가요?\nGUI와 비교하여 컴퓨터와 상호작용하는데 있어 어려운 모형이고 학습하는데 노력과 시간이 다소 소요된다. GUI는 선택지를 보여주고, 사용자가 선택지중에서 선택하는 하는 것이다. 명령라인 인터페이스(CLI)로 선택지가 명령어와 패러미터의 조합으로 표현된다. 사용자에게 제시되는 것이 아니라서 새로운 언어의 어휘를 학습하듯이 일부 학습이 필요하다. 명령어의 일부만 배우게 되면 정말 도움이 많이 되고, 핵심적인 명령어를 다뤄보자."
  },
  {
    "objectID": "01-shell-intro.html#shell-flexibility",
    "href": "01-shell-intro.html#shell-flexibility",
    "title": "3  쉘(Shell) 소개",
    "section": "3.6 유연성과 자동화",
    "text": "3.6 유연성과 자동화\n쉘문법(Grammar of Shell)은 기존 도구를 조합해서 강력한 파이프라인을 구축하도록 해서 방대한 데이터를 자동화하여 다룰 수 있다. 명령 순서는 스크립트(script)로 작성하여 작업흐름의 재현가능성을 향상시켜서 쉽게 반복이 가능하도록 한다.\n추가로, 명령 라인은 종종 멀리 떨어진 컴퓨터 혹은 슈퍼컴퓨터와 상호작용하는 가장 쉬운 방법이다. 고성능 컴퓨팅 시스템에 포함된 다양한 특화된 도구와 자원을 실행하는데 쉘과 친숙성이 거의 필연적이다. 클러스트 컴퓨팅과 클라우드 컴퓨팅이 과학 데이터 클런칭(scientific data cruching)이 점점 대중화됨에 따라 원격 컴퓨터를 구동하는 것이 필수적인 기술이 되어가고 있다. 여기서 다뤄지는 명령-라인 기술에 기반해서 광범위한 과학적 질문과 컴퓨터적 도전과제를 처리할 수 있다."
  },
  {
    "objectID": "01-shell-intro.html#shell-nelle",
    "href": "01-shell-intro.html#shell-nelle",
    "title": "3  쉘(Shell) 소개",
    "section": "3.7 사례: 문제정의",
    "text": "3.7 사례: 문제정의\n해양 생물학자 넬 니모(Nell Nemo) 박사가 방금전 6개월간 북태평양 소용돌이꼴 조사를 마치고 방금 귀환했다. 태평양 거대 쓰레기 지대에서 젤리같은 해양생물을 표본주출했다. 총 합쳐서 1,520개 시료가 있고 다음 작업이 필요하다:\n\n서로 다른 300개 단백질의 상대적인 함유량을 측정하는 분석기계로 시료를 시험한다. 한 시료에 대한 컴퓨터 출력결과는 각 단백질에 대해 한 줄 파일형식으로 표현된다.\ngoostat으로 명명된 그녀의 지도교수가 작성한 프로그램을 사용하여 각 단백질에 대한 통계량을 계산한다.\n다른 대학원 학생중 한명이 작성한 goodiff로 명명된 프로그램을 사용해서, 각 단백질에 대한 통계량과 다른 단백질에 대해 상응하는 통계량을 비교한다.\n결과를 작성한다. 그녀의 지도교수는 이달 말까지 이 작업을 정말로 마무리해서, 논문이 다음번 Aquatic Goo Letters 저널 특별판에 게재되기를 희망한다.\n\n각 시료를 분석장비가 처리하는데 약 반시간 정도 소요된다. 좋은 소식은 각 시료를 준비하는데는 단지 2분만 소요된다. 연구실에 병렬로 사용할 수 있는 분석장비 8대가 있어서, 이 단계는 약 2주정도만 소요될 것이다.\n나쁜 소식은 goostat, goodiff를 수작업으로 실행한다면, 파일이름 입력하고 “OK” 버튼을 45,150번 눌려야 된다는 사실이다 (goostat 300회 더하기 goodiff \\(\\frac{300 \\times 299}{2}\\)). 매번 30초씩 가정하면 2주 이상 소요될 것이다. 논문 마감일을 놓칠 수도 있지만, 이 모든 명령어를 올바르게 입력할 가능성은 거의 0 에 가깝다.\n다음 수업 몇개는 대신에 그녀가 무엇을 해야되는지 탐색한다. 좀더 구체적으로, 처리하는 파이프라인 중간에 반복되는 작업을 자동화하는데 쉘 명령어(command shell)를 어떻게 사용하는지 설명해서, 논문을 쓰는 동안에 컴퓨터가 하루에 24시간 작업한다. 덤으로 중간 처리작업 파이프라인을 완성하면, 더 많은 데이터를 얻을 때마다 다시 재사용할 수 있게 된다."
  },
  {
    "objectID": "01-shell-intro.html#쉘-gpt",
    "href": "01-shell-intro.html#쉘-gpt",
    "title": "3  쉘(Shell) 소개",
    "section": "3.8 쉘 GPT",
    "text": "3.8 쉘 GPT\nOpenAI의 ChatGPT(GPT-3.5)는 콘텐츠 생성에 주된 방점이 있지만 다양한 프로그래밍 코드도 작성함은 물론 유닉스 쉘 프로그램도 작성하여 CLI 생산성을 높이는데 사용될 수 있다. ChatGPT 기능을 활용하여 쉘 명령, 코드 스니펫, 주석, 문서 등을 생성할 수 있다. 즉, 데이터 과학자를 비롯한 개발자가 기존에 업무를 수행하던 방식이 전혀 다르게 된다. 즉, 책, 매뉴얼, 비밀노트(Cheat Sheet), 인터넷 북마크, 구글링 같은 검색없이 바로 터미널에서 바로 정확한 답변을 얻어 귀중한 시간과 노력을 절약할 수 있다.\n예를 들어 앞서 프로젝트를 할 때 해당 유닉스 쉘 명령어가 기억나지 않는다고 하면 shell gpt를 사용하여 해당 작업을 신속하게 수행할 수 있다. shell_gpt는 파이썬 패키지라 다음 파이썬 명령어로 패키지 설치를 할 수 있다.\npip install shell-gpt\n사용방법은 Git Bash를 설치한 후 터미널을 열구 sgpt --shell 다음에 자연어를 넣게 되면 해당되는 쉘 명령어를 알려준다. 이를 실행하게 되면 유닉스 쉘을 이용하여 해당 자동화 작업에 생산성을 높일 수 있다. 현재는 한국어는 지원하지 않아 한글로 작성한 다음 번역기를 사용하여 영어로 입력해야 하고 결과를 얻게 되면 이를 실행하는 방식으로 활용한다.\n\n$ sgpt --shell 'List the contents of the current directory and display a special character at the end of each filename to indicate its file type.'"
  },
  {
    "objectID": "02-shell-filedir.html#shell-help",
    "href": "02-shell-filedir.html#shell-help",
    "title": "4  파일과 폴더 넘나들기",
    "section": "4.1 도움말 얻기",
    "text": "4.1 도움말 얻기\nls 명령어에 딸린 플래그가 많다. 일반적으로 명령어와 수반되는 플래그 사용법을 파악하는 방식이 두개 있다:\n\n--help 플래그를 명령어에 다음과 같이 전달하는 방법:\n\n$ ls --help\n\nman 명령어로 다음과 같이 매뉴얼을 읽는 방법:\n\n$ man ls \n본인 컴퓨터 환경에 따라 상기 방법 중 하나만 동작(man 혹은 --help)할 수도 있다. 아래에서 두가지 방법 모두 살펴보자.\n\n4.1.1 --help 플래그\n배쉬 내부에서 동작하도록 작성된 배쉬 명령어와 프로그램은 --help 플래그를 지원해서 명령어 혹은 프로그램을 사용하는 방식에 대한 더 많은 정보를 볼 수 있게 해 준다.\n$ ls --help\n\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\nMandatory arguments to long options are mandatory for short options too.\n  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print C-style escapes for nongraphic characters\n      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n                               '--block-size=M' prints sizes in units of\n                               1,048,576 bytes; see SIZE format below\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information);\n                               with -l: show ctime and sort by name;\n                               otherwise: sort by ctime, newest first\n\n... 중략\n\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any security context of each file\n  -1                         list one file per line.  Avoid '\\n' with -q or -b\n      --help     display this help and exit\n      --version  output version information and exit\n\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\nUnits are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n\nUsing color to distinguish file types is disabled both by default and\nwith --color=never.  With --color=auto, ls emits color codes only when\nstandard output is connected to a terminal.  The LS_COLORS environment\nvariable can change the settings.  Use the dircolors command to set it.\n\nExit status:\n 0  if OK,\n 1  if minor problems (e.g., cannot access subdirectory),\n 2  if serious trouble (e.g., cannot access command-line argument).\n\nGNU coreutils online help: <http://www.gnu.org/software/coreutils/>\nFull documentation at: <http://www.gnu.org/software/coreutils/ls>\nor available locally via: info '(coreutils) ls invocation'\n\n지원되지 않는 명령-라인 선택옵션\n지원되지 않는 선택옵션(플래그)를 사용하게 되면, ls를 비롯한 다른 프로그램은 다음과 같은 오류 메시지를 일반적으로 출력하게 된다:\n$ ls -j\nls: invalid option -- 'j'\nTry 'ls --help' for more information.\n\n\n\n4.1.2 man 명령어\nls에 대해 배울 수 있는 다른 방식은 다음 명령어를 타이핑하는 것이다.\n$ man ls\n상기 명령어를 실행하게 되면 ls 명령어와 선택 옵션에 대해 기술된 페이지로 탈바꿈하게 된다. 만약 운이 좋은 경우 상용법에 대한 예제도 포함되어 있다.\nman 페이지를 살펴보는 방법은 행단위로 이동하는데 ↑, ↓을 사용하거나 전체 페이지 단위로 건너뛰거나 아래 페이지로 이동할 경우 B, Spacebar을 사용한다. man 페이지에서 단어나 문자를 찾는 경우 / 다음에 검색할 문자 혹은 단어를 타이핑하면 된다.\nman 페이지에서 빠져 나오고자 종료(quit)하고자 한다면 Q을 누른다.\n\n웹상의 매뉴얼 페이지\n물론 명령어에 대한 도움말에 접근하는 세번째 방식이 있다: 웹브라우저를 통해서 인터넷을 검색하는 것이다. 인터넷 검색을 이용할 때, 검색쿼리에 unix man page 문구를 포함할 경우 연관된 정보를 찾는데 도움이 될 수 있다.\nGNU도 GNU 핵심 유틸리티(core GNU utilities)이 포함된 매뉴얼을 제공하고 있는데 이번 학습에 소개된 많은 명령어를 망라하고 있다.\n\n\n더많은 ls 플래그 탐색\n-l, -h 플래그를 붙여 ls 명령어를 수행하게 되면 출력결과는 어떻게 나올까?\n출력결과의 일부는 이번 학습에서 다루지 않는 속성(property)에 대한 것으로 파일 권한과 파일 소유에 대한 것이다. 그럼에도 불구하고 나머지는 유용할 것이다.\n\nls와 사용되는 -l 플래그는 long을 축약한 것으로 파일/디렉토리 명칭 뿐만 아니라 파일 크기, 최종 변경 시간 같은 부가정보가 출력된다. -h 플래그는 “human readable” 사람이 읽기 편한 형태로 파일크기를 지정한다. 예를 들어, 5369 대신에 5.3K이 화면에 출력된다.\n\n\n\n재귀적으로 시간순으로 목록 출력\nls -R 명령어는 디렉토리에 담긴 내용을 재귀적으로 화면에 출력한다; 즉, 각 단계별로 하위 디렉토리, 하위-하위 디렉토리 내용을 확면에 출력한다. ls -t 명령어는 마지막 변경된 시점순으로 가장 최근에 변경된 파일 혹은 디렉토리를 화면에 정렬해서 출력한다. ls -R -t 명령어는 어떤 순서로 화면엘 출력할까?\n힌트: ls -l 명령어를 사용해서 시간도장(timestamp)을 볼 수 있도록 전체 목록을 화면에 출력한다.\n\n각 디렉토리의 파일/디렉토리가 가장 마지막 시간 변경순으로 정렬되어 출력된다.\n\n\n여기서 홈 디렉토리가 하위 디렉토리(sub-directories)가 포함된것을 알 수 있다. 슬래쉬(/)가 붙지 않는 명칭을 갖는 것은 것은 평범한 파일(file)이다. ls 와 -F 사이에 공백이 있는 것에 주목한다: 공백이 없다면 쉘은 존재하지 않는 ls-F 명령어를 실행시키려 한다고 간주한다.\nls 명령어를 사용해서 다른 디렉토리에 들어 있는 파일과 디렉토리를 살펴볼 수 있다. ls -F Desktop 명령어를 실행해서 바탕화면 Desktop 디렉토리에 담긴 것을 살펴보자. 즉, ls 명령어는 -F 플래그, 그리고 인자(argument) Desktop으로 구성된다. Desktop 인자는 ls로 하여금 현재 작업 디렉토리가 아닌 바탕화면 디렉토리 내용을 출력하도록 지정하는 역할을 수행한다:\n$ ls -F Desktop\ndata-shell/\n작업한 출력결과는 웹사이트에서 다운로드 받아 압축을 풀어 작업하여 생성한 data-shell 디렉토리와 본인 바탕화면에 저장된 모든 파일과 하위디렉토리가 출력되어야 한다."
  },
  {
    "objectID": "02-shell-filedir.html#shell-cd-change",
    "href": "02-shell-filedir.html#shell-cd-change",
    "title": "4  파일과 폴더 넘나들기",
    "section": "4.2 cd 디렉토리 변경",
    "text": "4.2 cd 디렉토리 변경\n지금 확인했듯이, 배쉬 쉘은 파일을 계층적 파일 시스템으로 구성한다는 아이디어에 강력히 의존하고 있다. 이런 방식으로 계층적으로 파일과 디렉토리를 구조화하게 되면 본인 작업을 추적하는데 도움이 된다: 책상위에 출력한 논문 수백개를 쌓아놓은 것는 것이 가능하듯이, 홈 디렉토리에 파일 수백개를 저장하는 것도 가능하다. 하지만, 이런 접근법은 자멸하는 전략이나 마찬가지다.\ndata-shell 디렉토리가 바탕화면(Desktop)에 위치하는 것을 확인했으니, 다음 두가지를 수행할 수 있다.\n먼저, data-shell 디렉토리에 담긴 것을 살펴보자; 디렉토리 이름에 ls를 전달해서 앞서 확인된 동일한 전략을 사용하자:\n$ ls -F Desktop/data-shell\ncreatures/          molecules/          notes.txt           solar.pdf\ndata/               north-pacific-gyre/ pizza.cfg           writing/\n둘째로, 다른 디렉토리로 위치를 실제로 바꿀 수 있다. 그렇게 하면 더이상 홈 디렉토리에 있지는 않게 된다.\n작업 디렉토리를 변경하기 위해서 cd 다음에 디렉토리 이름을 사용한다. cd는 “change directory”의 두문어다. 하지만 약간 오해의 소지가 있다: 명령어 자체가 디렉토리를 변경하지는 않고, 단지 사용자가 어느 디렉토리에 있는지에 대한 쉘의 생각만 바꾼다.\n앞서 확인한 data 디렉토리로 이동해 보자. 다음 명령어를 쭉 이어서 실행하게 되면 목적지에 도달할 수 있다:\n$ cd Desktop\n$ cd data-shell\n$ cd data\n상기 명령어는 홈 디렉토리에 바탕화면(Desktop) 디렉토리로 이동하고 나서, data-shell 디렉토리로 이동하고 나서, data 디렉토리에 이동하게 된다. cd 명령어는 아무것도 출력하지는 않지만, pwd 명령어를 실행하게 되면 /Users/nelle/Desktop/data-shell/data 위치한 것을 확인하게 된다. 인자 없이 ls 명령어를 실행하게 되면, /Users/nelle/Desktop/data-shell/data 디렉토리 파일과 디렉토리를 출력하게 되는데 이유는 지금 있는 위치이기 때문이다:\n$ pwd\n/Users/nelle/Desktop/data-shell/data\n$ ls -F\namino-acids.txt   elements/     pdb/            salmon.txt\nanimals.txt       morse.txt     planets.txt     sunspot.txt\n이제 디렉토리 나무를 타서 아래로 내려가는 방법을 익혔다. 하지만 어떻게 하면 위로 올라갈 수 있을까? 다음 명령어를 시도해보자:\n$ cd data-shell\n-bash: cd: data-shell: No such file or directory\n하지만, 오류 발생! 이유가 뭘까?\n지금까지 방법으로 cd 명령어는 현재 디렉토리 내부에 하위 디렉토리만 볼 수 있다. 현재 디렉토리에서 상위 디렉토리를 볼 수 있는 다른 방법이 있다; 가장 단순한 것부터 시작해보자.\n쉘에서 한단계 위 디렉토리로 이동할 수 있는 단축키가 존재하는데 다음과 같이 생겼다:\n$ cd ..\n..은 특별한 디렉토리명인데 “현재 디렉토리를 포함하는 디렉토리”, 좀더 간결하게 표현하면 현재 디렉토리의 부모를 의미한다. 물론, cd .. 명령어를 실행하고 나서 pwd을 실행하게 되면 /Users/nelle/Desktop/data-shell로 되돌아 간다:\n$ pwd\n/Users/nelle/Desktop/data-shell\n단순히 ls 명령어를 실행하게 되면 특수 디렉토리 ..이 화면에 출력되지는 않는다. .. 디렉토리를 출력하려면 ls 명령어와 -a 플래그를 사용한다:\n$ ls -F -a\n./   .bash_profile  data/       north-pacific-gyre/  pizza.cfg  thesis/\n../  creatures/     molecules/  notes.txt            solar.pdf  writing/\n-a은 “show all”의 축약으로 모두 보여주기를 의미한다; ls로 하여금 ..와 같은 .로 시작하는 파일과 디렉토리명도 화면에 출력하게 강제한다. (/Users/nelle 디렉토리에 위치한다면, /Users 디렉토리를 지칭) .도 또다른 특별한 디렉토리로, “현재 작업 디렉토리(current working directory)”를 의미한다. 중복되어 불필요해 보일 수 있지만, 곧 .에 대한 사용법을 학습할 것이다.\n대부분의 명령라인 도구에서 플래그 다수룰 조합해서 플래그 사이 공백없이 단일 -로 사용함에 주목한다: ls -F -a은 ls -Fa와 동일하다.\n\n다른 숨은 파일들\n숨은 .., . 디렉토리에 더해서, .bash_profile 파일도 봤을 것이다. .bash_profile 파일에는 쉘 환경설정 정보가 담겨져 있다. .으로 시작하는 다른 파일과 디렉토리를 봤을 수도 있다. 이런 파일은 본인 컴퓨터의 다른 프로그램에서 환경설정을 하기 위해서 사용되는 파일과 디렉토리라고 보면 된다. . 접두어를 사용해서 ls 명령어를 사용할 때 이러한 환경설정 파일들이 터미널을 난잡하게 만드는 것을 방지하는 기능을 수행한다.\n\n\n직교(Orthogonality)\n특수 이름 .과 ..는 ls에만 속하는 것이 아니고; 모든 프로그램에서 같은 방식으로 해석된다. 예를 들어, /Users/nelle/data 디렉토리에 있을 때, ls .. 명령어는 /Users/nelle의 목록을 보여줄 것이다. 어떻게 조합되든 상관없이 동일한 의미를 가지게 될 때, 프로그래머는 이를 직교(orthogonal)한다고 부른다. 직교 시스템은 사람들이 훨씬 배우기 쉬운데, 이유는 기억하고 추적할 특수 사례와 예외가 더 적기 때문이다."
  },
  {
    "objectID": "02-shell-filedir.html#shell-path-absolute",
    "href": "02-shell-filedir.html#shell-path-absolute",
    "title": "4  파일과 폴더 넘나들기",
    "section": "4.3 상대/절대 경로",
    "text": "4.3 상대/절대 경로\n컴퓨터에 파일시스템을 돌아다니는데 기본 명령어는 pwd, ls, cd을 들 수 있다. 지금까지 사용했던 했던 방식을 벗어난 사례를 살펴보자. 프롬프트에서 cd 명령어를 디렉토리를 특정하지 않고 실행시키면 어떻게 될까?\n$ cd\n상기 명령어 실행 결과를 어떻게 확인할 수 있을까? pwd 명령어가 정답을 제시한다!\n$ pwd\n/Users/nelle\n어떤 플래그도 없는 cd 명령어는 홈디렉토리로 이동시킨다. 파일시스템에서 방향을 잃었을 경우 큰 도움이 된다.\ndata 디렉토리로 되돌아가자. 앞서 명령어 세개를 동원했지만 한방에 해당 디렉토리를 명세해서 바로 이동할 수 있다.\n$ cd Desktop/data-shell/data\npwd 와 ls -F 명령어를 실행해서 올바른 자리로 돌아왔는지 확인하자. data 디렉토리에서 한단계 위로 올라가려고 하면 cd .. 명령어를 사용했다. 현재 디렉토리 위치에 관계없이 특정 디렉토리로 이동할 수 있는 다른 방식도 있다.\n지금까지 디렉토리명을 명세할 때 상대경로(relative paths)를 사용했다. ls 혹은 cd와 같은 명령어와 상대 경로를 사용할 때는 시스템이 파일시스템의 루트 위치(/)에서 차근차근 찾기보다 해당 위치를 현재 위치를 찾아 명령을 실행시킨다.\n하지만, / 슬래쉬로 표현되는 루트 디렉토리에서 전체 경로를 추가한 절대경로(absolute path)로 명세하는 것도 가능하다. / 슬래쉬는 컴퓨터가 루트 디렉토리에서 경로를 탐색하도록 지시한다. 따라서, 명령어를 실행할 때 현재 디렉토리 위치에 관계없이 정확한 특정 디렉토리를 항상 명세하게 된다.\n절대경로를 사용하면 파일 시스템에 어느 위치에서든 있던 관계없이 data-shell 디렉토리로 이동할 수 있다. 절대경로를 찾기 쉬운 방법은 pwd 명령어를 사용해서 필요한 디렉토리 정보를 추출하고 이를 활용해서 data-shell 디렉토리로 이동한다.\n$ pwd\n/Users/nelle/Desktop/data-shell/data\n$ cd /Users/nelle/Desktop/data-shell\npwd와 ls -F 명령어를 실행하게 되면 원하던 디렉토로리 제대로 이동되었는지 확인이 가능하다.\n\n단축(Shortcuts) 두개 더\n쉘을 ~ (틸드) 문자를 경로의 시작으로 해석해서 “현재 사용자 홈 디렉토리”를 의미하게 된다. 예를 들어, Nelle의 홈 디렉토리가 /Users/nelle이라면, ~/data은 /Users/nelle/data와 동치가 된다. 경로명에 첫 문자로 있을 때만 이것이 동작한다: here/there/~/elsewhere이 here/there/Users/nelle/elsewhere이 되는 것은 아니다. 따라서, cd ~을 홈 디렉토리로 변경하는데 사용한다.\n또 다룩 단축은 대쉬(-) 문자다. cd는 - 문자를 지금 있는 이전 디렉토리로 변역한다. 이 방법이 전체 경로를 기억하고 있다가 타이핑하는 것보다 더 빠르다. 이를 통해 디렉토리를 앞뒤로 매우 효율적으로 이동하게 된다. cd .. 와 cd - 명령어 사이 차이점은 전자(cd ..)는 위로, 후자(cd -)는 아래로 이동하게 위치를 바꾸는 역할을 수행한다. TV 리모컨의 이전 채널 기능으로 생각하면 편하다.\n\n\n동일 작업을 수행하는 수많은 방법 - 절대 경로 vs. 상대 경로\n/home/amanda/data/ 디렉토리에서 시작할 때, Amanda가 홈디렉토리인 /home/amanda로 돌아가도록 사용할 수 있는 명령어를 아래에서 선택하시요.\n\ncd .\ncd /\ncd /home/amanda\ncd ../..\ncd ~\ncd home\ncd ~/data/..\ncd\ncd ..\n\n\n해답 풀이 1. No: .은 현재 디렉토리를 나타냄. 2. No: /는 루트 디렉토리를 나타냄. 3. No: Amanda 홈 디렉토리른 /Users/amanda임. 4. No: ../..은 두 단계 거슬러 올라간다; 즉, /Users에 도달함. 5. Yes: ~은 사용자 홈 디렉토리를 나타남; 이 경우 /Users/amanda이 됨. 6. No: 현재 디렉토리 내부에 home 디렉토리가 존재하는 경우 home 디렉토리로 이동하게 됨. 7. Yes: 불필요하게 복잡하지만, 정답이 맞음. 8. Yes: 사용자 홈 디렉토리로 이동할 수 있는 단축키를 사용함. 9. Yes: 한 단계 위로 이동.\n\n\n\n상대경로 해결\n만약 pwd 명령어를 쳤을 때, 화면에 /Users/thing이 출력된다면, ls -F ../backup은 무엇을 출력할까요?\n\n../backup: No such file or directory\n2012-12-01 2013-01-08 2013-01-27\n2012-12-01/ 2013-01-08/ 2013-01-27/\noriginal/ pnas_final/ pnas_sub/\n\n\n\n\n도전과제 질문 파일 시스템\n\n\n\n해답 풀이\n\nNo: backup in /Users 디렉토리 내부에 backup 디렉토리가 있다. \nNo: Users/thing/backup 디렉토리에 담긴 것을 출력한다. 하지만 ..으로 한 단계 상위 레벨 위를 찾도록 요청했다.\nNo: 이전 해답을 참조한다.\nYes: ../backup/ 은 /Users/backup/을 지칭한다.\n\n\n\n\nls 독해 능력\n상기 그림(도전과제 질문에 사용되는 파일 시스템)에 나온 디렉토리 구조를 상정한다. 만약 pwd 명령어를 쳤을 때 화면에 /Users/backup이 출력되고, -r 인자는 ls 명령어가 역순으로 화면에 출력하게 한다면, 어떤 명령어가 다음을 화면에 출력할까요?\npnas_sub/ pnas_final/ original/\n1.  `ls pwd`\n2.  `ls -r -F`\n3.  `ls -r -F /Users/backup`\n4.  위 #2 혹은 #3, 하지만, #1은 아님.\n\n해답풀이 1. No: pwd 는 디렉토리 명칭이 아님. 2. Yes: 디렉토리 인자가 없는 ls 명령어는 현재 디렉토리의 파일과 디렉토리를 화면에 출력함. 3. Yes: 절대 경로를 명시적으로 사용. 4. Correct: 상기 해설 참조."
  },
  {
    "objectID": "02-shell-filedir.html#nelle-filedir",
    "href": "02-shell-filedir.html#nelle-filedir",
    "title": "4  파일과 폴더 넘나들기",
    "section": "4.4 사례: 파일 구성",
    "text": "4.4 사례: 파일 구성\n파일과 디렉토리에 대해서 알았으니, Nelle은 단백질 분석기가 생성하는 파일을 구성할 준비를 마쳤다. 우선 north-pacific-gyre 디렉토리를 생성해서 데이터가 어디에서 왔는지를 상기하도록 한다. 2012-07-03 디렉토리를 생성해서 시료 처리를 시작한 날짜를 명기했다. Nelle은 conference-paper와 revised-results같은 이름을 사용하곤 했다. 하지만, 몇년이 지난 후에 이해하기 어렵다는 것을 발견했다. (마지막 지푸라기는 revised-revised-results-3 디렉토리를 본인이 생성했다는 것을 발견했을 때였다.)\n\n출력결과 정렬\nNelle은 월과 일에 0을 앞에 붙여 디렉토리를 “년-월-일(year-month-day)” 방식으로 이름지었다. 왜냐하면 쉘이 알파벳 순으로 파일과 디렉토리 이름을 화면에 출력하기 때문이다. 만약 월이름을 사용한다면, 12월(December)이 7월(July) 앞에 위치할 것이다: 만약 앞에 0을 붙이지 않으면 11월이 7월 앞에 올 것이다.\n\n각각의 물리적 시료는 “NENE01729A”처럼 10자리 중복되지 않는 ID로 연구실 관례에 따라 표식을 붙였다. 시료의 장소, 시간, 깊이, 그리고 다른 특징을 기록하기 위해서 수집 기록에 사용된 것과 동일하다. 그래서 이를 각 파일 이름으로 사용하기로 결정했다. 분석기 출력값이 텍스트 형식이기 때문에 NENE01729A.txt, NENE01812A.txt, … 같이 확장자를 붙였다. 총 1,520개 파일 모두 동일한 디렉토리에 저장되었다.\n이제 data-shell 현재 작업 디렉토리에서 Nelle은 다음 명령어를 사용해서, 무슨 파일이 있는지 확인할 수 있다:\n$ ls north-pacific-gyre/2012-07-03/\n엄청나게 많은 타이핑이지만 탭 자동완성(tab completion)을 통해 쉘에게 많은 일을 시킬 수도 있다. 만약 다음과 같이 타이핑하고:\n$ ls nor\n그리고 나서 탭(키보드에 탭 키)을 누르면, 자동으로 쉘이 디렉토리 이름을 자동완성 시켜준다:\n$ ls north-pacific-gyre/\n탭을 다시 누르면, Bash가 명령문에 2012-07-03/을 추가하는데, 왜냐하면 유일하게 가능한 자동완성조건이기 때문이다. 한번더 탭을 누려면 아무것도 수행하지 않는다. 왜냐하면 1520가지 경우의 수가 있기 때문이다; 탭을 두번 누르면 모든 파일 목록을 가져온다. 이것을 탭 자동완성(tab completion)이라고 부르고, 앞으로도 다른 많은 툴에서도 많이 볼 것이다."
  },
  {
    "objectID": "02-shell-filedir.html#쉘-명령-일반구문",
    "href": "02-shell-filedir.html#쉘-명령-일반구문",
    "title": "4  파일과 폴더 넘나들기",
    "section": "4.5 쉘 명령 일반구문",
    "text": "4.5 쉘 명령 일반구문\n지금까지 명령어, 선택옵션 및 명령인자를 살펴보았지만 몇 가지 용어를 공식화하는 것이 필요하다. 아래 쉘 명령어를 일반적인 쉘 명령어 사례로 간주하고 구성요소별로 분해하면 다음과 같다:\n\nls -F /\n\n\n\n\n\n\n상기 쉘 명령어는 ls 명령어, 선택옵션 -F, 명령인자 /로 구성되어 있다. 이미 대시(-) 하나 또는 대시 두개(--)가 명령의 동작을 변경한다. 명령인자는 명령에 작업할 대상(예: 파일 및 디렉터리)을 지정해준다. 선택옵션과 명령인자를 매개변수라고 부른다. 쉘 명령은 둘 이상의 선택옵션과 둘 이상의 명령인자를 사용하여 실행할 수도 있지만, 쉘 명령어 작성에 항상 선택옵션과 명령인자가 필요한 것은 아니다.\n선택옵션을 스위치(switches) 또는 플래그(flag)라고 부르는 경우도 있다. 특히 명령인자가 없는 선택옵션을 스위치나 플래그로 부르지만, 선택옵션이라는 용어를 통일해서 사용한다.\n쉘 명령어 각 부분은 공백으로 구분된다. ls와 -F 사이에 공백을 생략하는 경우 공백을 생략하면 쉘은 ls-F라는 명령을 찾지만 이런 명령어는 존재하지 않는다. 쉘 명령어에서 대소문자 구분도 중요하다. 예를 들어 ls -s는 파일 및 디렉터리의 크기를 이름과 함께 표시하지반, ls -S는 아래와 같이 파일과 디렉터리를 크기별로 정렬한다:\n\ncd shell-lesson-data\nls -s exercise-data\n\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 proteins   4 writing\nls -s가 반환하는 크기는 블록 단위로 운영 체제마다 다르게 정의되어 있으므로 예제와 동일한 수치를 얻지 못할 수도 있다. 참고로 윈도우 10 운영체제에서 작성되었다.\nls -S는 파일과 디렉토리를 크기별로 정렬한다.\n\nls -S exercise-data\n\nanimal-counts  creatures  proteins  writing  numbers.txt\n이 모든 것을 종합하면 위의 ls -F / 명령은 루트 디렉터리 /에 있는 파일 및 디렉터리 목록을 출력한다. 참고로 윈도우 10 환경에 WSL 우분투 리눅스를 환경 사례다. 사용자의 운영체제에 따라 달리 나올 수도 있다.\n\nls -F /\n\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/"
  },
  {
    "objectID": "03-shell-create.html#파일과-디렉토리를-위한-좋은-명칭",
    "href": "03-shell-create.html#파일과-디렉토리를-위한-좋은-명칭",
    "title": "5  파일과 디렉토리 작업",
    "section": "5.1 파일과 디렉토리를 위한 좋은 명칭",
    "text": "5.1 파일과 디렉토리를 위한 좋은 명칭\n명령라인으로 작업할 때, 복잡하고 어려운 파일과 디렉토리는 삶을 질을 현격히 저하시킨다. 다음에 파일 명칭에 대한 유용한 팁이 몇개 있다.\n\n공백(whitespaces)을 사용하지 마라 공백은 이름을 의미있게 할 수도 있지만, 공백이 명령라인 인터페이스에서 인자를 구별하는데 사용되기에, 파일과 디렉토리 명에서는 피하는 것이 상책이다. 공백 대신에 - 혹은 _ 문자를 사용한다.\n대쉬(-)로 명칭을 시작하지 않는다. 명령어가 -으로 시작되는 명칭을 선택옵션으로 처리하기 때문이다.\n명칭에 문자, 숫자, . (마침표), - (대쉬) and _ (밑줄)을 고수한다. 명령라인 인터페이스에서 다른 많은 문자는 특별한 의미를 갖는다. 학습을 진행하면서 이들 중 일부를 배울 것이다. 일부 특수 문자는 명령어가 기대했던 대로 동작하지 못하게 하거나, 심한 경우 데이터 유실을 야기할 수도 있다.\n\n공백을 포함하거나 알파벳이 아닌 문자를 갖는 파일명이나 디렉토리명을 굳이 지정할 필요가 있다면, 인용부호(\"\")로 파일명이나 디렉토리명을 감싸야 한다."
  },
  {
    "objectID": "03-shell-create.html#shell-move-file",
    "href": "03-shell-create.html#shell-move-file",
    "title": "5  파일과 디렉토리 작업",
    "section": "5.2 파일과 폴더 이동",
    "text": "5.2 파일과 폴더 이동\ndraft.txt가 특별한 정보를 제공하는 이름이 아니어서 mv를 사용하여 파일 이름을 변경하자. mv는 “move”의 줄임말이다:\n$ mv thesis/draft.txt thesis/quotes.txt\n첫번째 매개변수는 mv 명령어에게 이동하려는 대상을, 두번째 매개변수는 어디로 이동되는지를 나타낸다. 이번 경우에는 thesis/draft.txt 파일을 thesis/quotes.txt으로 이동한다. 이렇게 파일을 이동하는 것이 파일 이름을 바꾸는 것과 동일한 효과를 가진다. 아니나 다를까, ls 명령어를 사용하여 확인하면 thesis 디렉토리에는 이제 quotes.txt 파일만 있음을 확인할 수 있다:\n$ ls thesis\nquotes.txt\n목표 파일명을 명세할 때 주의를 기울일 필요가 있다. 왜냐하면, mv 명령어는 동일 명칭을 갖는 어떤 기존 파일도 아주 조용히 덮어 써버리는 재주가 있어 데이터 유실에 이르게 된다. 부가적인 옵션 플래그, mv -i (즉 mv --interactive)를 사용해서 덮어쓰기 전에 사용자가 확인하도록 mv 명령어를 활용할 수도 있다.\n일관성을 갖고 있어서, mv는 디렉토리에도 동작한다 — 별도 mvdir 명령어는 없다.\nquotes.txt 파일을 현재 작업 디렉토리로 이동합시다. mv를 다시 사용한다. 하지만 이번에는 두번째 매개변수로 디렉토리 이름을 사용해서 파일이름을 바꾸지 않고, 새로운 장소에 놓는다. (이것이 왜 명령어가 “move(이동)”으로 불리는 이유다.) 이번 경우에 사용되는 디렉토리 이름은 앞에서 언급한 특수 디렉토리 이름 . 이다.\n$ mv thesis/quotes.txt .\n과거에 있던 디렉토리에서 파일을 현재 작업 디렉토리로 옮긴 효과가 나타난다. ls 명령어가 thesis 디렉토리가 비였음을 보여준다:\n$ ls thesis\n더 나아가, ls 명령어를 인자로 파일 이름 혹은 디렉토리 이름과 함께 사용하면, 그 해당 파일 혹은 디렉토리만 화면에 보여준다. 이렇게 사용하면, quotes.txt 파일이 현재 작업 디렉토리에 있음을 볼 수 있다:\n$ ls quotes.txt\nquotes.txt\n\n현재 폴더로 이동하기\n다음 명령어를 실행한 후에, 정훈이는 sucrose.dat, maltose.dat 파일을 잘못된 폴더에 넣은 것을 인지하게 되었다:\n$ ls -F\n analyzed/ raw/\n$ ls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\n$ cd raw/\n해당 파일을 현재 디렉토리(즉, 현재 사용자가 위치한 폴더)로 이동시키도록 아래 빈칸을 채우시오:\n$ mv ___/sucrose.dat  ___/maltose.dat ___\n\n$ mv ../analyzed/sucrose.dat ../analyzed/maltose.dat .\n.. 디렉토리는 부모 디렉토리(즉, 현재 디렉토리에서 상위 디렉토리를 지칭) . 디렉토리는 현재 디렉토리를 지칭함을 상기한다.\n\n\ncp 명령어는 mv 명령어와 거의 동일하게 동작한다. 차이점은 이동하는 대신에 복사한다는 점이다. 인자로 경로를 두개 갖는 ls 명령어로 제대로 작업을 했는지 확인할 수 있다. 대부분의 유닉스 명령어와 마찬가지로, ls 명령어로 한번 경로 다수를 전달할 수도 있다:\n$ cp quotes.txt thesis/quotations.txt\n$ ls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\n복사를 제대로 수행했는지 증명하기 위해서, 현재 작업 디렉토리에 있는 quotes.txt 파일을 삭제하고 나서, 다시 동일한 ls 명령어를 실행한다.\n$ rm quotes.txt\n$ ls quotes.txt thesis/quotations.txt\nls: cannot access quotes.txt: No such file or directory\nthesis/quotations.txt\n이번에는 현재 디렉토리에서 quotes.txt 파일은 찾을 수 없지만, 삭제하지 않은 thesis 폴더의 복사본은 찾아서 보여준다.\n\n파일명이 뭐가 중요해?\nNelle의 파일 이름이 “무엇.무엇”으로 된 것을 알아챘을 것이다. 이번 학습에서, 항상 .txt 확장자를 사용했다. 이것은 단지 관례다: 파일 이름을 mythesis 혹은 원하는 무엇이든지 작명할 수 있다. 하지만, 대부분의 사람들은 두 부분으로 구분된 이름을 사용하여 사람이나 프로그램이 다른 유형의 파일임을 구분하도록 돕는다. 이름에 나온 두번째 부분을 파일 확장자(filename extension)라고 부르고, 파일에 어떤 유형의 데이터가 담고 있는지 나타낸다. .txt 확장자는 텍스트 파일임을, .pdf는 PDF 문서임을, .cfg 확장자는 어떤 프로그램에 대한 구성정보를 담고 있는 형상관리 파일임을 내고, .png 확장자는 PNG 이미지 등등을 나타낸다.\n단지 관습이기는 하지만 중요하다. 파일은 바이트(byte) 정보를 담고 있다: PDF 문서, 이미지, 등에 대해서 규칙에 따라 바이트를 해석하는 것은 사람과 작성된 프로그램에 맡겨졌다.\nwhale.mp3처럼 고래 PNG 이미지 이름을 갖는 파일을 고래 노래의 음성파일로 변환하는 마술은 없다. 설사 누군가 두번 클릭할 때, 운영체제가 음악 재생기로 열어 실행할 수는 있지만 동작은 되지 않을 것이다.\n\n\n파일 이름 바꾸기\n데이터를 분석하는데 필요한 통계 검정 목록을 담고 있는 .txt 파일을 현재 디렉토리에 생성했다고 가정하자; 파일명은 statstics.txt. 파일을 생성하고 저장한 후에 곰곰히 생각해 보니 파일명 철자가 틀린 것을 알게 되었다! 틀린 철자를 바로잡고자 하는데, 다음 중 어떤 명령어를 사용해야 하는가? 1. cp statstics.txt statistics.txt 2. mv statstics.txt statistics.txt 3. mv statstics.txt . 4. cp statstics.txt .\n\n해답 1. No. 철자오류가 수정된 파일이 생성되지만, 철자가 틀린 파일도 디렉토리에 여전히 존재하기 때문에 삭제작업이 필요하다. 2. Yes, 이 명령어를 통해서 파일명을 고칠 수 있다. 3. No, 마침표(.)는 파일을 이동할 디렉토리를 나타내지 새로운 파일명을 제시하고 있지는 않고 있다; 동일한 파일명은 생성될 수 없다. 4. No, 마침표(.)는 파일을 복사할 디렉토리를 나타내지 새로운 파일명을 제시하고 있지는 않고 있다; 동일한 파일명은 생성될 수 없다.\n\n\n\n이동과 복사 아래 보여진 일련의 명령문에 뒤에 ls명령어의 출력값은 무엇일까요?\n$ pwd\n/Users/jamie/data\n$ ls\nproteins.dat\n$ mkdir recombine\n$ mv proteins.dat recombine/\n$ cp recombine/proteins.dat ../proteins-saved.dat\n$ ls\n\nproteins-saved.dat recombine\nrecombine\nproteins.dat recombine\nproteins-saved.dat\n\n\n해답 /Users/jamie/data 디렉토리에서 출발해서, recombine 이름의 디렉토리를 새로 생성한다. 두번째 행은 proteins.dat 파일을 새로 만든 폴더 recombine으로 이동(mv) 시킨다. 세번째 행은 방금전에 이동한 파일에 대한 사본을 생성시킨다. 여기서 조금 까다로운 점은 파일이 복사되는 디렉토리다. .. 이 의미하는 바가 “한단계 위로 이동”하라는 의미라서, 복사되는 파일은 이제 /Users/jamie 디렉토리에 위치하게 됨을 상기한다. .. 이 의미하는 바는 복사되는 파일 위치에 대한 것이 아니라 현재 작업 디렉토리에 대한 것으로 해석됨에 유의한다. 그래서, 그래서, ls 명령어를 사용해서 보여지게 되는 것은 (/Users/jamie/data에 있기 때문에) recombine 폴더가 된다.\n\nNo, 상기 해설을 참조한다. proteins-saved.dat 데이터는 /Users/jamie 폴더에 위치한다.\nYes\nNo, 상기 해설을 참조한다. proteins.dat 데이터는 /Users/jamie/data/recombine 폴더에 위치한다.\nNo, 상기 해설을 참조한다. proteins-saved.dat 데이터는 /Users/jamie 폴더에 위치한다."
  },
  {
    "objectID": "03-shell-create.html#shell-moving-multiple",
    "href": "03-shell-create.html#shell-moving-multiple",
    "title": "5  파일과 디렉토리 작업",
    "section": "5.3 다수 파일과 폴더 작업",
    "text": "5.3 다수 파일과 폴더 작업\n\n다수 파일을 복사하기 이번 연습문제에서는 data-shell/data 디렉토리에서 명령어를 테스트한다. 아래 예제에서, 파일명 다수와 디렉토리명이 주어졌을 떄 cp 명령어는 어떤 작업을 수행하는가?\n$ mkdir backup\n$ cp amino-acids.txt animals.txt backup/\n아래 예제에서, 3개 혹은 그 이상의 파일명이 주어졌을 때 cp 명령어는 어떤 작업을 수행하는가?\n$ ls -F\namino-acids.txt  animals.txt  backup/  elements/  morse.txt  pdb/  planets.txt  salmon.txt  sunspot.txt\n$ cp amino-acids.txt animals.txt morse.txt \n\n해답 하나이상 파일명 다음에 디렉토리명이 주어지게 되면(즉, 목적지 디렉토리는 마지막 인자에 위치해야 한다.), cp 명령어는 파일을 해당 디렉토리에 복사한다.\n연달아 파일명이 세게 주어지면, cp 명령어는 오류를 던지는데 이유는 마지막 인자로 디렉토리를 기대했기 때문이다.\ncp: target ‘morse.txt’ is not a directory\n\n\n\n와일드 카드(Wildcards)\n*는 와일드카드(wildcard)다. 와일드카드는 0 혹은 그 이상의 문자와 매칭되서, *.pdb은 ethane.pdb, propane.pdb 등등에 매칭한다. 반면에, p*.pdb은 propane.pdb와 pentane.pdb만 매칭하는데, 맨 앞에 ’p’로 시작되는 파일명만 일치하기만 하면 되기 때문이다.\n?도 또한 와일드카드지만 단지 단일 문자만 매칭한다. 이것이 의미하는 바는 p?.pdb은 pi.pdb\n혹은 p5.pdb을 매칭하지만 (molecules 디렉토리에 두 파일이 있다면), propane.pdb은 매칭하지 않는다. 한번에 원하는 수만큼 와일드카드를 사용할 수 있다. 예를 들어, p*.p?*는 ‘p’로 시작하고’.’과 ‘p’, 그리고 최소 한자의 이상의 문자로 끝나는 임의의 문자열을 매칭한다고 표현할 수 있는데 ‘?’이 한 문자를 매칭해야하고 마지막’*‘은 끝에 임의의 문자숫자와 매칭할 수 있기 때문이다. 그래서 p*.p?*은 preferred.practice과 심지어 p.pi도 매칭한다(첫번째’*‘은 어떤 문자도 매칭할 수가 없음). 하지만 quality.practice은 매칭할 수 없는데 이유는 ’p’로 시작하지 않고, preferred.p도 매칭할 수 없는데 ’p’ 다음에 최소 하나의 문자가 필요한데 없기 때문이다.\n쉘이 와일드카드를 봤을 때, 요청된 명령문을 시작하기 전에 와일드카드를 확장하여 매칭할 파일 이름 목록을 생성한다. 예외로, 와일드카드 표현식이 어떤 파일과도 매칭되지 않게되면, 배수는 명령어에 인자로 표현식을 있는 그대로 전달한다. 예를 들어, molecules 디렉토리(.pdb 확장자로 끝나는 파일만 모여있다.)에 ls *.pdf을 타이핑하게 되면, *.pdf으로 불리는 파일이 없다고 오류 메시지를 출력한다. 하지만, 일반적으로 wc과 ls 명령어는 와일드카드 표현식과 매칭되는 파일명 목록을 보게 되고 와일드카드 자체가 아니다. 다른 프로그램은 아니지만, 쉘은 와일드카드를 확장한 것을 다룬다는 점에서 직교 설계(orthogonal design)의 또 다른 사례로 볼 수 있다.\n\n\n와일드카드 추가 문제\n정훈이는 미세조정(calibration), 원본 데이터(dataset), 데이터 설명 데이터를 디렉토리에 보관하고 있다:\n2015-10-23-calibration.txt\n2015-10-23-dataset1.txt\n2015-10-23-dataset2.txt\n2015-10-23-dataset_overview.txt\n2015-10-26-calibration.txt\n2015-10-26-dataset1.txt\n2015-10-26-dataset2.txt\n2015-10-26-dataset_overview.txt\n2015-11-23-calibration.txt\n2015-11-23-dataset1.txt\n2015-11-23-dataset2.txt\n2015-11-23-dataset_overview.txt\n또 다른 견학여행을 떠나기 전에, 정훈이는 데이터를 백업하고 일부 데이터를 랩실 동료 기민에게 보내고자 한다. 정훈이는 백업과 전송 작업을 위해서 다음 명령어를 사용한다:\n$ cp *dataset* /backup/datasets\n$ cp ____calibration____ /backup/calibration\n$ cp 2015-____-____ ~/send_to_bob/all_november_files/\n$ cp ____ ~/send_to_bob/all_datasets_created_on_a_23rd/\n정훈이가 빈칸을 채우도록 도움을 주세요. > 해답 > > > $ cp *calibration.txt /backup/calibration > $ cp 2015-11-* ~/send_to_bob/all_november_files/ > $ cp *-23-dataset* ~send_to_bob/all_datasets_created_on_a_23rd/ >\n\n\n디렉토리와 파일 조직화\n정훈이가 프로젝트 작업을 하고 있는데, 작업 파일이 그다지 잘 조직적으로 정리되어 있지 않음을 알게 되었다:\n$ ls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nfructose.dat 와 sucrose.dat 파일은 자료분석 결과 산출된 출력결과를 담고 있다. 이번 학습에서 배운 어떤 명령어를 실행해야, 아래 명령어를 실행했을 때 다음에 보여지는 출력을 생성할까요?\n$ ls -F\nanalyzed/   raw/\n$ ls analyzed\nfructose.dat    sucrose.dat\n\n해답\nmv *.dat analyzed\n정훈이는 analyzed 디렉토리에 fructose.dat, sucrose.dat 파일을 이동시킬 필요가 있다. 쉘에서 현재 디렉토리에서 *.dat 와일드카드가 .dat 확장자를 갖는 모든 파일을 매칭한다. mv 명령어가 .dat 확장자를 갖는 파일을 analyzed 디렉토리로 이동시킨다.\n\n\n\n폴더 구조를 복사하지만, 파일을 복사하지 말자.\n새로운 실험을 시작해 보자. 데이터 파일 없이 이전 실험에게 만들었던 파일 구조만 복제하자. 그렇게 하면 새로운 데이터를 쉽게 추가할 수 있게 된다. ‘2016-05-18-data’ 디렉토리에 data 폴더로 raw와 processed가 있는데, 각자 데이터 파일이 담겨있다.\n목적은 2016-05-18-data 폴더를 2016-05-20-data 폴더로 복사하는 것인데 복사된 폴더에는 모든 데이터 파일을 제거해야 된다. 다음 명령어 집합 중 어떤 명령어 집합이 상기 목적을 달성할까요? 다른 명령어 집합은 무슨 작업을 수행하는 것일가?\n$ cp -r 2016-05-18-data/ 2016-05-20-data/\n$ rm 2016-05-20-data/raw/*\n$ rm 2016-05-20-data/processed/*\n$ rm 2016-05-20-data/raw/*\n$ rm 2016-05-20-data/processed/*\n$ cp -r 2016-05-18-data/ 2016-5-20-data/\n$ cp -r 2016-05-18-data/ 2016-05-20-data/\n$ rm -r -i 2016-05-20-data/\n\n해답\n첫번째 명령어들이 해당 목적을 달성한다. 먼저 재귀적으로 데이터 폴더를 복사한다. 그리고 나서 rm 명령어 두번 사용해서 복사한 디렉토리의 모든 파일을 제거한다. 쉘은 * 와일드카드로 매칭되는 모든 파일과 하위디렉토리를 확장하도록 한다.\n두번째 명령어들은 순서가 잘못되었다: 복사하지 않는 파일을 샂게하고 나서 재귀 복사 명령어로 디렉토리를 복사했다.\n세번째 명령어도 목적을 달성하는데, 시간이 다소 소요된다: 첫번째 명령어가 디렉토리를 재귀적으로 복사하지만, 두번째 명령어는 인터랙티브하게 각 파일과 디렉토리에 대한 확인하는 과정을 거쳐 삭제를 하게 되어 시간이 추가로 소요된다."
  },
  {
    "objectID": "06-shell-script.html#nelle-script",
    "href": "06-shell-script.html#nelle-script",
    "title": "8  쉘 스크립트",
    "section": "8.1 Nelle 파이프라인: 스크립트 생성하기",
    "text": "8.1 Nelle 파이프라인: 스크립트 생성하기\nNelle의 지도교수는 모든 분석결과가 재현가능해야 된다는 고집을 갖고 있다. 모든 분석 단계를 담아내는 가장 쉬운 방법은 스크립트에 있다. 편집기를 열어서 다음과 같이 작성한다:\n# 데이터 파일별로 통계량 계산.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats $datafile stats-$datafile\ndone\ndo-stats.sh 이름으로된 파일에 저장해서, 다음과 같이 타이핑해서 첫번째 단계 분석을 다시 실행할 수 있게 되었다:\n$ bash do-stats.sh NENE*[AB].txt\n또한 다음과 같이도 할 수 있다:\n$ bash do-stats.sh NENE*[AB].txt | wc -l\n그렇게 해서 출력은 처리된 파일 이름이 아니라 처리된 파일의 숫자만 출력된다.\nNelle의 스크립트에서 주목할 한가지는 스크립트를 실행하는 사람이 무슨 파일을 처리할지를 결정하게 하는 것이다. 스크립트를 다음과 같이 작성할 수 있다:\n# Site A, Site B 데이터 파일에 대한 통계량 계산\nfor datafile in NENE*[AB].txt\ndo\n    echo $datafile\n    bash goostats $datafile stats-$datafile\ndone\n장점은 이 스크립트는 항상 올바른 파일만을 선택한다: ‘Z’파일을 제거했는지 기억할 필요가 없다. 단점은 항상 이 파일만을 선택한다는 것이다 — 모든 파일(’Z’를 포함하는 파일), 혹은 남극 동료가 생성한 ’G’, ‘H’ 파일에 대해서 스크립트를 편집하지 않고는 실행할 수 없다. 좀더 모험적이라면, 스크립트를 변경해서 명령-라인 매개변수를 검증해서 만약 어떠한 매개변수도 제공되지 않았다면 NENE*[AB].txt을 사용하도록 바꿀수도 있다. 물론, 이런 접근법은 유연성과 복잡성 사이에 서로 대립되는 요소 사이의 균형, 즉 트레이드오프(trade-off)를 야기한다.\n\n쉘 스크립트의 변수\nmolecules 디렉토리에서, 다음 명령어를 포함하는 script.sh라는 쉘스크립트가 있다고 가정한다:\nhead -n $2 $1\ntail -n $3 $1\nmolecules 디렉토리에서 다음 명령어를 타이핑한다:\nbash script.sh '*.pdb' 1 1\n다음 출력물 결과 중 어떤 결과가 나올 것으로 예상하나요? 1. molecules 디렉토리에 있는 *.pdb 확장자를 갖는 각 파일의 첫번줄과 마지막줄 사이 모든 줄을 출력. 2. molecules 디렉토리에 있는 *.pdb 확장자를 갖는 각 파일의 첫번줄과 마지막 줄을 출력. 3. molecules 디렉토리에 있는 각 파일의 첫번째와 마지막 줄을 출력. 4. *.pdb 를 감싸는 인용부호로 오류가 발생.\n\n해답 정답은 2.\n특수 변수 $1, $2, $3은 스크립트에 명령라인 인수를 나타낸다. 따라서 실행되는 명령어는 다음과 같다:\n$ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n$ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n인용부호로 감싸져서 쉘이 '*.pdb'을 명령라인에서 확장하지 않는다. 이를 테면, 스크립트의 첫번째 인자는 '*.pdb'으로 전달되어 스크립트 내부에서 확장되어 head와 tail 명령어를 실행시키게 된다.\n\n\n\n주어진 확장자 내에서 가장 긴 파일을 찾아낸다 인자로 디렉토리 이름과 파일이름 확장자를 갖는 longest.sh이름의 쉘 스크립트를 작성해서, 그 디렉토리에서 해당 확장자를 가지는 파일 중에 가장 긴 줄을 가진 파일이름을 화면에 출력하세요. 예를 들어, 다음은\n$ bash longest.sh /tmp/data pdb\n/tmp/data 디렉토리에 .pdb 확장자를 가진 파일 중에 가장 긴 줄을 가진 파일이름을 화면에 출력한다.\n\n해답\n# 쉘 스크립트는 다음 두 인자를 갖는다: \n#    1. 디렉토리명\n#    2. 파일 확장자\n# 해당 디렉토리에서 파일 확장자와 매칭되는 가장 길이가 긴 파일명을 출력한다.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\n\n\n\n스크립트 독해 능력\n이번 문제에 대해, 다시 한번 data-shell/molecules 디렉토리에 있다고 가정한다. 지금까지 생성한 파일에 추가해서 디렉토리에는 .pdb 파일이 많다. 만약 다음 행을 담고 있는 스크립트로 bash example.sh *.dat을 실행할 때, example.sh 이름의 스크립트가 무엇을 수행하는지 설명하세요:\n# 스크립트 1\necho *.*\n# 스크립트 2\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\n# 스크립트 3\necho $@.pdb\n\n해답 스크립트 1은 파일명에 구두점(.)이 포함된 모든 파일을 출력한다.\n스크립트 2는 파일 확장자가 매칭되는 첫 3 파일의 내용을 화면에 출력시킨다. 쉘이 인자를 example.sh 스크립트에 전달하기 전에 와일드카드를 확장시킨다.\n스크립트 3은 .pdb로 끝나는 스크립트의 모든 인자(즉, 모든 .pdb 파일)를 화면에 출력시킨다.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n스크립트 디버깅\nNelle 컴퓨터 north-pacific-gyre/2012-07-03 디렉토리의 do-errors.sh 파일에 다음과 같은 스크립트가 저장되었다고 가정하자.\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats $datafile stats-$datafile\ndone\n다음을 실행하게 되면:\n$ bash do-errors.sh NENE*[AB].txt\n출력결과는 아무 것도 없다. 원인을 파악하고자 -x 선택옵션을 사용해서 스크립트를 재실행시킨다:\nbash -x do-errors.sh NENE*[AB].txt\n보여지는 출력결과는 무엇인가? 몇번째 행에서 오류가 발생했는가? > 해답 > -x 플래그를 사용하면 디버그 모드에서 bash를 실행시키게 된다. > 각 명령어를 행단위로 실행시키고 출력결과를 보여주는데, 오류를 특정하는데 도움이 된다. > 이번 예제에서 echo 명령어는 아무 것도 출력하지 않는 것을 볼 수 있다. > 루프 변수명의 철자가 잘못 타이핑 되어 있다. > datfile 변수가 존재하지 않아서 빈 문자열이 반환되었다."
  },
  {
    "objectID": "07-shell-find.html",
    "href": "07-shell-find.html",
    "title": "9  파일, 텍스트, 폴더 찾기",
    "section": "",
    "text": "“구글(Google)”을 “검색”을 의미하는 동사로 많은 분들이 사용하는 것처럼 유닉스 프로그래머는 “grep”을 동일하게 사용한다. grep은 “global/regular expression/print(전역/정규표현식/출력)”의 축약어로 초기 유닉스 편집기에서 일반적인 일련의 연산작업을 뜻한다. 매우 유용한 명령-라인 프로그램 이름이기도 하다.\ngrep은 패턴과 매칭되는 파일의 행을 찾아 화면에 뿌려준다. 예제 파일로, Salon 잡지 1988년 경쟁부문에서 하이쿠(haiku, 일본의 전통 단시) 3개를 담고 있는 파일을 사용례로 활용할 것이다. 이 예제 파일을 갖는 “writing” 하위 디렉토리에서 작업을 할 것이다:\n$ cd\n$ cd Desktop/data-shell/writing\n$ cat haiku.txt\n\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that.\n\n영원히 혹은 5년\n원본 하이쿠에 링크를 걸지 않았는데 이유는 Salon 사이트에 더 이상 보이는 것 같지 않아서다. Jeff Rothenberg가 말했듯이, “디지털 정보는 어느 것이 먼저 오든 영원한 영속성을 가지거나 혹은 5년이다.” 운이 좋은 경우 인기 콘텐트는 종종 백업된다.\n\n단어 “not”을 포함하는 행을 찾아 봅시다:\n$ grep not haiku.txt\n\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\n여기서 not이 찾고자 하는 패턴이다. grep 명령어는 파일을 뒤져 지정된 패턴과 매칭되는 것을 찾아낸다. 명령어를 사용하려면 grep을 타이핑하고 나서, 찾고자 하는 패턴을 지정하고 나서 검색하고자 하는 파일명(혹은 파일 다수)를 지정하면 된다.\n출력값으로 “not”을 포함하는 파일에 행이 3개 있다.\n다른 패턴을 시도해 보자. 이번에는 “The”이다.\n$ grep The haiku.txt\n\nThe Tao that is seen\n\"My Thesis\" not found.\n이번에는 문자 “The”를 포함한 행이 두줄 출력되었다. 하지만, 더 큰 단어 안에 포함된 단어(“Thesis”)도 함께 출력된다.\ngrep명령어에 -w 옵션을 주면, 단어 경계로 매칭을 제한해서, “day” 단어만을 가진 행만이 화면에 출력된다.\n매칭을 “The” 단어 자체만 포함하는 행만 매칭시키려면, grep명령어에 -w 옵션을 주게 되면, 단어 경계로 매칭을 제한시킨다.\n$ grep -w The haiku.txt\n\nThe Tao that is seen\n“단어 경계”는 행의 시작과 끝이 포함됨에 주의한다. 그래서 공백으로 감싼 단어는 해당사항이 없게 된다. 때때로, 단어 하나가 아닌, 문구를 찾고자 하는 경우도 있다. 인용부호 내부에 문구를 넣어 grep으로 작업하는 것이 편하다.\n$ grep -w \"is not\" haiku.txt\n\nToday it is not working\n지금까지 단일 단어 주위를 인용부호로 감쌀 필요가 없다는 것을 알고 있다. 하지만, 단어 다수를 검색할 때 인용부호를 사용하는 것이 유용하다. 이렇게 하면, 검색어(term) 혹은 검색 문구(phrase)와 검색 대상이 되는 파일 사이를 더 쉽게 구별하는데 도움을 준다. 나머지 예제에서는 인용부호를 사용한다.\n또다른 유용한 옵션은 -n으로, 매칭되는 행에 번호를 붙여 출력한다:\n$ grep -n \"it\" haiku.txt\n\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\n상기에서 5, 9, 10번째 행이 문자 “it”를 포함함을 확인할 수 있다.\n다른 유닉스 명령어와 마찬자기로 옵션(즉, 플래그)을 조합할 수 있다. 단어 “the”를 포함하는 행을 찾아보자. “the”를 포함하는 행을 찾는 -w 옵션과 매칭되는 행에 번호를 붙이는 -n을 조합할 수 있다:\n$ grep -n -w \"the\" haiku.txt\n\n2:Is not the true Tao, until\n6:and the presence of absence:\n이제 -i 옵션을 사용해서 대소분자 구분없이 매칭한다:\n$ grep -n -w -i \"the\" haiku.txt\n\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:\n이제, -v 옵션을 사용해서 뒤집어서 역으로 매칭을 한다. 즉, 단어 “the”를 포함하지 않는 행을 출력결과로 한다.\n$ grep -n -w -v \"the\" haiku.txt\n\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\ngrep 명령어는 옵션이 많다. grep 명령어에 대한 도움을 찾으려면, 다음 명령어를 타이핑한다:\n$ grep --help\n\nUsage: grep [OPTION]... PATTERN [FILE]...\nSearch for PATTERN in each FILE or standard input.\nPATTERN is, by default, a basic regular expression (BRE).\nExample: grep -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n\nMiscellaneous:\n...        ...        ...\n\ngrep 사용\n다음중 어떤 명령어가 다음 결과를 만들어낼까요?\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt\n\n\n해답 정답은 3번. -w 플래그는 온전한 단어만 매칭되는 것을 찾기 때문이다.\n\n\n\n와일드카드(Wildcards) \ngrep의 진정한 힘은 옵션에서 나오지 않고; 패턴에 와일드카드를 포함할 수 있다는 사실에서 나온다. (기술적 명칭은 정규 표현식(regular expressions)이고, “grep” 명령어의 “re”가 정규표현식을 나타낸다.) 정규 표현식은 복잡하기도 하지만 강력하기도 하다. 복잡한 검색을 하고자 한다면, 소프트웨어 카펜트리 웹사이트에서 수업내용을 볼 수 있다. 맛보기로, 다음과 같이 두번째 위치에 ’o’를 포함한 행을 찾을 수 있다:\n$ grep -E '^.o' haiku.txt\n\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\n-E 플래그를 사용해서 인용부호 안에 패턴을 넣어서 쉘이 해석하는 것을 방지한다. (예를 들어, 패턴에 ‘*’이 포함된다면, grep을 실행되기 전에 쉘이 먼저 전개하려 할 것이다.) 패턴에서’^‘은 행의 시작에 매칭을 고정시키는 역할을 한다.’.’은 한 문자만 매칭하고(쉘의 ’?’과 마찬가지로), ’o’는 실제 영문 ’o’와 매칭된다.\n\n\n개체(species) 추적하기\n정훈이는 한 디렉토리에 수백개 데이터 파일이 있는데, 형태는 다음과 같다:\n2013-11-05,deer,5\n2013-11-05,rabbit,22\n2013-11-05,raccoon,7\n2013-11-06,rabbit,19\n2013-11-06,deer,2\n명령라인에서 첫번째 인자로 개체(species), 두번째 인자로 디렉토리를 인자로 받는 쉘스크립트를 작성하고자 한다. 스크립트는 일자별로 관측된 개체수를 담아 species.txt 라는 파일로 저장하면 된다.\n2013-11-05,22\n2013-11-06,19\n스크립트를 작성하는데 다음에 나온 명령어를 적절한 순서로 파이프에 연결시키면 된다:\ncut -d : -f 2  \n>  \n|  \ngrep -w $1 -r $2  \n|  \n$1.txt  \ncut -d , -f 1,3  \n힌트: man grep 명령어를 사용해서 디렉토리에서 재귀적으로 텍스트를 grep하는지 찾아본다. man cut 명령어를 사용해서 한줄에 필드 하나 이상을 선택하는 방법을 살펴본다. data-shell/data/animal-counts/animals.txt 파일이 예제 파일로 제공되고 있다: > 해답 > > > grep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3  > $1.txt > > > 상기 쉘 스크립트를 다음과 같이 호출하면 된다: > > > $ bash count-species.sh bear . >\n\n\n작은 아낙네(Little Women)\nLouisa May Alcott가 지은 작은 아낙네(Little Women)를 친구과 함께 읽고 논쟁중이다. 책에는 Jo, Meg, Beth, Amy 네자매가 나온다. 친구가 Jo가 가장 많이 언급되었다고 생각한다. 하지만, 나는 Amy라고 확신한다. 운좋게도, 소설의 전체 텍스트를 담고 있는 LittleWomen.txt 파일이 있다(data-shell/writing/data/LittleWomen.txt). for 루프를 사용해서, 네자매 각각이 얼마나 언급되었는지 횟수를 개수할 수 있을까?\n힌트: 한가지 해결책은 grep, wc, | 명령어를 동원하는 것이지만, 다른 해결책으로 grep 옵션을 활용하는 것도 있다. There is often more than one way to solve a programming task, so a particular solution is usually chosen based on a combination of yielding the correct result, elegance, readability, and speed. 프로그래밍 문제를 푸는 방식은 한가지 이상 존재한다. 따라서, 올바른 결과를 도출해야 하고, 우아하고(elegance), 가독성이 좋고(readability), 속도를 다 함께 고려하여 선택한다.\n\n해답\nfor sis in Jo Meg Beth Amy\ndo\n  echo $sis:\n  grep -ow $sis LittleWomen.txt | wc -l\ndone\n또다른 해법으로, 다소 떨어지는 해답은 다음과 같다:\nfor sis in Jo Meg Beth Amy\ndo\n  echo $sis:\n  grep -ocw $sis LittleWomen.txt\ndone\n이 해답이 다소 뒤떨어지는 이유는 grep -c는 매칭되는 행 숫자만 출력하기 때문이다. 행마다 매칭되는 것이 하나 이상 되는 경우, 이 방법으로 매칭되는 전체 갯수는 낮아질 수 있기 때문이다.\n\n\ngrep이 파일의 행을 찾는 반면에, find 명령어는 파일 자체를 검색한다. 다시, find 명령어는 정말 옵션이 많다; 가장 간단한 것이 어떻게 동작하는지 시연하기 위해, 다음과 같은 디렉토리 구조를 사용할 것이다.\n\n\n\nFind 찾기 예제 파일 구조\n\n\nNelle의 writing 디렉토리는 haiku.txt로 불리는 파일 하나와, 하위 디렉토리 4개를 포함한다. thesis 디렉토리는 슬프게고 아무것도 담겨있지 않는 빈 파일 empty-draft.md만 있고, data 디렉토리는 LittleWomen.txt, one.txt과 two.txt 총 파일 3개를 포함하고, tools 디렉토리는 format과 stats 프로그램을 포함하고, oldtool 파일을 담고 있는 old 하위 디렉토리로 구성되어 있다.\n첫 명령어로, find .을 실행하자.\n$ find .\n\n.\n./data\n./data/one.txt\n./data/LittleWomen.txt\n./data/two.txt\n./tools\n./tools/format\n./tools/old\n./tools/old/oldtool\n./tools/stats\n./haiku.txt\n./thesis\n./thesis/empty-draft.md\n항상 그렇듯이, . 자체가 의미하는 바는 현재 작업 디렉토리로, 검색을 시작하는 디렉토리가 된다. find 출력결과로 현재 작업 디렉토리 아래 있는 모든 파일, 그리고 디렉토리명이 나온다. 출력결과가 쓸모없어 보이지만, find 명령어에 선택옵션이 많아서 출력결과를 필터할 수 있다. 이번 학습에서는 그중 일부만 다뤄볼 것이다.\n첫번째 선택옵션은 -type d로 “디렉토리인 것들”을 의미한다. 아니나 다를까, find의 출력에는 (.을 포함해서) 디렉토리 5개가 나온다.\n$ find . -type d\n\n./\n./data\n./thesis\n./tools\n./tools/old\nfind 명령어가 찾는 객체가 특별한 순서를 갖고 출력되는 것이 아님에 주목한다. -type d에서 -type f로 옵션을 변경하면, 대신에 모든 파일 목록이 나온다:\n$ find . -type f\n\n./haiku.txt\n./tools/stats\n./tools/old/oldtool\n./tools/format\n./thesis/empty-draft.md\n./data/one.txt\n./data/LittleWomen.txt\n./data/two.txt\n이제 이름으로 매칭을 하자:\n$ find . -name *.txt\n\n./haiku.txt\n모든 텍스트 파일을 찾기를 기대하지만, 단지 ./haiku.txt만을 화면에 출력한다. 문제는 명령문을 실행하기 전에, *같은 와일드카드 문자를 쉘이 전개하는 것이다. 현재 디렉토리에서 *.txt을 전개하면 haiku.txt이 되기 때문에, 실제 실행하는 명령어는 다음과 같다:\n$ find . -name haiku.txt\nfind 명령어는 사용자가 요청한 것만 수행한다; 사용자는 방금전에 잘못된 것을 요청했다.\n사용자가 원하는 것을 얻기 위해서, grep을 가지고 작업했던 것을 수행하자. 단일 인용부호에 *.txt을 넣어서 쉘이 와일드카드 *을 전개하지 못하게 한다. 이런 방식으로, find 명령어는 확장된 파일명 haiku.txt이 아닌, 실제로 *.txt 패턴을 얻는다:\n$ find . -name '*.txt'\n\n./data/one.txt\n./data/LittleWomen.txt\n./data/two.txt\n./haiku.txt\n\n목록(Listing) vs. 찾기(Finding)\n올바른 옵션이 주어진 상태에서, ls와 find 명령어를 사용해서 비슷한 작업을 수행하도록 만들 수 있다. 하지만, 정상 상태에서 ls는 가능한 모든 것을 목록으로 출력하는 반면에, find는 어떤 특성을 가진 것을 검색하고 보여준다는 점에서 차이가 난다.\n\n앞에서 언급했듯이, 명령-라인(command-line)의 힘은 도구를 조합하는데 있다. 파이프로 어떻게 조합하는지를 살펴봤고; 또 다른 기술을 살펴보자. 방금 보았듯이, find . -name '*.txt' 명령어는 현재 디렉토리 및 하위 디렉토리에 있는 모든 텍스트 파일 목록을 보여준다. 어떻게 하면 wc -l 명령어와 조합해서 모든 파일의 행을 개수할 수 있을까?\n가장 간단한 방법은 $() 내부에 find 명령어를 위치시키는 것이다:\n$ wc -l $(find . -name '*.txt')\n\n11 ./haiku.txt\n300 ./data/two.txt\n21022 ./data/LittleWomen.txt\n70 ./data/one.txt\n21403 total\n쉘이 상기 명령어를 실행할 때, 처음 수행하는 것은 $() 내부를 무엇이든 실행시키는 것이다. 그리고 나서 $() 표현식을 명령어의 출력 결과로 대체한다. find의 출력 결과가 파일 이름 4개, 즉, ./data/one.txt, ./data/LittleWomen.txt, ./data/two.txt, ./haiku.txt라서, 쉘은 다음과 같이 명령문을 구성하게 된다:\n$ wc -l ./data/one.txt ./data/LittleWomen.txt ./data/two.txt ./haiku.txt\n상기 명령문이 사용자가 원하는 것이다. 이러한 확장이 *과 ? 같은 와일드카드로 확장할 때, 정확하게 쉘이 수행하는 것이다. 하지만 자신의 “와일드카드”로 사용자가 원하는 임의 명령어를 사용해보자.\nfind와 grep을 함께 사용하는 것이 일반적이다. 먼저 find가 패턴을 매칭하는 파일을 찾고; 둘째로 grep이 또 다른 패턴과 매칭되는 파일 내부 행을 찾는다. 예제로 다음에 현재 부모 디렉토리에서 모든 .pdb 파일에 “FE” 문자열을 검색해서, 철(FE) 원자를 포함하는 PDB파일을 찾을 찾을 수 있다:\n$ grep \"FE\" $(find .. -name '*.pdb')\n\n../data/pdb/heme.pdb:ATOM     25 FE           1      -0.924   0.535  -0.518\n\n매칭후 빼내기\ngrep 명령어의 -v 옵션은 패턴 매칭을 반전시킨다. 패턴과 매칭하지 않는 행만 출력시킨다. 다음 명령어 중에서 어느 것이 /data 폴더에 s.txt로 끝나는 (예로, animals.txt 혹은 planets.txt), 하지만 net 단어는 포함하지 않게 모든 파일을 찾아낼까요? 정답을 생각해냈다면, data-shell 디렉토리에서 다음 명령어를 시도해본다.\n\nfind data -name '*s.txt' | grep -v net\nfind data -name *s.txt | grep -v net\ngrep -v \"temp\" $(find data -name '*s.txt')\nNone of the above.\n\n\n해답 정답은 1. 매칭 표현식을 인용부호로 감싸서 쉘이 전개하는 것을 방지시킨 상태로 find 명령어에 전개시킨다.\n2번은 틀렸는데, 이유는 쉘이 find 명령어에 와일드카드를 전달하는 대신에 *s.txt 을 전개하기 때문이다.\n3번은 틀렸는데, 이유는 파일명을 찾는 대신에 “temp”와 매칭되지 않는 행을 갖는 파일을 검색하기 때문이다.\n\n\n\n바이너리 파일(Binary File)\n텍스트 파일에 존재하는 것을 찾는 것에만 배타적으로 집중했다. 데이터가 만약 이미지로, 데이터베이스로, 혹은 다른 형식으로 저장되어 있다면 어떨까? 한가지 선택사항은 grep 같은 툴을 확장해서 텍스트가 아닌 형식도 다루게 한다. 이 접근법은 발생하지도 않았고, 아마도 그러지 않을 것이다. 왜냐하면 지원할 형식이 너무나도 많은 존재하기 때문이다.\n두번째 선택지는 데이터를 텍스트로 변환하거나, 데이터에서 텍스트같은 비트를 추출하는 것이다. 아마도 가장 흔한 접근법이 (정보를 추출하기 위해서) 각 데이터 형식마다 도구 하나만 개발하면 되기 때문이다. 한편으로, 이 접근법은 간단한 것을 쉽게 할 수 있게 한다. 부정적인 면으로 보면, 복잡한 것은 일반적으로 불가능하다.\n예를 들어, grep을 이리 저리 사용해서 이미지 파일에서 X와 Y 크기를 추출하는 프로그램을 작성하기는 쉽다. 하지만, 공식을 담고 있는 엑셀 같은 스프레드쉬트 셀에서 값을 찾아내는 것을 어떻게 작성할까? 세번째 선택지는 쉘과 텍스트 처리가 모두 한계를 가지고 있다는 것을 인지하고, 대신에 (R 혹은 파이썬 같은) 프로그램 언어를 사용하는 것이다. 이러한 시점이 왔을 때 쉘에서 너무 고생하지 마세요: R 혹은 파이썬을 포함한 많은 프로그래밍 언어가 많은 아이디어를 여기에서 가져왔다. 모방은 또한 칭찬의 가장 충심어린 형태이기도 하다.\n\n유닉스 쉘은 지금 사용하는 대부분의 사람보다 나이가 많다. 그토록 오랫동안 생존한 이유는 지금까지 만들어진 가장 생산성이 높은 프로그래밍 환경 중 하나 혹은 아마도 가장 생산성 높은 프로그래밍 환경이기 때문이다. 구문이 암호스러울 수도 있지만, 숙달한 사람은 다양한 명령어를 대화하듯이 실험하고 나서, 본인 작업을 자동화하는데 학습한 것을 사용한다. 그래픽 사용자 인터페이스(GUI)가 처음에는 더 좋을 수 있지만, 여전히 쉘이 최강이다. 화이트헤드(Alfred North Whitehead) 박사가 1911년 썼듯이 “문명은 생각없이 수행할 수 있는 중요한 작업의 수를 확장함으써 발전한다. (Civilization advances by extending the number of important operations which we can perform without thinking about them.)”\n\nfind 파이프라인 독해 능력\n다음 쉘 스크립트에 대해서 무슨 것을 수행하는지 짧은 설명문을 작성하세요.\nwc -l $(find . -name '*.dat') | sort -n\n\n해답\n\n현재 디렉토리에서 .dat 확장자를 갖는 모든 파일을 찾아내시오.\n파일 각각이 담고 있는 행을 개수한다.\n앞선 단계에서 나온 출력결과를 숫자로 인식해서 정렬시킨다.\n\n\n\n\n다른 특성을 갖는 파일 찾아내기\nfind 명령어에 “test”로 알려진 다른 기준을 제시해서 특정 속성을 갖는 파일을 지정할 수 있다. 예를 들어, 파일 생성시간, 파일 크기, 파일권한, 파일소유. man find 명령어를 사용해서 이를 살펴보고 나서, 지난 24시간 이내 ahmed 사용자가 변경시킨 모든 파일을 찾는 명령어를 적성한다.\n힌트 1: -type, -mtime, -user 플래그 세개를 모두 사용해야 한다. 힌트 2: -mtime 값을 음수를 지정해야 된다 — 왜일까?\n\n해답\nNelle의 홈이 작업 디렉토리라고 가정하고, 다음 명령어를 타이핑한다:\n$ find ./ -type f -mtime -1 -user ahmed"
  }
]